// generated with https://github.com/HearTao/open-typescript

declare module "typescript/lib/tsserverlibrary" {
    namespace ts {
        namespace server {
            namespace protocol {
                export import ApplicableRefactorInfo = ts.ApplicableRefactorInfo;
                export import ClassificationType = ts.ClassificationType;
                export import CompletionsTriggerCharacter = ts.CompletionsTriggerCharacter;
                export import CompletionTriggerKind = ts.CompletionTriggerKind;
                export import InlayHintKind = ts.InlayHintKind;
                export import OrganizeImportsMode = ts.OrganizeImportsMode;
                export import RefactorActionInfo = ts.RefactorActionInfo;
                export import RefactorTriggerReason = ts.RefactorTriggerReason;
                export import RenameInfoFailure = ts.RenameInfoFailure;
                export import SemicolonPreference = ts.SemicolonPreference;
                export import SignatureHelpCharacterTypedReason = ts.SignatureHelpCharacterTypedReason;
                export import SignatureHelpInvokedReason = ts.SignatureHelpInvokedReason;
                export import SignatureHelpParameter = ts.SignatureHelpParameter;
                export import SignatureHelpRetriggerCharacter = ts.SignatureHelpRetriggerCharacter;
                export import SignatureHelpRetriggeredReason = ts.SignatureHelpRetriggeredReason;
                export import SignatureHelpTriggerCharacter = ts.SignatureHelpTriggerCharacter;
                export import SignatureHelpTriggerReason = ts.SignatureHelpTriggerReason;
                export import SymbolDisplayPart = ts.SymbolDisplayPart;
                export import UserPreferences = ts.UserPreferences;
                type ChangePropertyTypes<T, Substitutions extends {
                    [K in keyof T]?: any;
                }> = {
                    [K in keyof T]: K extends keyof Substitutions ? Substitutions[K] : T[K];
                };
                type ChangeStringIndexSignature<T, NewStringIndexSignatureType> = {
                    [K in keyof T]: string extends K ? NewStringIndexSignatureType : T[K];
                };
                export enum CommandTypes {
                    JsxClosingTag = "jsxClosingTag",
                    LinkedEditingRange = "linkedEditingRange",
                    Brace = "brace",
                    BraceFull = "brace-full",
                    BraceCompletion = "braceCompletion",
                    GetSpanOfEnclosingComment = "getSpanOfEnclosingComment",
                    Change = "change",
                    Close = "close",
                    Completions = "completions",
                    CompletionInfo = "completionInfo",
                    CompletionsFull = "completions-full",
                    CompletionDetails = "completionEntryDetails",
                    CompletionDetailsFull = "completionEntryDetails-full",
                    CompileOnSaveAffectedFileList = "compileOnSaveAffectedFileList",
                    CompileOnSaveEmitFile = "compileOnSaveEmitFile",
                    Configure = "configure",
                    Definition = "definition",
                    DefinitionFull = "definition-full",
                    DefinitionAndBoundSpan = "definitionAndBoundSpan",
                    DefinitionAndBoundSpanFull = "definitionAndBoundSpan-full",
                    Implementation = "implementation",
                    ImplementationFull = "implementation-full",
                    EmitOutput = "emit-output",
                    Exit = "exit",
                    FileReferences = "fileReferences",
                    FileReferencesFull = "fileReferences-full",
                    Format = "format",
                    Formatonkey = "formatonkey",
                    FormatFull = "format-full",
                    FormatonkeyFull = "formatonkey-full",
                    FormatRangeFull = "formatRange-full",
                    Geterr = "geterr",
                    GeterrForProject = "geterrForProject",
                    SemanticDiagnosticsSync = "semanticDiagnosticsSync",
                    SyntacticDiagnosticsSync = "syntacticDiagnosticsSync",
                    SuggestionDiagnosticsSync = "suggestionDiagnosticsSync",
                    NavBar = "navbar",
                    NavBarFull = "navbar-full",
                    Navto = "navto",
                    NavtoFull = "navto-full",
                    NavTree = "navtree",
                    NavTreeFull = "navtree-full",
                    DocumentHighlights = "documentHighlights",
                    DocumentHighlightsFull = "documentHighlights-full",
                    Open = "open",
                    Quickinfo = "quickinfo",
                    QuickinfoFull = "quickinfo-full",
                    References = "references",
                    ReferencesFull = "references-full",
                    Reload = "reload",
                    Rename = "rename",
                    RenameInfoFull = "rename-full",
                    RenameLocationsFull = "renameLocations-full",
                    Saveto = "saveto",
                    SignatureHelp = "signatureHelp",
                    SignatureHelpFull = "signatureHelp-full",
                    FindSourceDefinition = "findSourceDefinition",
                    Status = "status",
                    TypeDefinition = "typeDefinition",
                    ProjectInfo = "projectInfo",
                    ReloadProjects = "reloadProjects",
                    Unknown = "unknown",
                    OpenExternalProject = "openExternalProject",
                    OpenExternalProjects = "openExternalProjects",
                    CloseExternalProject = "closeExternalProject",
                    SynchronizeProjectList = "synchronizeProjectList",
                    ApplyChangedToOpenFiles = "applyChangedToOpenFiles",
                    UpdateOpen = "updateOpen",
                    EncodedSyntacticClassificationsFull = "encodedSyntacticClassifications-full",
                    EncodedSemanticClassificationsFull = "encodedSemanticClassifications-full",
                    Cleanup = "cleanup",
                    GetOutliningSpans = "getOutliningSpans",
                    GetOutliningSpansFull = "outliningSpans",
                    TodoComments = "todoComments",
                    Indentation = "indentation",
                    DocCommentTemplate = "docCommentTemplate",
                    CompilerOptionsDiagnosticsFull = "compilerOptionsDiagnostics-full",
                    NameOrDottedNameSpan = "nameOrDottedNameSpan",
                    BreakpointStatement = "breakpointStatement",
                    CompilerOptionsForInferredProjects = "compilerOptionsForInferredProjects",
                    GetCodeFixes = "getCodeFixes",
                    GetCodeFixesFull = "getCodeFixes-full",
                    GetCombinedCodeFix = "getCombinedCodeFix",
                    GetCombinedCodeFixFull = "getCombinedCodeFix-full",
                    ApplyCodeActionCommand = "applyCodeActionCommand",
                    GetSupportedCodeFixes = "getSupportedCodeFixes",
                    GetApplicableRefactors = "getApplicableRefactors",
                    GetEditsForRefactor = "getEditsForRefactor",
                    GetMoveToRefactoringFileSuggestions = "getMoveToRefactoringFileSuggestions",
                    PreparePasteEdits = "preparePasteEdits",
                    GetPasteEdits = "getPasteEdits",
                    GetEditsForRefactorFull = "getEditsForRefactor-full",
                    OrganizeImports = "organizeImports",
                    OrganizeImportsFull = "organizeImports-full",
                    GetEditsForFileRename = "getEditsForFileRename",
                    GetEditsForFileRenameFull = "getEditsForFileRename-full",
                    ConfigurePlugin = "configurePlugin",
                    SelectionRange = "selectionRange",
                    SelectionRangeFull = "selectionRange-full",
                    ToggleLineComment = "toggleLineComment",
                    ToggleLineCommentFull = "toggleLineComment-full",
                    ToggleMultilineComment = "toggleMultilineComment",
                    ToggleMultilineCommentFull = "toggleMultilineComment-full",
                    CommentSelection = "commentSelection",
                    CommentSelectionFull = "commentSelection-full",
                    UncommentSelection = "uncommentSelection",
                    UncommentSelectionFull = "uncommentSelection-full",
                    PrepareCallHierarchy = "prepareCallHierarchy",
                    ProvideCallHierarchyIncomingCalls = "provideCallHierarchyIncomingCalls",
                    ProvideCallHierarchyOutgoingCalls = "provideCallHierarchyOutgoingCalls",
                    ProvideInlayHints = "provideInlayHints",
                    WatchChange = "watchChange",
                    MapCode = "mapCode",
                    CopilotRelated = "copilotRelated"
                }
                export interface Message {
                    seq: number;
                    type: "request" | "response" | "event";
                }
                export interface Request extends Message {
                    type: "request";
                    command: string;
                    arguments?: any;
                }
                export interface ReloadProjectsRequest extends Request {
                    command: CommandTypes.ReloadProjects;
                }
                export interface Event extends Message {
                    type: "event";
                    event: string;
                    body?: any;
                }
                export interface Response extends Message {
                    type: "response";
                    request_seq: number;
                    success: boolean;
                    command: string;
                    message?: string;
                    body?: any;
                    metadata?: unknown;
                    performanceData?: PerformanceData;
                }
                export interface PerformanceData {
                    updateGraphDurationMs?: number;
                    createAutoImportProviderProgramDurationMs?: number;
                    diagnosticsDuration?: FileDiagnosticPerformanceData[];
                }
                export type DiagnosticPerformanceData = {
                    [Kind in DiagnosticEventKind]?: number;
                };
                export interface FileDiagnosticPerformanceData extends DiagnosticPerformanceData {
                    file: string;
                }
                export interface FileRequestArgs {
                    file: string;
                    projectFileName?: string;
                }
                export interface StatusRequest extends Request {
                    command: CommandTypes.Status;
                }
                export interface StatusResponseBody {
                    version: string;
                }
                export interface StatusResponse extends Response {
                    body: StatusResponseBody;
                }
                export interface DocCommentTemplateRequest extends FileLocationRequest {
                    command: CommandTypes.DocCommentTemplate;
                }
                export interface DocCommandTemplateResponse extends Response {
                    body?: TextInsertion;
                }
                export interface TodoCommentRequest extends FileRequest {
                    command: CommandTypes.TodoComments;
                    arguments: TodoCommentRequestArgs;
                }
                export interface TodoCommentRequestArgs extends FileRequestArgs {
                    descriptors: TodoCommentDescriptor[];
                }
                export interface TodoCommentsResponse extends Response {
                    body?: TodoComment[];
                }
                export interface SpanOfEnclosingCommentRequest extends FileLocationRequest {
                    command: CommandTypes.GetSpanOfEnclosingComment;
                    arguments: SpanOfEnclosingCommentRequestArgs;
                }
                export interface SpanOfEnclosingCommentRequestArgs extends FileLocationRequestArgs {
                    onlyMultiLine: boolean;
                }
                export interface OutliningSpansRequest extends FileRequest {
                    command: CommandTypes.GetOutliningSpans;
                }
                export type OutliningSpan = ChangePropertyTypes<ts.OutliningSpan, {
                    textSpan: TextSpan;
                    hintSpan: TextSpan;
                }>;
                export interface OutliningSpansResponse extends Response {
                    body?: OutliningSpan[];
                }
                export interface OutliningSpansRequestFull extends FileRequest {
                    command: CommandTypes.GetOutliningSpansFull;
                }
                export interface OutliningSpansResponseFull extends Response {
                    body?: ts.OutliningSpan[];
                }
                export interface IndentationRequest extends FileLocationRequest {
                    command: CommandTypes.Indentation;
                    arguments: IndentationRequestArgs;
                }
                export interface IndentationResponse extends Response {
                    body?: IndentationResult;
                }
                export interface IndentationResult {
                    position: number;
                    indentation: number;
                }
                export interface IndentationRequestArgs extends FileLocationRequestArgs {
                    options?: EditorSettings;
                }
                export interface ProjectInfoRequestArgs extends FileRequestArgs {
                    needFileNameList: boolean;
                    needDefaultConfiguredProjectInfo?: boolean;
                }
                export interface ProjectInfoRequest extends Request {
                    command: CommandTypes.ProjectInfo;
                    arguments: ProjectInfoRequestArgs;
                }
                export interface CompilerOptionsDiagnosticsRequest extends Request {
                    arguments: CompilerOptionsDiagnosticsRequestArgs;
                }
                export interface CompilerOptionsDiagnosticsRequestArgs {
                    projectFileName: string;
                }
                export interface DefaultConfiguredProjectInfo {
                    notMatchedByConfig?: readonly string[];
                    notInProject?: readonly string[];
                    defaultProject?: string;
                }
                export interface ProjectInfo {
                    configFileName: string;
                    fileNames?: string[];
                    languageServiceDisabled?: boolean;
                    configuredProjectInfo?: DefaultConfiguredProjectInfo;
                }
                export interface DiagnosticWithLinePosition {
                    message: string;
                    start: number;
                    length: number;
                    startLocation: Location;
                    endLocation: Location;
                    category: string;
                    code: number;
                    reportsUnnecessary?: {};
                    reportsDeprecated?: {};
                    relatedInformation?: DiagnosticRelatedInformation[];
                }
                export interface ProjectInfoResponse extends Response {
                    body?: ProjectInfo;
                }
                export interface FileRequest extends Request {
                    arguments: FileRequestArgs;
                }
                export interface FileLocationRequestArgs extends FileRequestArgs {
                    line: number;
                    offset: number;
                    position?: number;
                }
                export type FileLocationOrRangeRequestArgs = FileLocationRequestArgs | FileRangeRequestArgs;
                export interface GetApplicableRefactorsRequest extends Request {
                    command: CommandTypes.GetApplicableRefactors;
                    arguments: GetApplicableRefactorsRequestArgs;
                }
                export type GetApplicableRefactorsRequestArgs = FileLocationOrRangeRequestArgs & {
                    triggerReason?: RefactorTriggerReason;
                    kind?: string;
                    includeInteractiveActions?: boolean;
                };
                export interface GetApplicableRefactorsResponse extends Response {
                    body?: ApplicableRefactorInfo[];
                }
                export interface GetMoveToRefactoringFileSuggestionsRequest extends Request {
                    command: CommandTypes.GetMoveToRefactoringFileSuggestions;
                    arguments: GetMoveToRefactoringFileSuggestionsRequestArgs;
                }
                export type GetMoveToRefactoringFileSuggestionsRequestArgs = FileLocationOrRangeRequestArgs & {
                    kind?: string;
                };
                export interface GetMoveToRefactoringFileSuggestions extends Response {
                    body: {
                        newFileName: string;
                        files: string[];
                    };
                }
                export interface PreparePasteEditsRequest extends FileRequest {
                    command: CommandTypes.PreparePasteEdits;
                    arguments: PreparePasteEditsRequestArgs;
                }
                export interface PreparePasteEditsRequestArgs extends FileRequestArgs {
                    copiedTextSpan: TextSpan[];
                }
                export interface PreparePasteEditsResponse extends Response {
                    body: boolean;
                }
                export interface GetPasteEditsRequest extends Request {
                    command: CommandTypes.GetPasteEdits;
                    arguments: GetPasteEditsRequestArgs;
                }
                export interface GetPasteEditsRequestArgs extends FileRequestArgs {
                    pastedText: string[];
                    pasteLocations: TextSpan[];
                    copiedFrom?: {
                        file: string;
                        spans: TextSpan[];
                    };
                }
                export interface GetPasteEditsResponse extends Response {
                    body: PasteEditsAction;
                }
                export interface PasteEditsAction {
                    edits: FileCodeEdits[];
                    fixId?: {};
                }
                export interface GetEditsForRefactorRequest extends Request {
                    command: CommandTypes.GetEditsForRefactor;
                    arguments: GetEditsForRefactorRequestArgs;
                }
                export type GetEditsForRefactorRequestArgs = FileLocationOrRangeRequestArgs & {
                    refactor: string;
                    action: string;
                    interactiveRefactorArguments?: InteractiveRefactorArguments;
                };
                export interface GetEditsForRefactorResponse extends Response {
                    body?: RefactorEditInfo;
                }
                export interface RefactorEditInfo {
                    edits: FileCodeEdits[];
                    renameLocation?: Location;
                    renameFilename?: string;
                    notApplicableReason?: string;
                }
                export interface OrganizeImportsRequest extends Request {
                    command: CommandTypes.OrganizeImports;
                    arguments: OrganizeImportsRequestArgs;
                }
                export type OrganizeImportsScope = GetCombinedCodeFixScope;
                export interface OrganizeImportsRequestArgs {
                    scope: OrganizeImportsScope;
                    skipDestructiveCodeActions?: boolean;
                    mode?: OrganizeImportsMode;
                }
                export interface OrganizeImportsResponse extends Response {
                    body: readonly FileCodeEdits[];
                }
                export interface GetEditsForFileRenameRequest extends Request {
                    command: CommandTypes.GetEditsForFileRename;
                    arguments: GetEditsForFileRenameRequestArgs;
                }
                export interface GetEditsForFileRenameRequestArgs {
                    readonly oldFilePath: string;
                    readonly newFilePath: string;
                }
                export interface GetEditsForFileRenameResponse extends Response {
                    body: readonly FileCodeEdits[];
                }
                export interface CodeFixRequest extends Request {
                    command: CommandTypes.GetCodeFixes;
                    arguments: CodeFixRequestArgs;
                }
                export interface GetCombinedCodeFixRequest extends Request {
                    command: CommandTypes.GetCombinedCodeFix;
                    arguments: GetCombinedCodeFixRequestArgs;
                }
                export interface GetCombinedCodeFixResponse extends Response {
                    body: CombinedCodeActions;
                }
                export interface ApplyCodeActionCommandRequest extends Request {
                    command: CommandTypes.ApplyCodeActionCommand;
                    arguments: ApplyCodeActionCommandRequestArgs;
                }
                export interface ApplyCodeActionCommandResponse extends Response {
                }
                export interface FileRangeRequestArgs extends FileRequestArgs, FileRange {
                    startPosition?: number;
                    endPosition?: number;
                }
                export interface CodeFixRequestArgs extends FileRangeRequestArgs {
                    errorCodes: readonly number[];
                }
                export interface GetCombinedCodeFixRequestArgs {
                    scope: GetCombinedCodeFixScope;
                    fixId: {};
                }
                export interface GetCombinedCodeFixScope {
                    type: "file";
                    args: FileRequestArgs;
                }
                export interface ApplyCodeActionCommandRequestArgs {
                    command: {};
                }
                export interface GetCodeFixesResponse extends Response {
                    body?: CodeAction[];
                }
                export interface FileLocationRequest extends FileRequest {
                    arguments: FileLocationRequestArgs;
                }
                export interface GetSupportedCodeFixesRequest extends Request {
                    command: CommandTypes.GetSupportedCodeFixes;
                    arguments?: Partial<FileRequestArgs>;
                }
                export interface GetSupportedCodeFixesResponse extends Response {
                    body?: string[];
                }
                export interface EncodedSyntacticClassificationsRequest extends FileRequest {
                    arguments: EncodedSyntacticClassificationsRequestArgs;
                }
                export interface EncodedSyntacticClassificationsRequestArgs extends FileRequestArgs {
                    start: number;
                    length: number;
                }
                export interface EncodedSemanticClassificationsRequest extends FileRequest {
                    arguments: EncodedSemanticClassificationsRequestArgs;
                }
                export interface EncodedSemanticClassificationsRequestArgs extends FileRequestArgs {
                    start: number;
                    length: number;
                    format?: "original" | "2020";
                }
                export interface EncodedSemanticClassificationsResponse extends Response {
                    body?: EncodedSemanticClassificationsResponseBody;
                }
                export interface EncodedSemanticClassificationsResponseBody {
                    endOfLineState: EndOfLineState;
                    spans: number[];
                }
                export interface DocumentHighlightsRequestArgs extends FileLocationRequestArgs {
                    filesToSearch: string[];
                }
                export interface DefinitionRequest extends FileLocationRequest {
                    command: CommandTypes.Definition;
                }
                export interface DefinitionAndBoundSpanRequest extends FileLocationRequest {
                    readonly command: CommandTypes.DefinitionAndBoundSpan;
                }
                export interface FindSourceDefinitionRequest extends FileLocationRequest {
                    readonly command: CommandTypes.FindSourceDefinition;
                }
                export interface DefinitionAndBoundSpanResponse extends Response {
                    readonly body: DefinitionInfoAndBoundSpan;
                }
                export interface EmitOutputRequest extends FileRequest {
                    command: CommandTypes.EmitOutput;
                    arguments: EmitOutputRequestArgs;
                }
                export interface EmitOutputRequestArgs extends FileRequestArgs {
                    includeLinePosition?: boolean;
                    richResponse?: boolean;
                }
                export interface EmitOutputResponse extends Response {
                    readonly body: EmitOutput | ts.EmitOutput;
                }
                export interface EmitOutput {
                    outputFiles: OutputFile[];
                    emitSkipped: boolean;
                    diagnostics: Diagnostic[] | DiagnosticWithLinePosition[];
                }
                export interface TypeDefinitionRequest extends FileLocationRequest {
                    command: CommandTypes.TypeDefinition;
                }
                export interface ImplementationRequest extends FileLocationRequest {
                    command: CommandTypes.Implementation;
                }
                export interface Location {
                    line: number;
                    offset: number;
                }
                export interface TextSpan {
                    start: Location;
                    end: Location;
                }
                export interface FileSpan extends TextSpan {
                    file: string;
                }
                export interface JSDocTagInfo {
                    name: string;
                    text?: string | SymbolDisplayPart[];
                }
                export interface TextSpanWithContext extends TextSpan {
                    contextStart?: Location;
                    contextEnd?: Location;
                }
                export interface FileSpanWithContext extends FileSpan, TextSpanWithContext {
                }
                export interface DefinitionInfo extends FileSpanWithContext {
                    unverified?: boolean;
                }
                export interface DefinitionInfoAndBoundSpan {
                    definitions: readonly DefinitionInfo[];
                    textSpan: TextSpan;
                }
                export interface DefinitionResponse extends Response {
                    body?: DefinitionInfo[];
                }
                export interface DefinitionInfoAndBoundSpanResponse extends Response {
                    body?: DefinitionInfoAndBoundSpan;
                }
                export type DefinitionInfoAndBoundSpanReponse = DefinitionInfoAndBoundSpanResponse;
                export interface TypeDefinitionResponse extends Response {
                    body?: FileSpanWithContext[];
                }
                export interface ImplementationResponse extends Response {
                    body?: FileSpanWithContext[];
                }
                export interface BraceCompletionRequest extends FileLocationRequest {
                    command: CommandTypes.BraceCompletion;
                    arguments: BraceCompletionRequestArgs;
                }
                export interface BraceCompletionRequestArgs extends FileLocationRequestArgs {
                    openingBrace: string;
                }
                export interface JsxClosingTagRequest extends FileLocationRequest {
                    readonly command: CommandTypes.JsxClosingTag;
                    readonly arguments: JsxClosingTagRequestArgs;
                }
                export interface JsxClosingTagRequestArgs extends FileLocationRequestArgs {
                }
                export interface JsxClosingTagResponse extends Response {
                    readonly body: TextInsertion;
                }
                export interface LinkedEditingRangeRequest extends FileLocationRequest {
                    readonly command: CommandTypes.LinkedEditingRange;
                }
                export interface LinkedEditingRangesBody {
                    ranges: TextSpan[];
                    wordPattern?: string;
                }
                export interface LinkedEditingRangeResponse extends Response {
                    readonly body: LinkedEditingRangesBody;
                }
                export interface DocumentHighlightsRequest extends FileLocationRequest {
                    command: CommandTypes.DocumentHighlights;
                    arguments: DocumentHighlightsRequestArgs;
                }
                export interface HighlightSpan extends TextSpanWithContext {
                    kind: HighlightSpanKind;
                }
                export interface DocumentHighlightsItem {
                    file: string;
                    highlightSpans: HighlightSpan[];
                }
                export interface DocumentHighlightsResponse extends Response {
                    body?: DocumentHighlightsItem[];
                }
                export interface ReferencesRequest extends FileLocationRequest {
                    command: CommandTypes.References;
                }
                export interface ReferencesResponseItem extends FileSpanWithContext {
                    lineText?: string;
                    isWriteAccess: boolean;
                    isDefinition?: boolean;
                }
                export interface ReferencesResponseBody {
                    refs: readonly ReferencesResponseItem[];
                    symbolName: string;
                    symbolStartOffset: number;
                    symbolDisplayString: string;
                }
                export interface ReferencesResponse extends Response {
                    body?: ReferencesResponseBody;
                }
                export interface FileReferencesRequest extends FileRequest {
                    command: CommandTypes.FileReferences;
                }
                export interface FileReferencesResponseBody {
                    refs: readonly ReferencesResponseItem[];
                    symbolName: string;
                }
                export interface FileReferencesResponse extends Response {
                    body?: FileReferencesResponseBody;
                }
                export interface RenameRequestArgs extends FileLocationRequestArgs {
                    findInComments?: boolean;
                    findInStrings?: boolean;
                }
                export interface RenameRequest extends FileLocationRequest {
                    command: CommandTypes.Rename;
                    arguments: RenameRequestArgs;
                }
                export interface RenameFullRequest extends FileLocationRequest {
                    readonly command: CommandTypes.RenameLocationsFull;
                    readonly arguments: RenameRequestArgs;
                }
                export interface RenameFullResponse extends Response {
                    readonly body: readonly RenameLocation[];
                }
                export type RenameInfo = RenameInfoSuccess | RenameInfoFailure;
                export type RenameInfoSuccess = ChangePropertyTypes<ts.RenameInfoSuccess, {
                    triggerSpan: TextSpan;
                }>;
                export interface SpanGroup {
                    file: string;
                    locs: RenameTextSpan[];
                }
                export interface RenameTextSpan extends TextSpanWithContext {
                    readonly prefixText?: string;
                    readonly suffixText?: string;
                }
                export interface RenameResponseBody {
                    info: RenameInfo;
                    locs: readonly SpanGroup[];
                }
                export interface RenameResponse extends Response {
                    body?: RenameResponseBody;
                }
                export interface ExternalFile {
                    fileName: string;
                    scriptKind?: ScriptKindName | ScriptKind;
                    hasMixedContent?: boolean;
                    content?: string;
                }
                export interface ExternalProject {
                    projectFileName: string;
                    rootFiles: ExternalFile[];
                    options: ExternalProjectCompilerOptions;
                    typeAcquisition?: TypeAcquisition;
                }
                export interface CompileOnSaveMixin {
                    compileOnSave?: boolean;
                }
                export type ExternalProjectCompilerOptions = CompilerOptions & CompileOnSaveMixin & WatchOptions;
                export interface ProjectVersionInfo {
                    projectName: string;
                    isInferred: boolean;
                    version: number;
                    options: ts.CompilerOptions;
                    languageServiceDisabled: boolean;
                    lastFileExceededProgramSize?: string;
                }
                export interface FileWithProjectReferenceRedirectInfo {
                    fileName: string;
                    isSourceOfProjectReferenceRedirect: boolean;
                }
                export interface ProjectChanges {
                    added: string[] | FileWithProjectReferenceRedirectInfo[];
                    removed: string[] | FileWithProjectReferenceRedirectInfo[];
                    updated: string[] | FileWithProjectReferenceRedirectInfo[];
                    updatedRedirects?: FileWithProjectReferenceRedirectInfo[];
                }
                export interface ProjectFiles {
                    info?: ProjectVersionInfo;
                    files?: string[] | FileWithProjectReferenceRedirectInfo[];
                    changes?: ProjectChanges;
                }
                export interface ProjectFilesWithDiagnostics extends ProjectFiles {
                    projectErrors: DiagnosticWithLinePosition[];
                }
                export interface ChangedOpenFile {
                    fileName: string;
                    changes: TextChange[];
                }
                export interface ConfigureRequestArguments {
                    hostInfo?: string;
                    file?: string;
                    formatOptions?: FormatCodeSettings;
                    preferences?: UserPreferences;
                    extraFileExtensions?: FileExtensionInfo[];
                    watchOptions?: WatchOptions;
                }
                export enum WatchFileKind {
                    FixedPollingInterval = "FixedPollingInterval",
                    PriorityPollingInterval = "PriorityPollingInterval",
                    DynamicPriorityPolling = "DynamicPriorityPolling",
                    FixedChunkSizePolling = "FixedChunkSizePolling",
                    UseFsEvents = "UseFsEvents",
                    UseFsEventsOnParentDirectory = "UseFsEventsOnParentDirectory"
                }
                export enum WatchDirectoryKind {
                    UseFsEvents = "UseFsEvents",
                    FixedPollingInterval = "FixedPollingInterval",
                    DynamicPriorityPolling = "DynamicPriorityPolling",
                    FixedChunkSizePolling = "FixedChunkSizePolling"
                }
                export enum PollingWatchKind {
                    FixedInterval = "FixedInterval",
                    PriorityInterval = "PriorityInterval",
                    DynamicPriority = "DynamicPriority",
                    FixedChunkSize = "FixedChunkSize"
                }
                export interface WatchOptions {
                    watchFile?: WatchFileKind | ts.WatchFileKind;
                    watchDirectory?: WatchDirectoryKind | ts.WatchDirectoryKind;
                    fallbackPolling?: PollingWatchKind | ts.PollingWatchKind;
                    synchronousWatchDirectory?: boolean;
                    excludeDirectories?: string[];
                    excludeFiles?: string[];
                    [option: string]: CompilerOptionsValue | undefined;
                }
                export interface ConfigureRequest extends Request {
                    command: CommandTypes.Configure;
                    arguments: ConfigureRequestArguments;
                }
                export interface ConfigureResponse extends Response {
                }
                export interface ConfigurePluginRequestArguments {
                    pluginName: string;
                    configuration: any;
                }
                export interface ConfigurePluginRequest extends Request {
                    command: CommandTypes.ConfigurePlugin;
                    arguments: ConfigurePluginRequestArguments;
                }
                export interface ConfigurePluginResponse extends Response {
                }
                export interface SelectionRangeRequest extends FileRequest {
                    command: CommandTypes.SelectionRange;
                    arguments: SelectionRangeRequestArgs;
                }
                export interface SelectionRangeRequestArgs extends FileRequestArgs {
                    locations: Location[];
                }
                export interface SelectionRangeResponse extends Response {
                    body?: SelectionRange[];
                }
                export interface SelectionRange {
                    textSpan: TextSpan;
                    parent?: SelectionRange;
                }
                export interface ToggleLineCommentRequest extends FileRequest {
                    command: CommandTypes.ToggleLineComment;
                    arguments: FileRangeRequestArgs;
                }
                export interface ToggleMultilineCommentRequest extends FileRequest {
                    command: CommandTypes.ToggleMultilineComment;
                    arguments: FileRangeRequestArgs;
                }
                export interface CommentSelectionRequest extends FileRequest {
                    command: CommandTypes.CommentSelection;
                    arguments: FileRangeRequestArgs;
                }
                export interface UncommentSelectionRequest extends FileRequest {
                    command: CommandTypes.UncommentSelection;
                    arguments: FileRangeRequestArgs;
                }
                export interface OpenRequestArgs extends FileRequestArgs {
                    fileContent?: string;
                    scriptKindName?: ScriptKindName;
                    projectRootPath?: string;
                }
                export type ScriptKindName = "TS" | "JS" | "TSX" | "JSX";
                export interface OpenRequest extends Request {
                    command: CommandTypes.Open;
                    arguments: OpenRequestArgs;
                }
                export interface OpenExternalProjectRequest extends Request {
                    command: CommandTypes.OpenExternalProject;
                    arguments: OpenExternalProjectArgs;
                }
                export type OpenExternalProjectArgs = ExternalProject;
                export interface OpenExternalProjectsRequest extends Request {
                    command: CommandTypes.OpenExternalProjects;
                    arguments: OpenExternalProjectsArgs;
                }
                export interface OpenExternalProjectsArgs {
                    projects: ExternalProject[];
                }
                export interface OpenExternalProjectResponse extends Response {
                }
                export interface OpenExternalProjectsResponse extends Response {
                }
                export interface CloseExternalProjectRequest extends Request {
                    command: CommandTypes.CloseExternalProject;
                    arguments: CloseExternalProjectRequestArgs;
                }
                export interface CloseExternalProjectRequestArgs {
                    projectFileName: string;
                }
                export interface CloseExternalProjectResponse extends Response {
                }
                export interface SynchronizeProjectListRequest extends Request {
                    arguments: SynchronizeProjectListRequestArgs;
                }
                export interface SynchronizeProjectListRequestArgs {
                    knownProjects: ProjectVersionInfo[];
                    includeProjectReferenceRedirectInfo?: boolean;
                }
                export interface ApplyChangedToOpenFilesRequest extends Request {
                    arguments: ApplyChangedToOpenFilesRequestArgs;
                }
                export interface ApplyChangedToOpenFilesRequestArgs {
                    openFiles?: ExternalFile[];
                    changedFiles?: ChangedOpenFile[];
                    closedFiles?: string[];
                }
                export interface UpdateOpenRequest extends Request {
                    command: CommandTypes.UpdateOpen;
                    arguments: UpdateOpenRequestArgs;
                }
                export interface UpdateOpenRequestArgs {
                    openFiles?: OpenRequestArgs[];
                    changedFiles?: FileCodeEdits[];
                    closedFiles?: string[];
                }
                export type InferredProjectCompilerOptions = ExternalProjectCompilerOptions & TypeAcquisition;
                export interface SetCompilerOptionsForInferredProjectsRequest extends Request {
                    command: CommandTypes.CompilerOptionsForInferredProjects;
                    arguments: SetCompilerOptionsForInferredProjectsArgs;
                }
                export interface SetCompilerOptionsForInferredProjectsArgs {
                    options: InferredProjectCompilerOptions;
                    projectRootPath?: string;
                }
                export interface SetCompilerOptionsForInferredProjectsResponse extends Response {
                }
                export interface ExitRequest extends Request {
                    command: CommandTypes.Exit;
                }
                export interface CloseRequest extends FileRequest {
                    command: CommandTypes.Close;
                }
                export interface WatchChangeRequest extends Request {
                    command: CommandTypes.WatchChange;
                    arguments: WatchChangeRequestArgs | readonly WatchChangeRequestArgs[];
                }
                export interface WatchChangeRequestArgs {
                    id: number;
                    created?: string[];
                    deleted?: string[];
                    updated?: string[];
                }
                export interface CompileOnSaveAffectedFileListRequest extends FileRequest {
                    command: CommandTypes.CompileOnSaveAffectedFileList;
                }
                export interface CompileOnSaveAffectedFileListSingleProject {
                    projectFileName: string;
                    fileNames: string[];
                    projectUsesOutFile: boolean;
                }
                export interface CompileOnSaveAffectedFileListResponse extends Response {
                    body: CompileOnSaveAffectedFileListSingleProject[];
                }
                export interface CompileOnSaveEmitFileRequest extends FileRequest {
                    command: CommandTypes.CompileOnSaveEmitFile;
                    arguments: CompileOnSaveEmitFileRequestArgs;
                }
                export interface CompileOnSaveEmitFileRequestArgs extends FileRequestArgs {
                    forced?: boolean;
                    includeLinePosition?: boolean;
                    richResponse?: boolean;
                }
                export interface CompileOnSaveEmitFileResponse extends Response {
                    body: boolean | EmitResult;
                }
                export interface EmitResult {
                    emitSkipped: boolean;
                    diagnostics: Diagnostic[] | DiagnosticWithLinePosition[];
                }
                export interface QuickInfoRequest extends FileLocationRequest {
                    command: CommandTypes.Quickinfo;
                    arguments: FileLocationRequestArgs;
                }
                export interface QuickInfoRequestArgs extends FileLocationRequestArgs {
                    verbosityLevel?: number;
                }
                export interface QuickInfoResponseBody {
                    kind: ScriptElementKind;
                    kindModifiers: string;
                    start: Location;
                    end: Location;
                    displayString: string;
                    documentation: string | SymbolDisplayPart[];
                    tags: JSDocTagInfo[];
                    canIncreaseVerbosityLevel?: boolean;
                }
                export interface QuickInfoResponse extends Response {
                    body?: QuickInfoResponseBody;
                }
                export interface FormatRequestArgs extends FileLocationRequestArgs {
                    endLine: number;
                    endOffset: number;
                    endPosition?: number;
                    options?: FormatCodeSettings;
                }
                export interface FormatRequest extends FileLocationRequest {
                    command: CommandTypes.Format;
                    arguments: FormatRequestArgs;
                }
                export interface CodeEdit {
                    start: Location;
                    end: Location;
                    newText: string;
                }
                export interface FileCodeEdits {
                    fileName: string;
                    textChanges: CodeEdit[];
                }
                export interface CodeFixResponse extends Response {
                    body?: CodeFixAction[];
                }
                export interface CodeAction {
                    description: string;
                    changes: FileCodeEdits[];
                    commands?: {}[];
                }
                export interface CombinedCodeActions {
                    changes: readonly FileCodeEdits[];
                    commands?: readonly {}[];
                }
                export interface CodeFixAction extends CodeAction {
                    fixName: string;
                    fixId?: {};
                    fixAllDescription?: string;
                }
                export interface FormatResponse extends Response {
                    body?: CodeEdit[];
                }
                export interface FormatOnKeyRequestArgs extends FileLocationRequestArgs {
                    key: string;
                    options?: FormatCodeSettings;
                }
                export interface FormatOnKeyRequest extends FileLocationRequest {
                    command: CommandTypes.Formatonkey;
                    arguments: FormatOnKeyRequestArgs;
                }
                export interface CompletionsRequestArgs extends FileLocationRequestArgs {
                    prefix?: string;
                    triggerCharacter?: CompletionsTriggerCharacter;
                    triggerKind?: CompletionTriggerKind;
                    includeExternalModuleExports?: boolean;
                    includeInsertTextCompletions?: boolean;
                }
                export interface CompletionsRequest extends FileLocationRequest {
                    command: CommandTypes.Completions | CommandTypes.CompletionInfo;
                    arguments: CompletionsRequestArgs;
                }
                export interface CompletionDetailsRequestArgs extends FileLocationRequestArgs {
                    entryNames: (string | CompletionEntryIdentifier)[];
                }
                export interface CompletionEntryIdentifier {
                    name: string;
                    source?: string;
                    data?: unknown;
                }
                export interface CompletionDetailsRequest extends FileLocationRequest {
                    command: CommandTypes.CompletionDetails;
                    arguments: CompletionDetailsRequestArgs;
                }
                export interface JSDocLinkDisplayPart extends SymbolDisplayPart {
                    target: FileSpan;
                }
                export type CompletionEntry = ChangePropertyTypes<Omit<ts.CompletionEntry, "symbol">, {
                    replacementSpan: TextSpan;
                    data: unknown;
                }>;
                export type CompletionEntryDetails = ChangePropertyTypes<ts.CompletionEntryDetails, {
                    tags: JSDocTagInfo[];
                    codeActions: CodeAction[];
                }>;
                export interface CompletionsResponse extends Response {
                    body?: CompletionEntry[];
                }
                export interface CompletionInfoResponse extends Response {
                    body?: CompletionInfo;
                }
                export type CompletionInfo = ChangePropertyTypes<ts.CompletionInfo, {
                    entries: readonly CompletionEntry[];
                    optionalReplacementSpan: TextSpan;
                }>;
                export interface CompletionDetailsResponse extends Response {
                    body?: CompletionEntryDetails[];
                }
                export type SignatureHelpItem = ChangePropertyTypes<ts.SignatureHelpItem, {
                    tags: JSDocTagInfo[];
                }>;
                export interface SignatureHelpItems {
                    items: SignatureHelpItem[];
                    applicableSpan: TextSpan;
                    selectedItemIndex: number;
                    argumentIndex: number;
                    argumentCount: number;
                }
                export interface SignatureHelpRequestArgs extends FileLocationRequestArgs {
                    triggerReason?: SignatureHelpTriggerReason;
                }
                export interface SignatureHelpRequest extends FileLocationRequest {
                    command: CommandTypes.SignatureHelp;
                    arguments: SignatureHelpRequestArgs;
                }
                export interface SignatureHelpResponse extends Response {
                    body?: SignatureHelpItems;
                }
                export interface InlayHintsRequestArgs extends FileRequestArgs {
                    start: number;
                    length: number;
                }
                export interface InlayHintsRequest extends Request {
                    command: CommandTypes.ProvideInlayHints;
                    arguments: InlayHintsRequestArgs;
                }
                export type InlayHintItem = ChangePropertyTypes<ts.InlayHint, {
                    position: Location;
                    displayParts: InlayHintItemDisplayPart[];
                }>;
                export interface InlayHintItemDisplayPart {
                    text: string;
                    span?: FileSpan;
                }
                export interface InlayHintsResponse extends Response {
                    body?: InlayHintItem[];
                }
                export interface MapCodeRequestArgs extends FileRequestArgs {
                    mapping: MapCodeRequestDocumentMapping;
                }
                export interface MapCodeRequestDocumentMapping {
                    contents: string[];
                    focusLocations?: TextSpan[][];
                }
                export interface MapCodeRequest extends FileRequest {
                    command: CommandTypes.MapCode;
                    arguments: MapCodeRequestArgs;
                }
                export interface MapCodeResponse extends Response {
                    body: readonly FileCodeEdits[];
                }
                export interface SemanticDiagnosticsSyncRequest extends FileRequest {
                    command: CommandTypes.SemanticDiagnosticsSync;
                    arguments: SemanticDiagnosticsSyncRequestArgs;
                }
                export interface SemanticDiagnosticsSyncRequestArgs extends FileRequestArgs {
                    includeLinePosition?: boolean;
                }
                export interface SemanticDiagnosticsSyncResponse extends Response {
                    body?: Diagnostic[] | DiagnosticWithLinePosition[];
                }
                export interface SuggestionDiagnosticsSyncRequest extends FileRequest {
                    command: CommandTypes.SuggestionDiagnosticsSync;
                    arguments: SuggestionDiagnosticsSyncRequestArgs;
                }
                export type SuggestionDiagnosticsSyncRequestArgs = SemanticDiagnosticsSyncRequestArgs;
                export type SuggestionDiagnosticsSyncResponse = SemanticDiagnosticsSyncResponse;
                export interface SyntacticDiagnosticsSyncRequest extends FileRequest {
                    command: CommandTypes.SyntacticDiagnosticsSync;
                    arguments: SyntacticDiagnosticsSyncRequestArgs;
                }
                export interface SyntacticDiagnosticsSyncRequestArgs extends FileRequestArgs {
                    includeLinePosition?: boolean;
                }
                export interface SyntacticDiagnosticsSyncResponse extends Response {
                    body?: Diagnostic[] | DiagnosticWithLinePosition[];
                }
                export interface GeterrForProjectRequestArgs {
                    file: string;
                    delay: number;
                }
                export interface GeterrForProjectRequest extends Request {
                    command: CommandTypes.GeterrForProject;
                    arguments: GeterrForProjectRequestArgs;
                }
                export interface GeterrRequestArgs {
                    files: (string | FileRangesRequestArgs)[];
                    delay: number;
                }
                export interface GeterrRequest extends Request {
                    command: CommandTypes.Geterr;
                    arguments: GeterrRequestArgs;
                }
                export interface FileRange {
                    startLine: number;
                    startOffset: number;
                    endLine: number;
                    endOffset: number;
                }
                export interface FileRangesRequestArgs extends Pick<FileRequestArgs, "file"> {
                    ranges: FileRange[];
                }
                export type RequestCompletedEventName = "requestCompleted";
                export interface RequestCompletedEvent extends Event {
                    event: RequestCompletedEventName;
                    body: RequestCompletedEventBody;
                }
                export interface RequestCompletedEventBody {
                    request_seq: number;
                    performanceData?: PerformanceData;
                }
                export interface Diagnostic {
                    start: Location;
                    end: Location;
                    text: string;
                    category: string;
                    reportsUnnecessary?: {};
                    reportsDeprecated?: {};
                    relatedInformation?: DiagnosticRelatedInformation[];
                    code?: number;
                    source?: string;
                }
                export interface DiagnosticWithFileName extends Diagnostic {
                    fileName: string;
                }
                export interface DiagnosticRelatedInformation {
                    category: string;
                    code: number;
                    message: string;
                    span?: FileSpan;
                }
                export interface DiagnosticEventBody {
                    file: string;
                    diagnostics: Diagnostic[];
                    spans?: TextSpan[];
                }
                export type DiagnosticEventKind = "semanticDiag" | "syntaxDiag" | "suggestionDiag" | "regionSemanticDiag";
                export interface DiagnosticEvent extends Event {
                    body?: DiagnosticEventBody;
                    event: DiagnosticEventKind;
                }
                export interface ConfigFileDiagnosticEventBody {
                    triggerFile: string;
                    configFile: string;
                    diagnostics: DiagnosticWithFileName[];
                }
                export interface ConfigFileDiagnosticEvent extends Event {
                    body?: ConfigFileDiagnosticEventBody;
                    event: "configFileDiag";
                }
                export type ProjectLanguageServiceStateEventName = "projectLanguageServiceState";
                export interface ProjectLanguageServiceStateEvent extends Event {
                    event: ProjectLanguageServiceStateEventName;
                    body?: ProjectLanguageServiceStateEventBody;
                }
                export interface ProjectLanguageServiceStateEventBody {
                    projectName: string;
                    languageServiceEnabled: boolean;
                }
                export type ProjectsUpdatedInBackgroundEventName = "projectsUpdatedInBackground";
                export interface ProjectsUpdatedInBackgroundEvent extends Event {
                    event: ProjectsUpdatedInBackgroundEventName;
                    body: ProjectsUpdatedInBackgroundEventBody;
                }
                export interface ProjectsUpdatedInBackgroundEventBody {
                    openFiles: string[];
                }
                export type ProjectLoadingStartEventName = "projectLoadingStart";
                export interface ProjectLoadingStartEvent extends Event {
                    event: ProjectLoadingStartEventName;
                    body: ProjectLoadingStartEventBody;
                }
                export interface ProjectLoadingStartEventBody {
                    projectName: string;
                    reason: string;
                }
                export type ProjectLoadingFinishEventName = "projectLoadingFinish";
                export interface ProjectLoadingFinishEvent extends Event {
                    event: ProjectLoadingFinishEventName;
                    body: ProjectLoadingFinishEventBody;
                }
                export interface ProjectLoadingFinishEventBody {
                    projectName: string;
                }
                export type SurveyReadyEventName = "surveyReady";
                export interface SurveyReadyEvent extends Event {
                    event: SurveyReadyEventName;
                    body: SurveyReadyEventBody;
                }
                export interface SurveyReadyEventBody {
                    surveyId: string;
                }
                export type LargeFileReferencedEventName = "largeFileReferenced";
                export interface LargeFileReferencedEvent extends Event {
                    event: LargeFileReferencedEventName;
                    body: LargeFileReferencedEventBody;
                }
                export interface LargeFileReferencedEventBody {
                    file: string;
                    fileSize: number;
                    maxFileSize: number;
                }
                export type CreateFileWatcherEventName = "createFileWatcher";
                export interface CreateFileWatcherEvent extends Event {
                    readonly event: CreateFileWatcherEventName;
                    readonly body: CreateFileWatcherEventBody;
                }
                export interface CreateFileWatcherEventBody {
                    readonly id: number;
                    readonly path: string;
                }
                export type CreateDirectoryWatcherEventName = "createDirectoryWatcher";
                export interface CreateDirectoryWatcherEvent extends Event {
                    readonly event: CreateDirectoryWatcherEventName;
                    readonly body: CreateDirectoryWatcherEventBody;
                }
                export interface CreateDirectoryWatcherEventBody {
                    readonly id: number;
                    readonly path: string;
                    readonly recursive: boolean;
                    readonly ignoreUpdate?: boolean;
                }
                export type CloseFileWatcherEventName = "closeFileWatcher";
                export interface CloseFileWatcherEvent extends Event {
                    readonly event: CloseFileWatcherEventName;
                    readonly body: CloseFileWatcherEventBody;
                }
                export interface CloseFileWatcherEventBody {
                    readonly id: number;
                }
                export type AnyEvent = RequestCompletedEvent | DiagnosticEvent | ConfigFileDiagnosticEvent | ProjectLanguageServiceStateEvent | TelemetryEvent | ProjectsUpdatedInBackgroundEvent | ProjectLoadingStartEvent | ProjectLoadingFinishEvent | SurveyReadyEvent | LargeFileReferencedEvent | CreateFileWatcherEvent | CreateDirectoryWatcherEvent | CloseFileWatcherEvent;
                export interface ReloadRequestArgs extends FileRequestArgs {
                    tmpfile: string;
                }
                export interface ReloadRequest extends FileRequest {
                    command: CommandTypes.Reload;
                    arguments: ReloadRequestArgs;
                }
                export interface ReloadResponse extends Response {
                }
                export interface SavetoRequestArgs extends FileRequestArgs {
                    tmpfile: string;
                }
                export interface SavetoRequest extends FileRequest {
                    command: CommandTypes.Saveto;
                    arguments: SavetoRequestArgs;
                }
                export interface NavtoRequestArgs {
                    searchValue: string;
                    maxResultCount?: number;
                    file?: string;
                    currentFileOnly?: boolean;
                    projectFileName?: string;
                }
                export interface NavtoRequest extends Request {
                    command: CommandTypes.Navto;
                    arguments: NavtoRequestArgs;
                }
                export interface NavtoItem extends FileSpan {
                    name: string;
                    kind: ScriptElementKind;
                    matchKind: string;
                    isCaseSensitive: boolean;
                    kindModifiers?: string;
                    containerName?: string;
                    containerKind?: ScriptElementKind;
                }
                export interface NavtoResponse extends Response {
                    body?: NavtoItem[];
                }
                export interface ChangeRequestArgs extends FormatRequestArgs {
                    insertString?: string;
                }
                export interface ChangeRequest extends FileLocationRequest {
                    command: CommandTypes.Change;
                    arguments: ChangeRequestArgs;
                }
                export interface BraceResponse extends Response {
                    body?: TextSpan[];
                }
                export interface BraceRequest extends FileLocationRequest {
                    command: CommandTypes.Brace;
                }
                export interface NavBarRequest extends FileRequest {
                    command: CommandTypes.NavBar;
                }
                export interface NavTreeRequest extends FileRequest {
                    command: CommandTypes.NavTree;
                }
                export interface NavigationBarItem {
                    text: string;
                    kind: ScriptElementKind;
                    kindModifiers?: string;
                    spans: TextSpan[];
                    childItems?: NavigationBarItem[];
                    indent: number;
                }
                export interface NavigationTree {
                    text: string;
                    kind: ScriptElementKind;
                    kindModifiers: string;
                    spans: TextSpan[];
                    nameSpan: TextSpan | undefined;
                    childItems?: NavigationTree[];
                }
                export type TelemetryEventName = "telemetry";
                export interface TelemetryEvent extends Event {
                    event: TelemetryEventName;
                    body: TelemetryEventBody;
                }
                export interface TelemetryEventBody {
                    telemetryEventName: string;
                    payload: any;
                }
                export type TypesInstallerInitializationFailedEventName = "typesInstallerInitializationFailed";
                export interface TypesInstallerInitializationFailedEvent extends Event {
                    event: TypesInstallerInitializationFailedEventName;
                    body: TypesInstallerInitializationFailedEventBody;
                }
                export interface TypesInstallerInitializationFailedEventBody {
                    message: string;
                }
                export type TypingsInstalledTelemetryEventName = "typingsInstalled";
                export interface TypingsInstalledTelemetryEventBody extends TelemetryEventBody {
                    telemetryEventName: TypingsInstalledTelemetryEventName;
                    payload: TypingsInstalledTelemetryEventPayload;
                }
                export interface TypingsInstalledTelemetryEventPayload {
                    installedPackages: string;
                    installSuccess: boolean;
                    typingsInstallerVersion: string;
                }
                export type BeginInstallTypesEventName = "beginInstallTypes";
                export type EndInstallTypesEventName = "endInstallTypes";
                export interface BeginInstallTypesEvent extends Event {
                    event: BeginInstallTypesEventName;
                    body: BeginInstallTypesEventBody;
                }
                export interface EndInstallTypesEvent extends Event {
                    event: EndInstallTypesEventName;
                    body: EndInstallTypesEventBody;
                }
                export interface InstallTypesEventBody {
                    eventId: number;
                    packages: readonly string[];
                }
                export interface BeginInstallTypesEventBody extends InstallTypesEventBody {
                }
                export interface EndInstallTypesEventBody extends InstallTypesEventBody {
                    success: boolean;
                }
                export interface NavBarResponse extends Response {
                    body?: NavigationBarItem[];
                }
                export interface NavTreeResponse extends Response {
                    body?: NavigationTree;
                }
                export type CallHierarchyItem = ChangePropertyTypes<ts.CallHierarchyItem, {
                    span: TextSpan;
                    selectionSpan: TextSpan;
                }>;
                export interface CallHierarchyIncomingCall {
                    from: CallHierarchyItem;
                    fromSpans: TextSpan[];
                }
                export interface CallHierarchyOutgoingCall {
                    to: CallHierarchyItem;
                    fromSpans: TextSpan[];
                }
                export interface PrepareCallHierarchyRequest extends FileLocationRequest {
                    command: CommandTypes.PrepareCallHierarchy;
                }
                export interface PrepareCallHierarchyResponse extends Response {
                    readonly body: CallHierarchyItem | CallHierarchyItem[];
                }
                export interface ProvideCallHierarchyIncomingCallsRequest extends FileLocationRequest {
                    command: CommandTypes.ProvideCallHierarchyIncomingCalls;
                }
                export interface ProvideCallHierarchyIncomingCallsResponse extends Response {
                    readonly body: CallHierarchyIncomingCall[];
                }
                export interface ProvideCallHierarchyOutgoingCallsRequest extends FileLocationRequest {
                    command: CommandTypes.ProvideCallHierarchyOutgoingCalls;
                }
                export interface ProvideCallHierarchyOutgoingCallsResponse extends Response {
                    readonly body: CallHierarchyOutgoingCall[];
                }
                export enum IndentStyle {
                    None = "None",
                    Block = "Block",
                    Smart = "Smart"
                }
                export type EditorSettings = ChangePropertyTypes<ts.EditorSettings, {
                    indentStyle: IndentStyle | ts.IndentStyle;
                }>;
                export type FormatCodeSettings = ChangePropertyTypes<ts.FormatCodeSettings, {
                    indentStyle: IndentStyle | ts.IndentStyle;
                }>;
                export type CompilerOptions = ChangePropertyTypes<ChangeStringIndexSignature<ts.CompilerOptions, CompilerOptionsValue>, {
                    jsx: JsxEmit | ts.JsxEmit;
                    module: ModuleKind | ts.ModuleKind;
                    moduleResolution: ModuleResolutionKind | ts.ModuleResolutionKind;
                    newLine: NewLineKind | ts.NewLineKind;
                    target: ScriptTarget | ts.ScriptTarget;
                }>;
                export enum JsxEmit {
                    None = "none",
                    Preserve = "preserve",
                    ReactNative = "react-native",
                    React = "react",
                    ReactJSX = "react-jsx",
                    ReactJSXDev = "react-jsxdev"
                }
                export enum ModuleKind {
                    None = "none",
                    CommonJS = "commonjs",
                    AMD = "amd",
                    UMD = "umd",
                    System = "system",
                    ES6 = "es6",
                    ES2015 = "es2015",
                    ES2020 = "es2020",
                    ES2022 = "es2022",
                    ESNext = "esnext",
                    Node16 = "node16",
                    Node18 = "node18",
                    NodeNext = "nodenext",
                    Preserve = "preserve"
                }
                export enum ModuleResolutionKind {
                    Classic = "classic",
                    Node = "node",
                    NodeJs = "node",
                    Node10 = "node10",
                    Node16 = "node16",
                    NodeNext = "nodenext",
                    Bundler = "bundler"
                }
                export enum NewLineKind {
                    Crlf = "Crlf",
                    Lf = "Lf"
                }
                export enum ScriptTarget {
                    ES3 = "es3",
                    ES5 = "es5",
                    ES6 = "es6",
                    ES2015 = "es2015",
                    ES2016 = "es2016",
                    ES2017 = "es2017",
                    ES2018 = "es2018",
                    ES2019 = "es2019",
                    ES2020 = "es2020",
                    ES2021 = "es2021",
                    ES2022 = "es2022",
                    ES2023 = "es2023",
                    ES2024 = "es2024",
                    ESNext = "esnext",
                    JSON = "json",
                    Latest = "esnext"
                }
            }
            namespace typingsInstaller {
                function installNpmPackages(npmPath: string, tsVersion: string, packageNames: string[], install: (command: string) => boolean): boolean;
                function getNpmCommandForInstallation(npmPath: string, tsVersion: string, packageNames: string[], remaining: number): {
                    command: string;
                    remaining: number;
                };
                function typingsName(packageName: string): string;
                interface Log {
                    isEnabled(): boolean;
                    writeLine(text: string): void;
                }
                type RequestCompletedAction = (success: boolean) => void;
                interface PendingRequest {
                    requestId: number;
                    packageNames: string[];
                    cwd: string;
                    onRequestCompleted: RequestCompletedAction;
                }
                abstract class TypingsInstaller {
                    protected readonly installTypingHost: InstallTypingHost;
                    private readonly globalCachePath;
                    private readonly safeListPath;
                    private readonly typesMapLocation;
                    private readonly throttleLimit;
                    protected readonly log: Log;
                    private readonly packageNameToTypingLocation;
                    private readonly missingTypingsSet;
                    private readonly knownCachesSet;
                    private readonly projectWatchers;
                    private safeList;
                    private pendingRunRequests;
                    private installRunCount;
                    private inFlightRequestCount;
                    abstract readonly typesRegistry: Map<string, MapLike<string>>;
                    constructor(installTypingHost: InstallTypingHost, globalCachePath: string, safeListPath: Path, typesMapLocation: Path, throttleLimit: number, log?: Log);
                    handleRequest(req: TypingInstallerRequestUnion): void;
                    closeProject(req: CloseProject): void;
                    private closeWatchers;
                    install(req: DiscoverTypings): void;
                    installPackage(req: InstallPackageRequest): void;
                    private initializeSafeList;
                    private processCacheLocation;
                    private filterTypings;
                    protected ensurePackageDirectoryExists(directory: string): void;
                    private installTypings;
                    private ensureDirectoryExists;
                    private watchFiles;
                    private createSetTypings;
                    private installTypingsAsync;
                    private executeWithThrottling;
                    protected abstract installWorker(requestId: number, packageNames: string[], cwd: string, onRequestCompleted: RequestCompletedAction): void;
                    protected abstract sendResponse(response: SetTypings | InvalidateCachedTypings | BeginInstallTypes | EndInstallTypes | WatchTypingLocations): void;
                    protected abstract sendResponse(response: SetTypings | InvalidateCachedTypings | BeginInstallTypes | EndInstallTypes | WatchTypingLocations | PackageInstalledResponse | TypesRegistryResponse): void;
                    protected readonly latestDistTag = "latest";
                }
            }
            function hasArgument(argumentName: string): boolean;
            function findArgument(argumentName: string): string | undefined;
            function nowString(): string;
            function indent(str: string): string;
            function stringifyIndented(json: {}): string;
            type ActionSet = "action::set";
            const ActionSet: ActionSet;
            type ActionInvalidate = "action::invalidate";
            const ActionInvalidate: ActionInvalidate;
            type ActionPackageInstalled = "action::packageInstalled";
            const ActionPackageInstalled: ActionPackageInstalled;
            type EventTypesRegistry = "event::typesRegistry";
            const EventTypesRegistry: EventTypesRegistry;
            type EventBeginInstallTypes = "event::beginInstallTypes";
            const EventBeginInstallTypes: EventBeginInstallTypes;
            type EventEndInstallTypes = "event::endInstallTypes";
            const EventEndInstallTypes: EventEndInstallTypes;
            type EventInitializationFailed = "event::initializationFailed";
            const EventInitializationFailed: EventInitializationFailed;
            type ActionWatchTypingLocations = "action::watchTypingLocations";
            const ActionWatchTypingLocations: ActionWatchTypingLocations;
            namespace Arguments {
                const GlobalCacheLocation = "--globalTypingsCacheLocation";
                const LogFile = "--logFile";
                const EnableTelemetry = "--enableTelemetry";
                const TypingSafeListLocation = "--typingSafeListLocation";
                const TypesMapLocation = "--typesMapLocation";
                const NpmLocation = "--npmLocation";
                const ValidateDefaultNpmLocation = "--validateDefaultNpmLocation";
            }
            interface TypingInstallerResponse {
                readonly kind: ActionSet | ActionInvalidate | EventTypesRegistry | ActionPackageInstalled | EventBeginInstallTypes | EventEndInstallTypes | EventInitializationFailed | ActionWatchTypingLocations;
            }
            interface TypingInstallerRequestWithProjectName {
                readonly projectName: string;
            }
            type TypingInstallerRequestUnion = DiscoverTypings | CloseProject | TypesRegistryRequest | InstallPackageRequest;
            interface DiscoverTypings extends TypingInstallerRequestWithProjectName {
                readonly fileNames: string[];
                readonly projectRootPath: Path;
                readonly compilerOptions: CompilerOptions;
                readonly typeAcquisition: TypeAcquisition;
                readonly unresolvedImports: SortedReadonlyArray<string>;
                readonly cachePath?: string;
                readonly kind: "discover";
            }
            interface CloseProject extends TypingInstallerRequestWithProjectName {
                readonly kind: "closeProject";
            }
            interface TypesRegistryRequest {
                readonly kind: "typesRegistry";
            }
            interface InstallPackageRequest extends TypingInstallerRequestWithProjectName {
                readonly kind: "installPackage";
                readonly fileName: Path;
                readonly packageName: string;
                readonly projectRootPath: Path;
                readonly id: number;
            }
            interface TypesRegistryResponse extends TypingInstallerResponse {
                readonly kind: EventTypesRegistry;
                readonly typesRegistry: MapLike<MapLike<string>>;
            }
            interface PackageInstalledResponse extends ProjectResponse {
                readonly kind: ActionPackageInstalled;
                readonly id: number;
                readonly success: boolean;
                readonly message: string;
            }
            interface InitializationFailedResponse extends TypingInstallerResponse {
                readonly kind: EventInitializationFailed;
                readonly message: string;
                readonly stack?: string;
            }
            interface ProjectResponse extends TypingInstallerResponse {
                readonly projectName: string;
            }
            interface InvalidateCachedTypings extends ProjectResponse {
                readonly kind: ActionInvalidate;
            }
            interface InstallTypes extends ProjectResponse {
                readonly kind: EventBeginInstallTypes | EventEndInstallTypes;
                readonly eventId: number;
                readonly typingsInstallerVersion: string;
                readonly packagesToInstall: readonly string[];
            }
            interface BeginInstallTypes extends InstallTypes {
                readonly kind: EventBeginInstallTypes;
            }
            interface EndInstallTypes extends InstallTypes {
                readonly kind: EventEndInstallTypes;
                readonly installSuccess: boolean;
            }
            interface InstallTypingHost extends JsTyping.TypingResolutionHost {
                useCaseSensitiveFileNames: boolean;
                writeFile(path: string, content: string): void;
                createDirectory(path: string): void;
                getCurrentDirectory?(): string;
            }
            interface SetTypings extends ProjectResponse {
                readonly typeAcquisition: TypeAcquisition;
                readonly compilerOptions: CompilerOptions;
                readonly typings: string[];
                readonly unresolvedImports: SortedReadonlyArray<string>;
                readonly kind: ActionSet;
            }
            interface WatchTypingLocations extends ProjectResponse {
                readonly files: readonly string[] | undefined;
                readonly kind: ActionWatchTypingLocations;
            }
            type TypingInstallerResponseUnion = SetTypings | InvalidateCachedTypings | TypesRegistryResponse | PackageInstalledResponse | InstallTypes | InitializationFailedResponse | WatchTypingLocations;
            interface CompressedData {
                length: number;
                compressionKind: string;
                data: any;
            }
            type ModuleImportResult = {
                module: {};
                error: undefined;
            } | {
                module: undefined;
                error: {
                    stack?: string;
                    message?: string;
                };
            };
            type RequireResult = ModuleImportResult;
            interface ServerHost extends System {
                watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
                watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
                preferNonRecursiveWatch?: boolean;
                setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;
                clearTimeout(timeoutId: any): void;
                setImmediate(callback: (...args: any[]) => void, ...args: any[]): any;
                clearImmediate(timeoutId: any): void;
                gc?(): void;
                trace?(s: string): void;
                require?(initialPath: string, moduleName: string): ModuleImportResult;
                importPlugin?(root: string, moduleName: string): Promise<ModuleImportResult>;
            }
            interface InstallPackageOptionsWithProject extends InstallPackageOptions {
                projectName: string;
                projectRootPath: Path;
            }
            interface ITypingsInstaller {
                isKnownTypesPackageName(name: string): boolean;
                installPackage(options: InstallPackageOptionsWithProject): Promise<ApplyCodeActionCommandResult>;
                enqueueInstallTypingsRequest(p: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string> | undefined): void;
                attach(projectService: ProjectService): void;
                onProjectClosed(p: Project): void;
                readonly globalTypingsCacheLocation: string | undefined;
            }
            function createInstallTypingsRequest(project: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string>, cachePath?: string): DiscoverTypings;
            function toNormalizedPath(fileName: string): NormalizedPath;
            function normalizedPathToPath(normalizedPath: NormalizedPath, currentDirectory: string, getCanonicalFileName: (f: string) => string): Path;
            function asNormalizedPath(fileName: string): NormalizedPath;
            function createNormalizedPathMap<T>(): NormalizedPathMap<T>;
            function isInferredProjectName(name: string): boolean;
            function makeInferredProjectName(counter: number): string;
            function makeAutoImportProviderProjectName(counter: number): string;
            function makeAuxiliaryProjectName(counter: number): string;
            function createSortedArray<T>(): SortedArray<T>;
            enum LogLevel {
                terse = 0,
                normal = 1,
                requestTime = 2,
                verbose = 3
            }
            const emptyArray: SortedReadonlyArray<never>;
            interface Logger {
                close(): void;
                hasLevel(level: LogLevel): boolean;
                loggingEnabled(): boolean;
                perftrc(s: string): void;
                info(s: string): void;
                startGroup(): void;
                endGroup(): void;
                msg(s: string, type?: Msg): void;
                getLogFileName(): string | undefined;
                isTestLogger?: boolean;
            }
            enum Msg {
                Err = "Err",
                Info = "Info",
                Perf = "Perf"
            }
            namespace Errors {
                function ThrowNoProject(): never;
                function ThrowProjectLanguageServiceDisabled(): never;
                function ThrowProjectDoesNotContainDocument(fileName: string, project: Project): never;
            }
            type NormalizedPath = string & {
                __normalizedPathTag: any;
            };
            interface NormalizedPathMap<T> {
                get(path: NormalizedPath): T | undefined;
                set(path: NormalizedPath, value: T): void;
                contains(path: NormalizedPath): boolean;
                remove(path: NormalizedPath): void;
            }
            interface ProjectOptions {
                configHasExtendsProperty: boolean;
                configHasFilesProperty: boolean;
                configHasIncludeProperty: boolean;
                configHasExcludeProperty: boolean;
            }
            function getBaseConfigFileName(configFilePath: NormalizedPath): "tsconfig.json" | "jsconfig.json" | undefined;
            class ThrottledOperations {
                private readonly host;
                private readonly pendingTimeouts;
                private readonly logger?;
                constructor(host: ServerHost, logger: Logger);
                schedule(operationId: string, delay: number, cb: () => void): void;
                cancel(operationId: string): boolean;
                private static run;
            }
            class GcTimer {
                private readonly host;
                private readonly delay;
                private readonly logger;
                private timerId;
                constructor(host: ServerHost, delay: number, logger: Logger);
                scheduleCollect(): void;
                private static run;
            }
            function isDynamicFileName(fileName: NormalizedPath): boolean;
            function scriptInfoIsContainedByBackgroundProject(info: ScriptInfo): boolean;
            function scriptInfoIsContainedByDeferredClosedProject(info: ScriptInfo): boolean;
            class TextStorage {
                private readonly host;
                private readonly info;
                version: number;
                private svc;
                private text;
                private textSnapshot;
                private lineMap;
                private fileSize;
                isOpen: boolean;
                private ownFileText;
                pendingReloadFromDisk: boolean;
                constructor(host: ServerHost, info: ScriptInfo, initialVersion?: number);
                getVersion(): string;
                hasScriptVersionCache_TestOnly(): boolean;
                private resetSourceMapInfo;
                useText(newText: string): void;
                edit(start: number, end: number, newText: string): void;
                reload(newText: string): boolean;
                reloadWithFileText(tempFileName?: string): boolean;
                scheduleReloadIfNeeded(): boolean;
                delayReloadFromFileIntoText(): void;
                getTelemetryFileSize(): number;
                getSnapshot(): IScriptSnapshot;
                getAbsolutePositionAndLineText(oneBasedLine: number): AbsolutePositionAndLineText;
                lineToTextSpan(line: number): TextSpan;
                lineOffsetToPosition(line: number, offset: number, allowEdits?: true): number;
                positionToLineOffset(position: number): protocol.Location;
                private getFileTextAndSize;
                switchToScriptVersionCache(): ScriptVersionCache;
                private tryUseScriptVersionCache;
                private getOrLoadText;
                private getLineMap;
                getLineInfo(): LineInfo;
            }
            interface DocumentRegistrySourceFileCache {
                key: DocumentRegistryBucketKeyWithMode;
                sourceFile: SourceFile;
            }
            interface SourceMapFileWatcher {
                watcher: FileWatcher;
                sourceInfos?: Set<Path>;
            }
            class ScriptInfo {
                private readonly host;
                readonly fileName: NormalizedPath;
                readonly scriptKind: ScriptKind;
                readonly hasMixedContent: boolean;
                readonly path: Path;
                readonly containingProjects: Project[];
                private formatSettings;
                private preferences;
                fileWatcher: FileWatcher | undefined;
                readonly textStorage: TextStorage;
                readonly isDynamic: boolean;
                private realpath;
                cacheSourceFile: DocumentRegistrySourceFileCache | undefined;
                mTime?: number;
                sourceFileLike?: SourceFileLike;
                sourceMapFilePath?: Path | SourceMapFileWatcher | false;
                declarationInfoPath?: Path;
                sourceInfos?: Set<Path>;
                documentPositionMapper?: DocumentPositionMapper | false;
                deferredDelete?: boolean;
                constructor(host: ServerHost, fileName: NormalizedPath, scriptKind: ScriptKind, hasMixedContent: boolean, path: Path, initialVersion?: number);
                isDynamicOrHasMixedContent(): boolean;
                isScriptOpen(): boolean;
                open(newText: string | undefined): void;
                close(fileExists?: boolean): void;
                getSnapshot(): IScriptSnapshot;
                private ensureRealPath;
                getRealpathIfDifferent(): Path | undefined;
                isSymlink(): boolean | undefined;
                getFormatCodeSettings(): FormatCodeSettings | undefined;
                getPreferences(): protocol.UserPreferences | undefined;
                attachToProject(project: Project): boolean;
                isAttached(project: Project): boolean;
                detachFromProject(project: Project): void;
                detachAllProjects(): void;
                getDefaultProject(): Project;
                registerFileUpdate(): void;
                setOptions(formatSettings: FormatCodeSettings, preferences: protocol.UserPreferences | undefined): void;
                getLatestVersion(): string;
                saveTo(fileName: string): void;
                delayReloadNonMixedContentFile(): void;
                reloadFromFile(tempFileName?: NormalizedPath): boolean;
                editContent(start: number, end: number, newText: string): void;
                markContainingProjectsAsDirty(): void;
                isOrphan(): boolean;
                lineToTextSpan(line: number): TextSpan;
                lineOffsetToPosition(line: number, offset: number): number;
                lineOffsetToPosition(line: number, offset: number, allowEdits?: true): number;
                positionToLineOffset(position: number): protocol.Location;
                isJavaScript(): boolean;
                closeSourceMapFileWatcher(): void;
            }
            function countEachFileTypes(infos: ScriptInfo[], includeSizes?: boolean): FileStats;
            function allRootFilesAreJsOrDts(project: Project): boolean;
            function allFilesAreJsOrDts(project: Project): boolean;
            function hasNoTypeScriptSource(fileNames: string[]): boolean;
            function isInferredProject(project: Project): project is InferredProject;
            function isConfiguredProject(project: Project): project is ConfiguredProject;
            function isExternalProject(project: Project): project is ExternalProject;
            function isBackgroundProject(project: Project): project is AutoImportProviderProject | AuxiliaryProject;
            function isProjectDeferredClose(project: Project): project is ConfiguredProject;
            enum ProjectKind {
                Inferred = 0,
                Configured = 1,
                External = 2,
                AutoImportProvider = 3,
                Auxiliary = 4
            }
            type Mutable<T> = {
                -readonly [K in keyof T]: T[K];
            };
            interface ProjectFilesWithTSDiagnostics extends protocol.ProjectFiles {
                projectErrors: readonly Diagnostic[];
            }
            interface PluginCreateInfo {
                project: Project;
                languageService: LanguageService;
                languageServiceHost: LanguageServiceHost;
                serverHost: ServerHost;
                session?: Session<unknown>;
                config: any;
            }
            interface PluginModule {
                create(createInfo: PluginCreateInfo): LanguageService;
                getExternalFiles?(proj: Project, updateLevel: ProgramUpdateLevel): string[];
                onConfigurationChanged?(config: any): void;
            }
            interface PluginModuleWithName {
                name: string;
                module: PluginModule;
            }
            type PluginModuleFactory = (mod: {
                typescript: typeof ts;
            }) => PluginModule;
            interface PluginImportResult<T> {
                pluginConfigEntry: PluginImport;
                resolvedModule: T | undefined;
                errorLogs: string[] | undefined;
            }
            type BeginEnablePluginResult = PluginImportResult<PluginModuleFactory>;
            interface ProjectRootFile {
                fileName: NormalizedPath;
                info?: ScriptInfo;
            }
            interface EmitResult {
                emitSkipped: boolean;
                diagnostics: readonly Diagnostic[];
            }
            abstract class Project implements LanguageServiceHost, ModuleResolutionHost {
                readonly projectKind: ProjectKind;
                readonly projectService: ProjectService;
                private compilerOptions;
                compileOnSaveEnabled: boolean;
                protected watchOptions: WatchOptions | undefined;
                private rootFilesMap;
                private program;
                private externalFiles;
                private missingFilesMap;
                private generatedFilesMap;
                protected readonly plugins: PluginModuleWithName[];
                cachedUnresolvedImportsPerFile: Map<Path, readonly string[]>;
                lastCachedUnresolvedImportsList: SortedReadonlyArray<string> | undefined;
                private hasAddedorRemovedFiles;
                private hasAddedOrRemovedSymlinks;
                lastFileExceededProgramSize: string | undefined;
                protected languageService: LanguageService;
                languageServiceEnabled: boolean;
                readonly trace?: (s: string) => void;
                readonly realpath?: (path: string) => string;
                hasInvalidatedResolutions?: HasInvalidatedResolutions | undefined;
                hasInvalidatedLibResolutions: HasInvalidatedLibResolutions | undefined;
                resolutionCache: ResolutionCache;
                private builderState;
                private updatedFileNames;
                private lastReportedFileNames;
                private lastReportedVersion;
                projectProgramVersion: number;
                projectStateVersion: number;
                protected projectErrors: Diagnostic[] | undefined;
                initialLoadPending: boolean;
                dirty: boolean;
                typingFiles: SortedReadonlyArray<string>;
                private typingsCache;
                private typingWatchers;
                originalConfiguredProjects: Set<NormalizedPath> | undefined;
                packageJsonWatches: Set<PackageJsonWatcher> | undefined;
                noDtsResolutionProject?: AuxiliaryProject | undefined;
                getResolvedProjectReferenceToRedirect(_fileName: string): ResolvedProjectReference | undefined;
                useSourceOfProjectReferenceRedirect?(): boolean;
                getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
                private readonly cancellationToken;
                isNonTsProject(): boolean;
                isJsOnlyProject(): boolean;
                static resolveModule(moduleName: string, initialDir: string, host: ServerHost, log: (message: string) => void): {} | undefined;
                static importServicePluginSync<T = {}>(pluginConfigEntry: PluginImport, searchPaths: string[], host: ServerHost, log: (message: string) => void): PluginImportResult<T>;
                static importServicePluginAsync<T = {}>(pluginConfigEntry: PluginImport, searchPaths: string[], host: ServerHost, log: (message: string) => void): Promise<PluginImportResult<T>>;
                readonly currentDirectory: string;
                readonly projectName: string;
                directoryStructureHost: DirectoryStructureHost;
                readonly getCanonicalFileName: GetCanonicalFileName;
                private exportMapCache;
                private changedFilesForExportMapCache;
                private moduleSpecifierCache;
                private symlinks;
                autoImportProviderHost: AutoImportProviderProject | false | undefined;
                protected typeAcquisition: TypeAcquisition | undefined;
                createHash: ((data: string) => string) | undefined;
                preferNonRecursiveWatch: boolean | undefined;
                readonly jsDocParsingMode: JSDocParsingMode | undefined;
                constructor(projectName: string, projectKind: ProjectKind, projectService: ProjectService, hasExplicitListOfFiles: boolean, lastFileExceededProgramSize: string | undefined, compilerOptions: CompilerOptions, compileOnSaveEnabled: boolean, watchOptions: WatchOptions | undefined, directoryStructureHost: DirectoryStructureHost, currentDirectory: string);
                isKnownTypesPackageName(name: string): boolean;
                installPackage(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;
                getGlobalTypingsCacheLocation(): string | undefined;
                getSymlinkCache(): SymlinkCache;
                getCompilationSettings(): CompilerOptions;
                getCompilerOptions(): CompilerOptions;
                getNewLine(): string;
                getProjectVersion(): string;
                getProjectReferences(): readonly ProjectReference[] | undefined;
                getScriptFileNames(): string[];
                private getOrCreateScriptInfoAndAttachToProject;
                getScriptKind(fileName: string): ScriptKind;
                getScriptVersion(filename: string): string;
                getScriptSnapshot(filename: string): IScriptSnapshot | undefined;
                getCancellationToken(): HostCancellationToken;
                getCurrentDirectory(): string;
                getDefaultLibFileName(): string;
                useCaseSensitiveFileNames(): boolean;
                readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
                readFile(fileName: string): string | undefined;
                writeFile(fileName: string, content: string): void;
                fileExists(file: string): boolean;
                resolveModuleNameLiterals(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];
                getModuleResolutionCache(): ModuleResolutionCache | undefined;
                resolveTypeReferenceDirectiveReferences<T extends string | FileReference>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];
                resolveLibrary(libraryName: string, resolveFrom: string, options: CompilerOptions, libFileName: string): ResolvedModuleWithFailedLookupLocations;
                directoryExists(path: string): boolean;
                getDirectories(path: string): string[];
                getCachedDirectoryStructureHost(): CachedDirectoryStructureHost;
                toPath(fileName: string): Path;
                watchDirectoryOfFailedLookupLocation(directory: string, cb: DirectoryWatcherCallback, flags: WatchDirectoryFlags): FileWatcher;
                watchAffectingFileLocation(file: string, cb: FileWatcherCallback): FileWatcher;
                clearInvalidateResolutionOfFailedLookupTimer(): boolean;
                scheduleInvalidateResolutionsOfFailedLookupLocations(): void;
                invalidateResolutionsOfFailedLookupLocations(): void;
                onInvalidatedResolution(): void;
                watchTypeRootsDirectory(directory: string, cb: DirectoryWatcherCallback, flags: WatchDirectoryFlags): FileWatcher;
                hasChangedAutomaticTypeDirectiveNames(): boolean;
                onChangedAutomaticTypeDirectiveNames(): void;
                globalCacheResolutionModuleName: typeof JsTyping.nonRelativeModuleNameForTypingCache;
                fileIsOpen(filePath: Path): boolean;
                writeLog(s: string): void;
                log(s: string): void;
                error(s: string): void;
                private setInternalCompilerOptionsForEmittingJsFiles;
                getGlobalProjectErrors(): readonly Diagnostic[];
                getAllProjectErrors(): readonly Diagnostic[];
                setProjectErrors(projectErrors: Diagnostic[] | undefined): void;
                getLanguageService(ensureSynchronized?: boolean): LanguageService;
                getSourceMapper(): SourceMapper;
                clearSourceMapperCache(): void;
                getDocumentPositionMapper(generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined;
                getSourceFileLike(fileName: string): SourceFileLike | undefined;
                shouldEmitFile(scriptInfo: ScriptInfo | undefined): boolean | undefined;
                getCompileOnSaveAffectedFileList(scriptInfo: ScriptInfo): string[];
                emitFile(scriptInfo: ScriptInfo, writeFile: (path: string, data: string, writeByteOrderMark?: boolean) => void): EmitResult;
                enableLanguageService(): void;
                cleanupProgram(): void;
                disableLanguageService(lastFileExceededProgramSize?: string): void;
                getProjectName(): string;
                protected removeLocalTypingsFromTypeAcquisition(newTypeAcquisition: TypeAcquisition): TypeAcquisition;
                getExternalFiles(updateLevel?: ProgramUpdateLevel): SortedReadonlyArray<string>;
                getSourceFile(path: Path): SourceFile | undefined;
                getSourceFileOrConfigFile(path: Path): SourceFile | undefined;
                close(): void;
                private detachScriptInfoIfNotRoot;
                isClosed(): boolean;
                hasRoots(): boolean;
                isOrphan(): boolean;
                getRootFiles(): NormalizedPath[];
                getRootFilesMap(): Map<Path, ProjectRootFile>;
                getRootScriptInfos(): ScriptInfo[];
                getScriptInfos(): ScriptInfo[];
                getExcludedFiles(): readonly NormalizedPath[];
                getFileNames(excludeFilesFromExternalLibraries?: boolean, excludeConfigFiles?: boolean): NormalizedPath[];
                getFileNamesWithRedirectInfo(includeProjectReferenceRedirectInfo: boolean): protocol.FileWithProjectReferenceRedirectInfo[];
                hasConfigFile(configFilePath: NormalizedPath): boolean;
                containsScriptInfo(info: ScriptInfo): boolean;
                containsFile(filename: NormalizedPath, requireOpen?: boolean): boolean;
                isRoot(info: ScriptInfo): boolean;
                addRoot(info: ScriptInfo, fileName?: NormalizedPath): void;
                addMissingFileRoot(fileName: NormalizedPath): void;
                removeFile(info: ScriptInfo, fileExists: boolean, detachFromProject: boolean): void;
                registerFileUpdate(fileName: string): void;
                markFileAsDirty(changedFile: Path): void;
                markAsDirty(): void;
                markAutoImportProviderAsDirty(): void;
                onAutoImportProviderSettingsChanged(): void;
                onPackageJsonChange(): void;
                onFileAddedOrRemoved(isSymlink: boolean | undefined): void;
                onDiscoveredSymlink(): void;
                onReleaseOldSourceFile(oldSourceFile: SourceFile, _oldOptions: CompilerOptions, hasSourceFileByPath: boolean, newSourceFileByResolvedPath: SourceFile | undefined): void;
                updateFromProjectInProgress: boolean;
                updateFromProject(): void;
                updateGraph(): boolean;
                enqueueInstallTypingsForProject(forceRefresh: boolean): void;
                updateTypingFiles(compilerOptions: CompilerOptions, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string>, newTypings: string[]): void;
                private closeWatchingTypingLocations;
                private onTypingInstallerWatchInvoke;
                watchTypingLocations(files: readonly string[] | undefined): void;
                getCurrentProgram(): Program | undefined;
                protected removeExistingTypings(include: string[]): string[];
                private updateGraphWorker;
                sendPerformanceEvent(kind: PerformanceEvent["kind"], durationMs: number): void;
                private detachScriptInfoFromProject;
                private addMissingFileWatcher;
                private isWatchedMissingFile;
                addGeneratedFileWatch(generatedFile: string, sourceFile: string): void;
                private createGeneratedFileWatcher;
                private isValidGeneratedFileWatcher;
                private clearGeneratedFileWatch;
                getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;
                getScriptInfo(uncheckedFileName: string): ScriptInfo | undefined;
                filesToString(writeProjectFileNames: boolean): string;
                private filesToStringWorker;
                print(writeProjectFileNames: boolean, writeFileExplaination: boolean, writeFileVersionAndText: boolean): void;
                setCompilerOptions(compilerOptions: CompilerOptions): void;
                setWatchOptions(watchOptions: WatchOptions | undefined): void;
                getWatchOptions(): WatchOptions | undefined;
                setTypeAcquisition(newTypeAcquisition: TypeAcquisition | undefined): void;
                getTypeAcquisition(): TypeAcquisition;
                getChangesSinceVersion(lastKnownVersion?: number, includeProjectReferenceRedirectInfo?: boolean): ProjectFilesWithTSDiagnostics;
                protected removeRoot(info: ScriptInfo): void;
                isSourceOfProjectReferenceRedirect(fileName: string): boolean;
                protected getGlobalPluginSearchPaths(): string[];
                protected enableGlobalPlugins(options: CompilerOptions): void;
                protected enablePlugin(pluginConfigEntry: PluginImport, searchPaths: string[]): void;
                enableProxy(pluginModuleFactory: PluginModuleFactory, configEntry: PluginImport): void;
                onPluginConfigurationChanged(pluginName: string, configuration: any): void;
                refreshDiagnostics(): void;
                getPackageJsonsVisibleToFile(fileName: string, rootDir?: string): readonly ProjectPackageJsonInfo[];
                getNearestAncestorDirectoryWithPackageJson(fileName: string): string | undefined;
                getPackageJsonsForAutoImport(rootDir?: string): readonly ProjectPackageJsonInfo[];
                getPackageJsonCache(): PackageJsonCache;
                getCachedExportInfoMap(): ExportInfoMap;
                clearCachedExportInfoMap(): void;
                getModuleSpecifierCache(): ModuleSpecifierCache;
                includePackageJsonAutoImports(): PackageJsonAutoImportPreference;
                getHostForAutoImportProvider(): GetPackageJsonEntrypointsHost;
                getPackageJsonAutoImportProvider(): Program | undefined;
                private isDefaultProjectForOpenFiles;
                watchNodeModulesForPackageJsonChanges(directoryPath: string): FileWatcher;
                getIncompleteCompletionsCache(): IncompleteCompletionsCache;
                getNoDtsResolutionProject(rootFile: NormalizedPath): AuxiliaryProject;
                runWithTemporaryFileUpdate(rootFile: string, updatedText: string, cb: (updatedProgram: Program, originalProgram: Program | undefined, updatedFile: SourceFile) => void): void;
                getCompilerOptionsForNoDtsResolutionProject(): CompilerOptions;
            }
            class InferredProject extends Project {
                private _isJsInferredProject;
                toggleJsInferredProject(isJsInferredProject: boolean): void;
                setCompilerOptions(options?: CompilerOptions): void;
                readonly projectRootPath: string | undefined;
                readonly canonicalCurrentDirectory: string | undefined;
                constructor(projectService: ProjectService, compilerOptions: CompilerOptions, watchOptions: WatchOptions | undefined, projectRootPath: NormalizedPath | undefined, currentDirectory: string, typeAcquisition: TypeAcquisition | undefined);
                addRoot(info: ScriptInfo): void;
                removeRoot(info: ScriptInfo): void;
                isOrphan(): boolean;
                isProjectWithSingleRoot(): boolean;
                close(): void;
                getTypeAcquisition(): TypeAcquisition;
            }
            class AuxiliaryProject extends Project {
                rootFile: NormalizedPath | undefined;
                constructor(hostProject: Project);
                isOrphan(): boolean;
                scheduleInvalidateResolutionsOfFailedLookupLocations(): void;
            }
            class AutoImportProviderProject extends Project {
                private hostProject;
                private static readonly maxDependencies;
                static getRootFileNames(dependencySelection: PackageJsonAutoImportPreference, hostProject: Project, host: GetPackageJsonEntrypointsHost, compilerOptions: CompilerOptions): string[];
                static readonly compilerOptionsOverrides: CompilerOptions;
                static create(dependencySelection: PackageJsonAutoImportPreference, hostProject: Project, host: GetPackageJsonEntrypointsHost): AutoImportProviderProject | undefined;
                private rootFileNames;
                constructor(hostProject: Project, initialRootNames: string[], compilerOptions: CompilerOptions);
                isEmpty(): boolean;
                isOrphan(): boolean;
                updateGraph(): boolean;
                scheduleInvalidateResolutionsOfFailedLookupLocations(): void;
                hasRoots(): boolean;
                markAsDirty(): void;
                getScriptFileNames(): string[];
                getLanguageService(): never;
                onAutoImportProviderSettingsChanged(): never;
                onPackageJsonChange(): never;
                getHostForAutoImportProvider(): never;
                getProjectReferences(): readonly ProjectReference[] | undefined;
                includePackageJsonAutoImports(): PackageJsonAutoImportPreference;
                getSymlinkCache(): SymlinkCache;
                getModuleResolutionCache(): ModuleResolutionCache | undefined;
            }
            class ConfiguredProject extends Project {
                readonly canonicalConfigFilePath: NormalizedPath;
                pendingUpdateLevel: ProgramUpdateLevel;
                pendingUpdateReason: string | undefined;
                openFileWatchTriggered: Map<string, ProgramUpdateLevel>;
                parsedCommandLine: ParsedCommandLine | undefined;
                resolvedChildConfigs?: Set<NormalizedPath>;
                private projectReferences;
                potentialProjectReferences: Set<NormalizedPath> | undefined;
                projectOptions?: ProjectOptions | true;
                initialLoadPending: boolean;
                sendLoadingProjectFinish: boolean;
                private compilerHost?;
                configDiagDiagnosticsReported?: number;
                triggerFileForConfigFileDiag?: NormalizedPath;
                deferredClose?: boolean;
                constructor(configFileName: NormalizedPath, canonicalConfigFilePath: NormalizedPath, projectService: ProjectService, cachedDirectoryStructureHost: CachedDirectoryStructureHost, pendingUpdateReason: string);
                setCompilerHost(host: CompilerHost): void;
                getCompilerHost(): CompilerHost | undefined;
                useSourceOfProjectReferenceRedirect(): boolean;
                getParsedCommandLine(fileName: string): ParsedCommandLine | undefined;
                onReleaseParsedCommandLine(fileName: string): void;
                private releaseParsedConfig;
                updateGraph(): boolean;
                getCachedDirectoryStructureHost(): CachedDirectoryStructureHost;
                getConfigFilePath(): NormalizedPath;
                getProjectReferences(): readonly ProjectReference[] | undefined;
                updateReferences(refs: readonly ProjectReference[] | undefined): void;
                setPotentialProjectReference(canonicalConfigPath: NormalizedPath): void;
                getResolvedProjectReferenceToRedirect(fileName: string): ResolvedProjectReference | undefined;
                forEachResolvedProjectReference<T>(cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined): T | undefined;
                enablePluginsWithOptions(options: CompilerOptions): void;
                getGlobalProjectErrors(): readonly Diagnostic[];
                getAllProjectErrors(): readonly Diagnostic[];
                setProjectErrors(projectErrors: Diagnostic[]): void;
                close(): void;
                markAsDirty(): void;
                isOrphan(): boolean;
                getEffectiveTypeRoots(): string[];
                updateErrorOnNoInputFiles(parsedCommandLine: ParsedCommandLine): void;
            }
            class ExternalProject extends Project {
                externalProjectName: string;
                compileOnSaveEnabled: boolean;
                excludedFiles: readonly NormalizedPath[];
                constructor(externalProjectName: string, projectService: ProjectService, compilerOptions: CompilerOptions, lastFileExceededProgramSize: string | undefined, compileOnSaveEnabled: boolean, projectFilePath: string | undefined, watchOptions: WatchOptions | undefined);
                updateGraph(): boolean;
                getExcludedFiles(): readonly NormalizedPath[];
            }
            function convertFormatOptions(protocolOptions: protocol.FormatCodeSettings): FormatCodeSettings;
            function convertCompilerOptions(protocolOptions: protocol.ExternalProjectCompilerOptions): CompilerOptions & protocol.CompileOnSaveMixin;
            function convertWatchOptions(protocolOptions: protocol.ExternalProjectCompilerOptions, currentDirectory?: string): WatchOptionsAndErrors | undefined;
            function convertTypeAcquisition(protocolOptions: protocol.InferredProjectCompilerOptions): TypeAcquisition | undefined;
            function tryConvertScriptKindName(scriptKindName: protocol.ScriptKindName | ScriptKind): ScriptKind;
            function convertScriptKindName(scriptKindName: protocol.ScriptKindName): ScriptKind;
            function convertUserPreferences(preferences: protocol.UserPreferences): UserPreferences;
            function getDetailWatchInfo(watchType: WatchType, project: Project | NormalizedPath | undefined): string;
            function updateProjectIfDirty(project: Project): boolean;
            function isConfigFile(config: ScriptInfoOrConfig): config is TsConfigSourceFile;
            const maxProgramSizeForNonTsFiles: number;
            const maxFileSize: number;
            const ProjectsUpdatedInBackgroundEvent = "projectsUpdatedInBackground";
            interface ProjectsUpdatedInBackgroundEvent {
                eventName: typeof ProjectsUpdatedInBackgroundEvent;
                data: {
                    openFiles: string[];
                };
            }
            const ProjectLoadingStartEvent = "projectLoadingStart";
            interface ProjectLoadingStartEvent {
                eventName: typeof ProjectLoadingStartEvent;
                data: {
                    project: Project;
                    reason: string;
                };
            }
            const ProjectLoadingFinishEvent = "projectLoadingFinish";
            interface ProjectLoadingFinishEvent {
                eventName: typeof ProjectLoadingFinishEvent;
                data: {
                    project: Project;
                };
            }
            const LargeFileReferencedEvent = "largeFileReferenced";
            interface LargeFileReferencedEvent {
                eventName: typeof LargeFileReferencedEvent;
                data: {
                    file: string;
                    fileSize: number;
                    maxFileSize: number;
                };
            }
            const ConfigFileDiagEvent = "configFileDiag";
            interface ConfigFileDiagEvent {
                eventName: typeof ConfigFileDiagEvent;
                data: {
                    triggerFile: string;
                    configFileName: string;
                    diagnostics: readonly Diagnostic[];
                };
            }
            const ProjectLanguageServiceStateEvent = "projectLanguageServiceState";
            interface ProjectLanguageServiceStateEvent {
                eventName: typeof ProjectLanguageServiceStateEvent;
                data: {
                    project: Project;
                    languageServiceEnabled: boolean;
                };
            }
            const ProjectInfoTelemetryEvent = "projectInfo";
            interface ProjectInfoTelemetryEvent {
                readonly eventName: typeof ProjectInfoTelemetryEvent;
                readonly data: ProjectInfoTelemetryEventData;
            }
            const OpenFileInfoTelemetryEvent = "openFileInfo";
            interface OpenFileInfoTelemetryEvent {
                readonly eventName: typeof OpenFileInfoTelemetryEvent;
                readonly data: OpenFileInfoTelemetryEventData;
            }
            const CreateFileWatcherEvent: protocol.CreateFileWatcherEventName;
            interface CreateFileWatcherEvent {
                readonly eventName: protocol.CreateFileWatcherEventName;
                readonly data: protocol.CreateFileWatcherEventBody;
            }
            const CreateDirectoryWatcherEvent: protocol.CreateDirectoryWatcherEventName;
            interface CreateDirectoryWatcherEvent {
                readonly eventName: protocol.CreateDirectoryWatcherEventName;
                readonly data: protocol.CreateDirectoryWatcherEventBody;
            }
            const CloseFileWatcherEvent: protocol.CloseFileWatcherEventName;
            interface CloseFileWatcherEvent {
                readonly eventName: protocol.CloseFileWatcherEventName;
                readonly data: protocol.CloseFileWatcherEventBody;
            }
            interface ProjectInfoTelemetryEventData {
                readonly projectId: string;
                readonly fileStats: FileStats;
                readonly compilerOptions: CompilerOptions;
                readonly extends: boolean | undefined;
                readonly files: boolean | undefined;
                readonly include: boolean | undefined;
                readonly exclude: boolean | undefined;
                readonly compileOnSave: boolean;
                readonly typeAcquisition: ProjectInfoTypeAcquisitionData;
                readonly configFileName: "tsconfig.json" | "jsconfig.json" | "other";
                readonly projectType: "external" | "configured";
                readonly languageServiceEnabled: boolean;
                readonly version: string;
            }
            interface OpenFileInfoTelemetryEventData {
                readonly info: OpenFileInfo;
            }
            interface ProjectInfoTypeAcquisitionData {
                readonly enable: boolean | undefined;
                readonly include: boolean;
                readonly exclude: boolean;
            }
            interface FileStats {
                readonly js: number;
                readonly jsSize?: number;
                readonly jsx: number;
                readonly jsxSize?: number;
                readonly ts: number;
                readonly tsSize?: number;
                readonly tsx: number;
                readonly tsxSize?: number;
                readonly dts: number;
                readonly dtsSize?: number;
                readonly deferred: number;
                readonly deferredSize?: number;
            }
            interface OpenFileInfo {
                readonly checkJs: boolean;
            }
            type ProjectServiceEvent = LargeFileReferencedEvent | ProjectsUpdatedInBackgroundEvent | ProjectLoadingStartEvent | ProjectLoadingFinishEvent | ConfigFileDiagEvent | ProjectLanguageServiceStateEvent | ProjectInfoTelemetryEvent | OpenFileInfoTelemetryEvent | CreateFileWatcherEvent | CreateDirectoryWatcherEvent | CloseFileWatcherEvent;
            type ProjectServiceEventHandler = (event: ProjectServiceEvent) => void;
            type PerformanceEventHandler = (event: PerformanceEvent) => void;
            interface SafeList {
                [name: string]: {
                    match: RegExp;
                    exclude?: (string | number)[][];
                    types?: string[];
                };
            }
            interface TypesMapFile {
                typesMap: SafeList;
                simpleMap: {
                    [libName: string]: string;
                };
            }
            interface HostConfiguration {
                formatCodeOptions: FormatCodeSettings;
                preferences: protocol.UserPreferences;
                hostInfo: string;
                extraFileExtensions?: FileExtensionInfo[];
                watchOptions?: WatchOptions;
                beforeSubstitution?: WatchOptions;
            }
            interface OpenConfiguredProjectResult {
                configFileName?: NormalizedPath;
                configFileErrors?: readonly Diagnostic[];
            }
            const nullTypingsInstaller: ITypingsInstaller;
            interface ConfigFileExistenceInfo {
                exists: boolean;
                inferredProjectRoots?: number;
                openFilesImpactedByConfigFile?: Set<Path>;
                watcher?: FileWatcher;
                config?: ParsedConfig;
            }
            interface ProjectServiceOptions {
                host: ServerHost;
                logger: Logger;
                cancellationToken: HostCancellationToken;
                useSingleInferredProject: boolean;
                useInferredProjectPerProjectRoot: boolean;
                typingsInstaller?: ITypingsInstaller;
                eventHandler?: ProjectServiceEventHandler;
                canUseWatchEvents?: boolean;
                suppressDiagnosticEvents?: boolean;
                throttleWaitMilliseconds?: number;
                globalPlugins?: readonly string[];
                pluginProbeLocations?: readonly string[];
                allowLocalPluginLoads?: boolean;
                typesMapLocation?: string;
                serverMode?: LanguageServiceMode;
                session: Session<unknown> | undefined;
                incrementalVerifier?: (service: ProjectService) => void;
                jsDocParsingMode?: JSDocParsingMode;
            }
            type ConfigFileName = NormalizedPath | false;
            type ConfigFileMapForOpenFile = Map<ConfigFileName, ConfigFileName>;
            type ConfigFileForOpenFile = ConfigFileName | ConfigFileMapForOpenFile;
            interface OriginalFileInfo {
                fileName: NormalizedPath;
                path: Path;
            }
            interface AncestorConfigFileInfo {
                fileName: NormalizedPath;
                path: Path;
                configFileInfo: true;
                isForDefaultProject: boolean;
            }
            type OpenScriptInfoOrClosedFileInfo = ScriptInfo | OriginalFileInfo;
            type OpenScriptInfoOrClosedOrConfigFileInfo = OpenScriptInfoOrClosedFileInfo | AncestorConfigFileInfo;
            enum ConfiguredProjectLoadKind {
                FindOptimized = 0,
                Find = 1,
                CreateReplayOptimized = 2,
                CreateReplay = 3,
                CreateOptimized = 4,
                Create = 5,
                ReloadOptimized = 6,
                Reload = 7
            }
            type ConfigureProjectToLoadKind = Map<ConfiguredProject, ConfiguredProjectLoadKind>;
            type ConfiguredProjectToAnyReloadKind = Map<ConfiguredProject, ConfiguredProjectLoadKind.Reload | ConfiguredProjectLoadKind.ReloadOptimized>;
            type DefaultConfiguredProjectResult = ReturnType<ProjectService["tryFindDefaultConfiguredProjectForOpenScriptInfoOrClosedFileInfo"]>;
            interface FindCreateOrLoadConfiguredProjectResult {
                project: ConfiguredProject;
                sentConfigFileDiag: boolean;
                configFileExistenceInfo: ConfigFileExistenceInfo | undefined;
                reason: string | undefined;
            }
            interface PackageJsonWatcher extends FileWatcher {
                projects: Set<Project | WildcardWatcher>;
            }
            interface WildcardWatcher extends FileWatcher {
                packageJsonWatches: Set<PackageJsonWatcher> | undefined;
            }
            interface OpenFileArguments {
                fileName: string;
                content?: string;
                scriptKind?: protocol.ScriptKindName | ScriptKind;
                hasMixedContent?: boolean;
                projectRootPath?: string;
            }
            interface ChangeFileArguments {
                fileName: string;
                changes: Iterable<TextChange>;
            }
            interface WatchOptionsAndErrors {
                watchOptions: WatchOptions;
                errors: Diagnostic[] | undefined;
            }
            interface ParsedConfig {
                cachedDirectoryStructureHost: CachedDirectoryStructureHost;
                projects: Map<NormalizedPath, boolean>;
                parsedCommandLine?: ParsedCommandLine;
                watchedDirectories?: Map<string, WildcardDirectoryWatcher<WildcardWatcher>>;
                watchedDirectoriesStale?: boolean;
                updateLevel?: ProgramUpdateLevel.RootNamesAndUpdate | ProgramUpdateLevel.Full;
            }
            class ProjectService {
                readonly documentRegistry: DocumentRegistry;
                readonly filenameToScriptInfo: Map<Path, ScriptInfo>;
                private readonly nodeModulesWatchers;
                private readonly filenameToScriptInfoVersion;
                private readonly allJsFilesForOpenFileTelemetry;
                readonly realpathToScriptInfos: MultiMap<Path, ScriptInfo> | undefined;
                private readonly externalProjectToConfiguredProjectMap;
                readonly externalProjects: ExternalProject[];
                readonly inferredProjects: InferredProject[];
                readonly configuredProjects: Map<string, ConfiguredProject>;
                readonly newInferredProjectName: () => string;
                readonly newAutoImportProviderProjectName: () => string;
                readonly newAuxiliaryProjectName: () => string;
                readonly openFiles: Map<Path, NormalizedPath | undefined>;
                private readonly configFileForOpenFiles;
                private rootOfInferredProjects;
                private readonly openFilesWithNonRootedDiskPath;
                private compilerOptionsForInferredProjects;
                private compilerOptionsForInferredProjectsPerProjectRoot;
                private watchOptionsForInferredProjects;
                private watchOptionsForInferredProjectsPerProjectRoot;
                private typeAcquisitionForInferredProjects;
                private typeAcquisitionForInferredProjectsPerProjectRoot;
                private readonly projectToSizeMap;
                readonly configFileExistenceInfoCache: Map<NormalizedPath, ConfigFileExistenceInfo>;
                readonly throttledOperations: ThrottledOperations;
                private readonly hostConfiguration;
                private safelist;
                private readonly legacySafelist;
                private pendingProjectUpdates;
                private pendingOpenFileProjectUpdates?;
                pendingEnsureProjectForOpenFiles: boolean;
                readonly currentDirectory: NormalizedPath;
                readonly toCanonicalFileName: (f: string) => string;
                readonly host: ServerHost;
                readonly logger: Logger;
                readonly cancellationToken: HostCancellationToken;
                readonly useSingleInferredProject: boolean;
                readonly useInferredProjectPerProjectRoot: boolean;
                readonly typingsInstaller: ITypingsInstaller;
                private readonly globalCacheLocationDirectoryPath;
                readonly throttleWaitMilliseconds?: number;
                readonly eventHandler?: ProjectServiceEventHandler;
                private readonly suppressDiagnosticEvents?;
                readonly globalPlugins: readonly string[];
                readonly pluginProbeLocations: readonly string[];
                readonly allowLocalPluginLoads: boolean;
                currentPluginConfigOverrides: Map<string, any> | undefined;
                readonly typesMapLocation: string | undefined;
                readonly serverMode: LanguageServiceMode;
                private readonly seenProjects;
                readonly watchFactory: WatchFactory<WatchType, Project | NormalizedPath>;
                private readonly sharedExtendedConfigFileWatchers;
                private readonly extendedConfigCache;
                readonly packageJsonCache: PackageJsonCache;
                private packageJsonFilesMap;
                private incompleteCompletionsCache;
                readonly session: Session<unknown> | undefined;
                private performanceEventHandler?;
                private pendingPluginEnablements?;
                private currentPluginEnablementPromise?;
                baseline: (title?: string) => void;
                verifyDocumentRegistry: typeof noop;
                verifyProgram: (project: Project) => void;
                onProjectCreation: (project: Project) => void;
                canUseWatchEvents: boolean;
                readonly jsDocParsingMode: JSDocParsingMode | undefined;
                constructor(opts: ProjectServiceOptions);
                toPath(fileName: string): Path;
                getExecutingFilePath(): string;
                getNormalizedAbsolutePath(fileName: string): string;
                setDocument(key: DocumentRegistryBucketKeyWithMode, path: Path, sourceFile: SourceFile): void;
                getDocument(key: DocumentRegistryBucketKeyWithMode, path: Path): SourceFile | undefined;
                ensureInferredProjectsUpToDate_TestOnly(): void;
                getCompilerOptionsForInferredProjects(): CompilerOptions | undefined;
                onUpdateLanguageServiceStateForProject(project: Project, languageServiceEnabled: boolean): void;
                private loadTypesMap;
                updateTypingsForProject(response: SetTypings | InvalidateCachedTypings | PackageInstalledResponse): void;
                updateTypingsForProject(response: SetTypings | InvalidateCachedTypings | PackageInstalledResponse | BeginInstallTypes | EndInstallTypes): void;
                watchTypingLocations(response: WatchTypingLocations): void;
                delayEnsureProjectForOpenFiles(): void;
                private delayUpdateProjectGraph;
                hasPendingProjectUpdate(project: Project): boolean;
                sendProjectsUpdatedInBackgroundEvent(): void;
                sendLargeFileReferencedEvent(file: string, fileSize: number): void;
                sendProjectLoadingStartEvent(project: ConfiguredProject, reason: string): void;
                sendProjectLoadingFinishEvent(project: ConfiguredProject): void;
                sendPerformanceEvent(kind: PerformanceEvent["kind"], durationMs: number): void;
                delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(project: Project): void;
                private delayUpdateProjectGraphs;
                setCompilerOptionsForInferredProjects(projectCompilerOptions: protocol.InferredProjectCompilerOptions, projectRootPath?: string): void;
                findProject(projectName: string): Project | undefined;
                forEachProject(cb: (project: Project) => void): void;
                forEachEnabledProject(cb: (project: Project) => void): void;
                getDefaultProjectForFile(fileName: NormalizedPath, ensureProject: boolean): Project | undefined;
                tryGetDefaultProjectForFile(fileNameOrScriptInfo: NormalizedPath | ScriptInfo): Project | undefined;
                private tryGetDefaultProjectForEnsuringConfiguredProjectForFile;
                ensureDefaultProjectForFile(fileNameOrScriptInfo: NormalizedPath | ScriptInfo): Project;
                private doEnsureDefaultProjectForFile;
                getScriptInfoEnsuringProjectsUptoDate(uncheckedFileName: string): ScriptInfo | undefined;
                private ensureProjectStructuresUptoDate;
                getFormatCodeOptions(file: NormalizedPath): FormatCodeSettings;
                getPreferences(file: NormalizedPath): protocol.UserPreferences;
                getHostFormatCodeOptions(): FormatCodeSettings;
                getHostPreferences(): protocol.UserPreferences;
                private onSourceFileChanged;
                private handleSourceMapProjects;
                private delayUpdateSourceInfoProjects;
                private delayUpdateProjectsOfScriptInfoPath;
                private handleDeletedFile;
                private watchWildcardDirectory;
                private onWildCardDirectoryWatcherInvoke;
                private delayUpdateProjectsFromParsedConfigOnConfigFileChange;
                private onConfigFileChanged;
                private removeProject;
                assignOrphanScriptInfoToInferredProject(info: ScriptInfo, projectRootPath: NormalizedPath | undefined): InferredProject;
                private assignOrphanScriptInfosToInferredProject;
                private closeOpenFile;
                private deleteScriptInfo;
                private configFileExists;
                private createConfigFileWatcherForParsedConfig;
                private ensureConfigFileWatcherForProject;
                releaseParsedConfig(canonicalConfigFilePath: NormalizedPath, forProject: ConfiguredProject): void;
                stopWatchingConfigFilesForScriptInfo(info: ScriptInfo): void;
                startWatchingConfigFilesForInferredProjectRoot(info: ScriptInfo): void;
                private forEachConfigFileLocation;
                findDefaultConfiguredProject(info: ScriptInfo): ConfiguredProject | undefined;
                findDefaultConfiguredProjectWorker(info: ScriptInfo, kind: ConfiguredProjectLoadKind.Find | ConfiguredProjectLoadKind.CreateReplay): DefaultConfiguredProjectResult | undefined;
                private getConfigFileNameForFileFromCache;
                private setConfigFileNameForFileInCache;
                getConfigFileNameForFile(info: OpenScriptInfoOrClosedOrConfigFileInfo, findFromCacheOnly: boolean): NormalizedPath | undefined;
                private printProjects;
                findConfiguredProjectByProjectName(configFileName: NormalizedPath, allowDeferredClosed?: boolean): ConfiguredProject | undefined;
                private getConfiguredProjectByCanonicalConfigFilePath;
                private findExternalProjectByProjectName;
                private getFilenameForExceededTotalSizeLimitForNonTsFiles;
                private createExternalProject;
                sendProjectTelemetry(project: ExternalProject | ConfiguredProject): void;
                private addFilesToNonInferredProject;
                createConfiguredProject(configFileName: NormalizedPath, reason: string): ConfiguredProject;
                private loadConfiguredProject;
                ensureParsedConfigUptoDate(configFilename: NormalizedPath, canonicalConfigFilePath: NormalizedPath, configFileExistenceInfo: ConfigFileExistenceInfo, forProject: ConfiguredProject): ConfigFileExistenceInfo;
                watchWildcards(configFileName: NormalizedPath, { exists, config }: ConfigFileExistenceInfo, forProject: ConfiguredProject): void;
                stopWatchingWildCards(canonicalConfigFilePath: NormalizedPath, forProject: ConfiguredProject): void;
                private updateNonInferredProjectFiles;
                private updateRootAndOptionsOfNonInferredProject;
                reloadFileNamesOfConfiguredProject(project: ConfiguredProject): boolean;
                private reloadFileNamesOfParsedConfig;
                setFileNamesOfAutoImportProviderOrAuxillaryProject(project: AutoImportProviderProject | AuxiliaryProject, fileNames: readonly string[]): void;
                reloadConfiguredProjectOptimized(project: ConfiguredProject, reason: string, reloadedProjects: ConfiguredProjectToAnyReloadKind): void;
                reloadConfiguredProjectClearingSemanticCache(project: ConfiguredProject, reason: string, reloadedProjects: ConfiguredProjectToAnyReloadKind): boolean;
                private setProjectForReload;
                reloadConfiguredProject(project: ConfiguredProject, reason: string): void;
                private clearSemanticCache;
                sendConfigFileDiagEvent(project: ConfiguredProject, triggerFile: NormalizedPath | undefined, force: boolean): boolean;
                private getOrCreateInferredProjectForProjectRootPathIfEnabled;
                private getOrCreateSingleInferredProjectIfEnabled;
                private getOrCreateSingleInferredWithoutProjectRoot;
                private createInferredProject;
                getOrCreateScriptInfoNotOpenedByClient(uncheckedFileName: string, currentDirectory: string, hostToQueryFileExistsOn: DirectoryStructureHost, deferredDeleteOk: boolean): ScriptInfo | undefined;
                getScriptInfo(uncheckedFileName: string): ScriptInfo | undefined;
                getScriptInfoOrConfig(uncheckedFileName: string): ScriptInfoOrConfig | undefined;
                logErrorForScriptInfoNotFound(fileName: string): void;
                getSymlinkedProjects(info: ScriptInfo): MultiMap<Path, Project> | undefined;
                private watchClosedScriptInfo;
                private createNodeModulesWatcher;
                watchPackageJsonsInNodeModules(dir: string, project: Project): FileWatcher;
                private watchClosedScriptInfoInNodeModules;
                private getModifiedTime;
                private refreshScriptInfo;
                private refreshScriptInfosInDirectory;
                private stopWatchingScriptInfo;
                private getOrCreateScriptInfoNotOpenedByClientForNormalizedPath;
                getOrCreateScriptInfoForNormalizedPath(fileName: NormalizedPath, openedByClient: boolean, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, hostToQueryFileExistsOn?: {
                    fileExists(path: string): boolean;
                }): ScriptInfo | undefined;
                private getOrCreateScriptInfoWorker;
                getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;
                getScriptInfoForPath(fileName: Path): ScriptInfo | undefined;
                getDocumentPositionMapper(project: Project, generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined;
                private addSourceInfoToSourceMap;
                private addMissingSourceMapFile;
                getSourceFileLike(fileName: string, projectNameOrProject: string | Project, declarationInfo?: ScriptInfo): SourceFileLike | undefined;
                setPerformanceEventHandler(performanceEventHandler: PerformanceEventHandler): void;
                setHostConfiguration(args: protocol.ConfigureRequestArguments): void;
                getWatchOptions(project: Project): WatchOptions | undefined;
                private getWatchOptionsFromProjectWatchOptions;
                closeLog(): void;
                private sendSourceFileChange;
                reloadProjects(): void;
                private removeRootOfInferredProjectIfNowPartOfOtherProject;
                private ensureProjectForOpenFiles;
                openClientFile(fileName: string, fileContent?: string, scriptKind?: ScriptKind, projectRootPath?: string): OpenConfiguredProjectResult;
                getOriginalLocationEnsuringConfiguredProject(project: Project, location: DocumentPosition): DocumentPosition | undefined;
                fileExists(fileName: NormalizedPath): boolean;
                private findExternalProjectContainingOpenScriptInfo;
                private getOrCreateOpenScriptInfo;
                private assignProjectToOpenedScriptInfo;
                findCreateOrReloadConfiguredProject(configFileName: NormalizedPath, kind: ConfiguredProjectLoadKind, reason?: string, allowDeferredClosed?: boolean, triggerFile?: NormalizedPath, reloadedProjects?: ConfiguredProjectToAnyReloadKind, delayLoad?: boolean, delayReloadedConfiguredProjects?: Set<ConfiguredProject>, projectForConfigFile?: ConfiguredProject): FindCreateOrLoadConfiguredProjectResult | undefined;
                private tryFindDefaultConfiguredProjectForOpenScriptInfo;
                private isMatchedByConfig;
                private tryFindDefaultConfiguredProjectForOpenScriptInfoOrClosedFileInfo;
                private tryFindDefaultConfiguredProjectAndLoadAncestorsForOpenScriptInfo;
                loadAncestorProjectTree(forProjects?: ReadonlyCollection<string>): void;
                private ensureProjectChildren;
                private cleanupConfiguredProjects;
                private cleanupProjectsAndScriptInfos;
                private tryInvokeWildCardDirectories;
                openClientFileWithNormalizedPath(fileName: NormalizedPath, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, projectRootPath?: NormalizedPath): OpenConfiguredProjectResult;
                getOrphanConfiguredProjects(toRetainConfiguredProjects: ConfigureProjectToLoadKind | Set<ConfiguredProject> | undefined, openFilesWithRetainedConfiguredProject: Set<Path> | undefined, externalProjectsRetainingConfiguredProjects: Set<string> | undefined): Set<ConfiguredProject>;
                private removeOrphanScriptInfos;
                private telemetryOnOpenFile;
                closeClientFile(uncheckedFileName: string): void;
                closeClientFile(uncheckedFileName: string, skipAssignOrphanScriptInfosToInferredProject: true): boolean;
                private collectChanges;
                synchronizeProjectList(knownProjects: protocol.ProjectVersionInfo[], includeProjectReferenceRedirectInfo?: boolean): ProjectFilesWithTSDiagnostics[];
                applyChangesInOpenFiles(openFiles: Iterable<OpenFileArguments> | undefined, changedFiles?: Iterable<ChangeFileArguments>, closedFiles?: string[]): void;
                applyChangesToFile(scriptInfo: ScriptInfo, changes: Iterable<TextChange>): void;
                closeExternalProject(uncheckedFileName: string): void;
                closeExternalProject(uncheckedFileName: string, cleanupAfter: boolean): void;
                openExternalProjects(projects: protocol.ExternalProject[]): void;
                private static readonly filenameEscapeRegexp;
                private static escapeFilenameForRegex;
                resetSafeList(): void;
                applySafeList(proj: protocol.ExternalProject): NormalizedPath[];
                private applySafeListWorker;
                openExternalProject(proj: protocol.ExternalProject): void;
                openExternalProject(proj: protocol.ExternalProject, cleanupAfter: boolean): void;
                hasDeferredExtension(): boolean;
                requestEnablePlugin(project: Project, pluginConfigEntry: PluginImport, searchPaths: string[]): void;
                private endEnablePlugin;
                hasNewPluginEnablementRequests(): boolean;
                hasPendingPluginEnablements(): boolean;
                waitForPendingPlugins(): Promise<void>;
                enableRequestedPlugins(): void;
                private enableRequestedPluginsAsync;
                private enableRequestedPluginsWorker;
                configurePlugin(args: protocol.ConfigurePluginRequestArguments): void;
                getPackageJsonsVisibleToFile(fileName: string, project: Project, rootDir?: string): readonly ProjectPackageJsonInfo[];
                getNearestAncestorDirectoryWithPackageJson(fileName: string, project: Project): string | undefined;
                private watchPackageJsonFile;
                private onPackageJsonChange;
                includePackageJsonAutoImports(): PackageJsonAutoImportPreference;
                getIncompleteCompletionsCache(): IncompleteCompletionsCache;
            }
            type ScriptInfoOrConfig = ScriptInfo | TsConfigSourceFile;
            function createModuleSpecifierCache(host: ModuleSpecifierResolutionCacheHost): ModuleSpecifierCache;
            interface ModuleSpecifierResolutionCacheHost {
                watchNodeModulesForPackageJsonChanges(directoryPath: string): FileWatcher;
                toPath(fileName: string): Path;
            }
            function createPackageJsonCache(host: ProjectService): PackageJsonCache;
            interface PackageJsonCache {
                addOrUpdate(fileName: string, path: Path): void;
                invalidate(path: Path): void;
                delete(fileName: Path): void;
                getInDirectory(directory: string): ProjectPackageJsonInfo | undefined;
                directoryHasPackageJson(directory: string): Ternary;
                searchDirectoryAndAncestors(directory: string, project: Project): void;
            }
            function formatDiagnosticToProtocol(diag: Diagnostic, includeFileName: true): protocol.DiagnosticWithFileName;
            function formatDiagnosticToProtocol(diag: Diagnostic, includeFileName: false): protocol.Diagnostic;
            function formatMessage<T extends protocol.Message>(msg: T, logger: Logger, byteLength: (s: string, encoding: BufferEncoding) => number, newLine: string): string;
            function toEvent(eventName: string, body: object): protocol.Event;
            function getLocationInNewDocument(oldText: string, renameFilename: string, renameLocation: number, edits: readonly FileTextChanges[]): protocol.Location;
            interface ServerCancellationToken extends HostCancellationToken {
                setRequest(requestId: number): void;
                resetRequest(requestId: number): void;
            }
            const nullCancellationToken: ServerCancellationToken;
            type CommandNames = protocol.CommandTypes;
            const CommandNames: any;
            type PerformanceData = Omit<protocol.PerformanceData, "diagnosticsDuration"> & {
                diagnosticsDuration?: Map<NormalizedPath, protocol.DiagnosticPerformanceData>;
            };
            type Event = <T extends object>(body: T, eventName: string) => void;
            interface EventSender {
                event: Event;
            }
            interface SessionOptions {
                host: ServerHost;
                cancellationToken: ServerCancellationToken;
                useSingleInferredProject: boolean;
                useInferredProjectPerProjectRoot: boolean;
                typingsInstaller?: ITypingsInstaller;
                byteLength: (buf: string, encoding?: BufferEncoding) => number;
                hrtime: (start?: [
                    number,
                    number
                ]) => [
                    number,
                    number
                ];
                logger: Logger;
                canUseEvents: boolean;
                canUseWatchEvents?: boolean;
                eventHandler?: ProjectServiceEventHandler;
                suppressDiagnosticEvents?: boolean;
                serverMode?: LanguageServiceMode;
                throttleWaitMilliseconds?: number;
                noGetErrOnBackgroundUpdate?: boolean;
                globalPlugins?: readonly string[];
                pluginProbeLocations?: readonly string[];
                allowLocalPluginLoads?: boolean;
                typesMapLocation?: string;
                incrementalVerifier?: (service: ProjectService) => void;
            }
            class Session<TMessage = string> implements EventSender {
                private readonly gcTimer;
                protected projectService: ProjectService;
                private changeSeq;
                private performanceData;
                private currentRequestId;
                private errorCheck;
                protected host: ServerHost;
                private readonly cancellationToken;
                protected readonly typingsInstaller: ITypingsInstaller;
                protected byteLength: (buf: string, encoding?: BufferEncoding) => number;
                private hrtime;
                protected logger: Logger;
                protected canUseEvents: boolean;
                private suppressDiagnosticEvents?;
                private eventHandler;
                private readonly noGetErrOnBackgroundUpdate?;
                protected regionDiagLineCountThreshold: number;
                constructor(opts: SessionOptions);
                private sendRequestCompletedEvent;
                private addPerformanceData;
                private addDiagnosticsPerformanceData;
                private performanceEventHandler;
                private defaultEventHandler;
                private projectsUpdatedInBackgroundEvent;
                logError(err: Error, cmd: string): void;
                private logErrorWorker;
                send(msg: protocol.Message): void;
                protected writeMessage(msg: protocol.Message): void;
                event<T extends object>(body: T, eventName: string): void;
                doOutput(info: {} | undefined, cmdName: string, reqSeq: number, success: boolean, performanceData: PerformanceData | undefined, message?: string): void;
                private semanticCheck;
                private syntacticCheck;
                private suggestionCheck;
                private regionSemanticCheck;
                protected shouldDoRegionCheck(file: NormalizedPath): boolean;
                private sendDiagnosticsEvent;
                private updateErrorCheck;
                private cleanProjects;
                private cleanup;
                private getEncodedSyntacticClassifications;
                private getEncodedSemanticClassifications;
                private getProject;
                private getConfigFileAndProject;
                private getConfigFileDiagnostics;
                private convertToDiagnosticsWithLinePositionFromDiagnosticFile;
                private getCompilerOptionsDiagnostics;
                private convertToDiagnosticsWithLinePosition;
                private getDiagnosticsWorker;
                private getDefinition;
                private mapDefinitionInfoLocations;
                private getDefinitionAndBoundSpan;
                private findSourceDefinition;
                private getEmitOutput;
                private mapJSDocTagInfo;
                private mapDisplayParts;
                private mapSignatureHelpItems;
                private mapDefinitionInfo;
                private static mapToOriginalLocation;
                private toFileSpan;
                private toFileSpanWithContext;
                private getTypeDefinition;
                private mapImplementationLocations;
                private getImplementation;
                private getSyntacticDiagnosticsSync;
                private getSemanticDiagnosticsSync;
                private getSuggestionDiagnosticsSync;
                private getJsxClosingTag;
                private getLinkedEditingRange;
                private getDocumentHighlights;
                private provideInlayHints;
                private mapCode;
                private getCopilotRelatedInfo;
                private setCompilerOptionsForInferredProjects;
                private getProjectInfo;
                private getProjectInfoWorker;
                private getDefaultConfiguredProjectInfo;
                private getRenameInfo;
                private getProjects;
                private getDefaultProject;
                private getRenameLocations;
                private mapRenameInfo;
                private toSpanGroups;
                private getReferences;
                private getFileReferences;
                private openClientFile;
                private getPosition;
                private getPositionInFile;
                private getFileAndProject;
                private getFileAndLanguageServiceForSyntacticOperation;
                private getFileAndProjectWorker;
                private getOutliningSpans;
                private getTodoComments;
                private getDocCommentTemplate;
                private getSpanOfEnclosingComment;
                private getIndentation;
                private getBreakpointStatement;
                private getNameOrDottedNameSpan;
                private isValidBraceCompletion;
                private getQuickInfoWorker;
                private getFormattingEditsForRange;
                private getFormattingEditsForRangeFull;
                private getFormattingEditsForDocumentFull;
                private getFormattingEditsAfterKeystrokeFull;
                private getFormattingEditsAfterKeystroke;
                private getCompletions;
                private getCompletionEntryDetails;
                private getCompileOnSaveAffectedFileList;
                private emitFile;
                private getSignatureHelpItems;
                private toPendingErrorCheck;
                private getDiagnostics;
                private change;
                private reload;
                private saveToTmp;
                private closeClientFile;
                private mapLocationNavigationBarItems;
                private getNavigationBarItems;
                private toLocationNavigationTree;
                private getNavigationTree;
                private getNavigateToItems;
                private getFullNavigateToItems;
                private getSupportedCodeFixes;
                private isLocation;
                private extractPositionOrRange;
                private getRange;
                private getApplicableRefactors;
                private getEditsForRefactor;
                private getMoveToRefactoringFileSuggestions;
                private preparePasteEdits;
                private getPasteEdits;
                private organizeImports;
                private getEditsForFileRename;
                private getCodeFixes;
                private getCombinedCodeFix;
                private applyCodeActionCommand;
                private getStartAndEndPosition;
                private mapCodeAction;
                private mapCodeFixAction;
                private mapPasteEditsAction;
                private mapTextChangesToCodeEdits;
                private mapTextChangeToCodeEdit;
                private convertTextChangeToCodeEdit;
                private getBraceMatching;
                private getDiagnosticsForProject;
                private configurePlugin;
                private getSmartSelectionRange;
                private toggleLineComment;
                private toggleMultilineComment;
                private commentSelection;
                private uncommentSelection;
                private mapSelectionRange;
                private getScriptInfoFromProjectService;
                private toProtocolCallHierarchyItem;
                private toProtocolCallHierarchyIncomingCall;
                private toProtocolCallHierarchyOutgoingCall;
                private prepareCallHierarchy;
                private provideCallHierarchyIncomingCalls;
                private provideCallHierarchyOutgoingCalls;
                getCanonicalFileName(fileName: string): string;
                exit(): void;
                private notRequired;
                private requiredResponse;
                private handlers;
                addProtocolHandler(command: string, handler: (request: protocol.Request) => HandlerResponse): void;
                private setCurrentRequest;
                private resetCurrentRequest;
                executeWithRequestId<T>(requestId: number, f: () => T): T;
                executeWithRequestId<T>(requestId: number, f: () => T, perfomanceData: PerformanceData | undefined): T;
                executeCommand(request: protocol.Request): HandlerResponse;
                onMessage(message: TMessage): void;
                protected parseMessage(message: TMessage): protocol.Request;
                protected toStringMessage(message: TMessage): string;
                private getFormatOptions;
                private getPreferences;
                private getHostFormatOptions;
                private getHostPreferences;
            }
            interface HandlerResponse {
                response?: {};
                responseRequired?: boolean;
                performanceData?: PerformanceData;
            }
            interface LineCollection {
                charCount(): number;
                lineCount(): number;
                isLeaf(): this is LineLeaf;
                walk(rangeStart: number, rangeLength: number, walkFns: LineIndexWalker): void;
            }
            interface AbsolutePositionAndLineText {
                absolutePosition: number;
                lineText: string | undefined;
            }
            enum CharRangeSection {
                PreStart = 0,
                Start = 1,
                Entire = 2,
                Mid = 3,
                End = 4,
                PostEnd = 5
            }
            interface LineIndexWalker {
                goSubtree: boolean;
                done: boolean;
                leaf(relativeStart: number, relativeLength: number, lineCollection: LineLeaf): void;
                pre?(relativeStart: number, relativeLength: number, lineCollection: LineCollection, parent: LineNode, nodeType: CharRangeSection): void;
                post?(relativeStart: number, relativeLength: number, lineCollection: LineCollection, parent: LineNode, nodeType: CharRangeSection): void;
            }
            class ScriptVersionCache {
                private static readonly changeNumberThreshold;
                private static readonly changeLengthThreshold;
                private static readonly maxVersions;
                private changes;
                private readonly versions;
                private minVersion;
                private currentVersion;
                private versionToIndex;
                private currentVersionToIndex;
                edit(pos: number, deleteLen: number, insertedText?: string): void;
                getSnapshot(): IScriptSnapshot;
                private _getSnapshot;
                getSnapshotVersion(): number;
                getAbsolutePositionAndLineText(oneBasedLine: number): AbsolutePositionAndLineText;
                lineOffsetToPosition(line: number, column: number): number;
                positionToLineOffset(position: number): protocol.Location;
                lineToTextSpan(line: number): TextSpan;
                getTextChangesBetweenVersions(oldVersion: number, newVersion: number): TextChangeRange | undefined;
                getLineCount(): number;
                static fromString(script: string): ScriptVersionCache;
            }
            class LineIndex {
                root: LineNode;
                checkEdits: boolean;
                absolutePositionOfStartOfLine(oneBasedLine: number): number;
                positionToLineOffset(position: number): protocol.Location;
                private positionToColumnAndLineText;
                getLineCount(): number;
                lineNumberToInfo(oneBasedLine: number): AbsolutePositionAndLineText;
                load(lines: string[]): void;
                walk(rangeStart: number, rangeLength: number, walkFns: LineIndexWalker): void;
                getText(rangeStart: number, rangeLength: number): string;
                getLength(): number;
                every(f: (ll: LineLeaf, s: number, len: number) => boolean, rangeStart: number, rangeEnd?: number): boolean;
                edit(pos: number, deleteLength: number, newText?: string): LineIndex;
                private static buildTreeFromBottom;
                static linesFromText(text: string): {
                    lines: string[];
                    lineMap: number[];
                };
            }
            class LineNode implements LineCollection {
                private readonly children;
                totalChars: number;
                totalLines: number;
                constructor(children?: LineCollection[]);
                isLeaf(): this is LineLeaf;
                updateCounts(): void;
                private execWalk;
                private skipChild;
                walk(rangeStart: number, rangeLength: number, walkFns: LineIndexWalker): void;
                charOffsetToLineInfo(lineNumberAccumulator: number, relativePosition: number): {
                    oneBasedLine: number;
                    zeroBasedColumn: number;
                    lineText: string | undefined;
                };
                lineNumberToInfo(relativeOneBasedLine: number, positionAccumulator: number): {
                    position: number;
                    leaf: LineLeaf | undefined;
                };
                private splitAfter;
                remove(child: LineCollection): void;
                private findChildIndex;
                insertAt(child: LineCollection, nodes: LineCollection[]): LineNode[];
                add(collection: LineCollection): void;
                charCount(): number;
                lineCount(): number;
            }
            class LineLeaf implements LineCollection {
                text: string;
                constructor(text: string);
                isLeaf(): this is LineLeaf;
                walk(rangeStart: number, rangeLength: number, walkFns: LineIndexWalker): void;
                charCount(): number;
                lineCount(): number;
            }
            interface TypingsInstallerWorkerProcess {
                send<T extends TypingInstallerRequestUnion>(rq: T): void;
            }
            abstract class TypingsInstallerAdapter implements ITypingsInstaller {
                protected readonly telemetryEnabled: boolean;
                protected readonly logger: Logger;
                protected readonly host: ServerHost;
                readonly globalTypingsCacheLocation: string;
                protected event: Event;
                private readonly maxActiveRequestCount;
                protected installer: TypingsInstallerWorkerProcess;
                private projectService;
                protected activeRequestCount: number;
                private requestQueue;
                private requestMap;
                private requestedRegistry;
                private typesRegistryCache;
                private static readonly requestDelayMillis;
                private packageInstalledPromise;
                private packageInstallId;
                constructor(telemetryEnabled: boolean, logger: Logger, host: ServerHost, globalTypingsCacheLocation: string, event: Event, maxActiveRequestCount: number);
                isKnownTypesPackageName(name: string): boolean;
                installPackage(options: InstallPackageOptionsWithProject): Promise<ApplyCodeActionCommandResult>;
                attach(projectService: ProjectService): void;
                onProjectClosed(p: Project): void;
                enqueueInstallTypingsRequest(project: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string>): void;
                handleMessage(response: TypesRegistryResponse | PackageInstalledResponse | SetTypings | InvalidateCachedTypings | BeginInstallTypes | EndInstallTypes | InitializationFailedResponse | server.WatchTypingLocations): void;
                scheduleRequest(request: DiscoverTypings): void;
                protected abstract createInstallerProcess(): TypingsInstallerWorkerProcess;
            }
        }
        namespace moduleSpecifiers {
            function getModuleSpecifierPreferences({ importModuleSpecifierPreference, importModuleSpecifierEnding, autoImportSpecifierExcludeRegexes }: UserPreferences, host: Pick<ModuleSpecifierResolutionHost, "getDefaultResolutionModeForFile">, compilerOptions: CompilerOptions, importingSourceFile: Pick<SourceFile, "fileName" | "impliedNodeFormat">, oldImportSpecifier?: string): ModuleSpecifierPreferences;
            function updateModuleSpecifier(compilerOptions: CompilerOptions, importingSourceFile: SourceFile, importingSourceFileName: string, toFileName: string, host: ModuleSpecifierResolutionHost, oldImportSpecifier: string, options?: ModuleSpecifierOptions): string | undefined;
            function getModuleSpecifier(compilerOptions: CompilerOptions, importingSourceFile: SourceFile | FutureSourceFile, importingSourceFileName: string, toFileName: string, host: ModuleSpecifierResolutionHost, options?: ModuleSpecifierOptions): string;
            function getNodeModulesPackageName(compilerOptions: CompilerOptions, importingSourceFile: SourceFile | FutureSourceFile, nodeModulesFileName: string, host: ModuleSpecifierResolutionHost, preferences: UserPreferences, options?: ModuleSpecifierOptions): string | undefined;
            function tryGetModuleSpecifiersFromCache(moduleSymbol: Symbol, importingSourceFile: SourceFile | FutureSourceFile, host: ModuleSpecifierResolutionHost, userPreferences: UserPreferences, options?: ModuleSpecifierOptions): ModuleSpecifierResult | undefined;
            function getModuleSpecifiers(moduleSymbol: Symbol, checker: TypeChecker, compilerOptions: CompilerOptions, importingSourceFile: SourceFile, host: ModuleSpecifierResolutionHost, userPreferences: UserPreferences, options?: ModuleSpecifierOptions): readonly string[];
            function getModuleSpecifiersWithCacheInfo(moduleSymbol: Symbol, checker: TypeChecker, compilerOptions: CompilerOptions, importingSourceFile: SourceFile | FutureSourceFile, host: ModuleSpecifierResolutionHost, userPreferences: UserPreferences, options: ModuleSpecifierOptions | undefined, forAutoImport: boolean): ModuleSpecifierResult;
            function getLocalModuleSpecifierBetweenFileNames(importingFile: Pick<SourceFile, "fileName" | "impliedNodeFormat">, targetFileName: string, compilerOptions: CompilerOptions, host: ModuleSpecifierResolutionHost, preferences: UserPreferences, options?: ModuleSpecifierOptions): string;
            function countPathComponents(path: string): number;
            function forEachFileNameOfModule<T>(importingFileName: string, importedFileName: string, host: ModuleSpecifierResolutionHost, preferSymlinks: boolean, cb: (fileName: string, isRedirect: boolean) => T | undefined): T | undefined;
            function tryGetRealFileNameForNonJsDeclarationFileName(fileName: string): string | undefined;
            function tryGetJSExtensionForFile(fileName: string, options: CompilerOptions): Extension | undefined;
            enum RelativePreference {
                Relative = 0,
                NonRelative = 1,
                Shortest = 2,
                ExternalNonRelative = 3
            }
            interface ModuleSpecifierPreferences {
                readonly relativePreference: RelativePreference;
                getAllowedEndingsInPreferredOrder(syntaxImpliedNodeFormat?: ResolutionMode): ModuleSpecifierEnding[];
                readonly excludeRegexes?: readonly string[];
            }
            interface ModuleSpecifierResult {
                kind: ResolvedModuleSpecifierInfo["kind"];
                moduleSpecifiers: readonly string[];
                computedWithoutCache: boolean;
            }
        }
        namespace performance {
            function createTimerIf(condition: boolean, measureName: string, startMarkName: string, endMarkName: string): Timer;
            function createTimer(measureName: string, startMarkName: string, endMarkName: string): Timer;
            function mark(markName: string): void;
            function measure(measureName: string, startMarkName?: string, endMarkName?: string): void;
            function getCount(markName: string): number;
            function getDuration(measureName: string): number;
            function forEachMeasure(cb: (measureName: string, duration: number) => void): void;
            function forEachMark(cb: (markName: string) => void): void;
            function clearMeasures(name?: string): void;
            function clearMarks(name?: string): void;
            function isEnabled(): boolean;
            function enable(system?: System): boolean;
            function disable(): void;
            interface Timer {
                enter(): void;
                exit(): void;
            }
            const nullTimer: Timer;
        }
        namespace JsTyping {
            function isTypingUpToDate(cachedTyping: CachedTyping, availableTypingVersions: MapLike<string>): boolean;
            function nonRelativeModuleNameForTypingCache(moduleName: string): string;
            function loadSafeList(host: TypingResolutionHost, safeListPath: Path): SafeList;
            function loadTypesMap(host: TypingResolutionHost, typesMapPath: Path): SafeList | undefined;
            function discoverTypings(host: TypingResolutionHost, log: ((message: string) => void) | undefined, fileNames: string[], projectRootPath: Path, safeList: SafeList, packageNameToTypingLocation: ReadonlyMap<string, CachedTyping>, typeAcquisition: TypeAcquisition, unresolvedImports: readonly string[], typesRegistry: ReadonlyMap<string, MapLike<string>>, compilerOptions: CompilerOptions): {
                cachedTypingPaths: string[];
                newTypingNames: string[];
                filesToWatch: string[];
            };
            function validatePackageName(packageName: string): PackageNameValidationResult;
            function renderPackageNameValidationFailure(result: PackageNameValidationResult, typing: string): string;
            interface TypingResolutionHost {
                directoryExists(path: string): boolean;
                fileExists(fileName: string): boolean;
                readFile(path: string, encoding?: string): string | undefined;
                readDirectory(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[] | undefined, depth?: number): string[];
            }
            interface CachedTyping {
                typingLocation: string;
                version: Version;
            }
            type SafeList = ReadonlyMap<string, string>;
            enum NameValidationResult {
                Ok = 0,
                EmptyName = 1,
                NameTooLong = 2,
                NameStartsWithDot = 3,
                NameStartsWithUnderscore = 4,
                NameContainsNonURISafeCharacters = 5
            }
            interface ScopedPackageNameValidationResult {
                name: string;
                isScopeName: boolean;
                result: NameValidationResult;
            }
            type PackageNameValidationResult = NameValidationResult | ScopedPackageNameValidationResult;
        }
        namespace BreakpointResolver {
            function spanInSourceFileAtLocation(sourceFile: SourceFile, position: number): TextSpan | undefined;
        }
        namespace CallHierarchy {
            function resolveCallHierarchyDeclaration(program: Program, location: Node): CallHierarchyDeclaration | CallHierarchyDeclaration[] | undefined;
            function createCallHierarchyItem(program: Program, node: CallHierarchyDeclaration): CallHierarchyItem;
            function getIncomingCalls(program: Program, declaration: CallHierarchyDeclaration, cancellationToken: CancellationToken): CallHierarchyIncomingCall[];
            function getOutgoingCalls(program: Program, declaration: CallHierarchyDeclaration): CallHierarchyOutgoingCall[];
            type NamedExpression = ClassExpression & {
                name: Identifier;
            } | FunctionExpression & {
                name: Identifier;
            };
            type VariableLike = VariableDeclaration | PropertyDeclaration;
            type AssignedExpression = ClassExpression & {
                name: undefined;
                parent: VariableLike & {
                    name: Identifier;
                };
            } | FunctionExpression & {
                name: undefined;
                parent: VariableLike & {
                    name: Identifier;
                };
            } | ArrowFunction & {
                name: undefined;
                parent: VariableLike & {
                    name: Identifier;
                };
            };
            type CallHierarchyDeclaration = SourceFile | ModuleDeclaration & {
                name: Identifier;
            } | FunctionDeclaration | ClassDeclaration | ClassStaticBlockDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | NamedExpression | AssignedExpression;
        }
        namespace classifier {
            namespace v2020 {
                function getSemanticClassifications(program: Program, cancellationToken: CancellationToken, sourceFile: SourceFile, span: TextSpan): ClassifiedSpan2020[];
                function getEncodedSemanticClassifications(program: Program, cancellationToken: CancellationToken, sourceFile: SourceFile, span: TextSpan): Classifications;
                enum TokenEncodingConsts {
                    typeOffset = 8,
                    modifierMask = 255
                }
                enum TokenType {
                    class = 0,
                    enum = 1,
                    interface = 2,
                    namespace = 3,
                    typeParameter = 4,
                    type = 5,
                    parameter = 6,
                    variable = 7,
                    enumMember = 8,
                    property = 9,
                    function = 10,
                    member = 11
                }
                enum TokenModifier {
                    declaration = 0,
                    static = 1,
                    async = 2,
                    readonly = 3,
                    defaultLibrary = 4,
                    local = 5
                }
            }
        }
        namespace codefix {
            function createCodeFixActionWithoutFixAll(fixName: string, changes: FileTextChanges[], description: DiagnosticOrDiagnosticAndArguments): CodeFixAction;
            function createCodeFixAction(fixName: string, changes: FileTextChanges[], description: DiagnosticOrDiagnosticAndArguments, fixId: {}, fixAllDescription: DiagnosticOrDiagnosticAndArguments, command?: CodeActionCommand): CodeFixAction;
            function createCodeFixActionMaybeFixAll(fixName: string, changes: FileTextChanges[], description: DiagnosticOrDiagnosticAndArguments, fixId?: {}, fixAllDescription?: DiagnosticOrDiagnosticAndArguments, command?: CodeActionCommand): CodeFixAction;
            function registerCodeFix(reg: CodeFixRegistration): void;
            function getSupportedErrorCodes(): readonly string[];
            function getFixes(context: CodeFixContext): readonly CodeFixAction[];
            function getAllFixes(context: CodeFixAllContext): CombinedCodeActions;
            function createCombinedCodeActions(changes: FileTextChanges[], commands?: CodeActionCommand[]): CombinedCodeActions;
            function createFileTextChanges(fileName: string, textChanges: TextChange[]): FileTextChanges;
            function codeFixAll(context: CodeFixAllContext, errorCodes: number[], use: (changes: textChanges.ChangeTracker, error: DiagnosticWithLocation, commands: CodeActionCommand[]) => void): CombinedCodeActions;
            function eachDiagnostic(context: CodeFixAllContext, errorCodes: readonly number[], cb: (diag: DiagnosticWithLocation) => void): void;
            function parameterShouldGetTypeFromJSDoc(node: Node): node is DeclarationWithType;
            type DeclarationWithType = FunctionLikeDeclaration | VariableDeclaration | PropertySignature | PropertyDeclaration;
            function getJSDocTypedefNodes(node: Node): readonly JSDocTag[];
            function createImportAdder(sourceFile: SourceFile | FutureSourceFile, program: Program, preferences: UserPreferences, host: LanguageServiceHost, cancellationToken?: CancellationToken): ImportAdder;
            function createImportSpecifierResolver(importingFile: SourceFile, program: Program, host: LanguageServiceHost, preferences: UserPreferences): ImportSpecifierResolver;
            function getImportCompletionAction(targetSymbol: Symbol, moduleSymbol: Symbol, exportMapKey: ExportMapInfoKey | undefined, sourceFile: SourceFile, symbolName: string, isJsxTagName: boolean, host: LanguageServiceHost, program: Program, formatContext: formatting.FormatContext, position: number, preferences: UserPreferences, cancellationToken: CancellationToken): {
                readonly moduleSpecifier: string;
                readonly codeAction: CodeAction;
            };
            function getPromoteTypeOnlyCompletionAction(sourceFile: SourceFile, symbolToken: Identifier, program: Program, host: LanguageServiceHost, formatContext: formatting.FormatContext, preferences: UserPreferences): CodeAction | undefined;
            function getImportKind(importingFile: SourceFile | FutureSourceFile, exportKind: ExportKind, program: Program, forceImportKeyword?: boolean): ImportKind;
            const importFixName = "import";
            type ImportOrRequireAliasDeclaration = ImportEqualsDeclaration | ImportClause | ImportSpecifier | NamespaceImport | VariableDeclarationInitializedTo<RequireOrImportCall> | BindingElement;
            interface ImportAdder {
                hasFixes(): boolean;
                addImportFromDiagnostic: (diagnostic: DiagnosticWithLocation, context: CodeFixContextBase) => void;
                addImportFromExportedSymbol: (exportedSymbol: Symbol, isValidTypeOnlyUseSite?: boolean, referenceImport?: ImportOrRequireAliasDeclaration) => void;
                addImportForNonExistentExport: (exportName: string, exportingFileName: string, exportKind: ExportKind, exportedMeanings: SymbolFlags, isImportUsageValidAsTypeOnly: boolean) => void;
                addImportForModuleSymbol: (symbolAlias: Symbol, isValidTypeOnlyUseSite: boolean, referenceImport: ImportOrRequireAliasDeclaration) => void;
                addImportForUnresolvedIdentifier: (context: CodeFixContextBase, symbolToken: Identifier, useAutoImportProvider: boolean) => void;
                addVerbatimImport: (declaration: AnyImportOrRequireStatement | ImportOrRequireAliasDeclaration) => void;
                removeExistingImport: (declaration: ImportOrRequireAliasDeclaration) => void;
                writeFixes: (changeTracker: textChanges.ChangeTracker, oldFileQuotePreference?: QuotePreference) => void;
            }
            interface ImportSpecifierResolver {
                getModuleSpecifierForBestExportInfo(exportInfo: readonly SymbolExportInfo[], position: number, isValidTypeOnlyUseSite: boolean, fromCacheOnly?: boolean): {
                    exportInfo?: SymbolExportInfo | FutureSymbolExportInfo;
                    moduleSpecifier: string;
                    computedWithoutCacheCount: number;
                } | undefined;
            }
            function createMissingMemberNodes(classDeclaration: ClassLikeDeclaration, possiblyMissingSymbols: readonly Symbol[], sourceFile: SourceFile, context: TypeConstructionContext, preferences: UserPreferences, importAdder: ImportAdder | undefined, addClassElement: (node: AddNode) => void): void;
            function getNoopSymbolTrackerWithResolver(context: TypeConstructionContext): SymbolTracker;
            function addNewNodeForMemberSymbol(symbol: Symbol, enclosingDeclaration: ClassLikeDeclaration, sourceFile: SourceFile, context: TypeConstructionContext, preferences: UserPreferences, importAdder: ImportAdder | undefined, addClassElement: (node: AddNode) => void, body: Block | undefined, preserveOptional?: PreserveOptionalFlags, isAmbient?: boolean): void;
            function createSignatureDeclarationFromSignature(kind: SyntaxKind.MethodDeclaration | SyntaxKind.FunctionExpression | SyntaxKind.ArrowFunction | SyntaxKind.FunctionDeclaration, context: TypeConstructionContext, quotePreference: QuotePreference, signature: Signature, body: Block | undefined, name: PropertyName | undefined, modifiers: NodeArray<Modifier> | undefined, optional: boolean | undefined, enclosingDeclaration: Node | undefined, importAdder: ImportAdder | undefined): FunctionDeclaration | MethodDeclaration | FunctionExpression | ArrowFunction | undefined;
            function createSignatureDeclarationFromCallExpression(kind: SyntaxKind.MethodDeclaration | SyntaxKind.FunctionDeclaration | SyntaxKind.MethodSignature, context: CodeFixContextBase, importAdder: ImportAdder, call: CallExpression, name: Identifier | PrivateIdentifier | string, modifierFlags: ModifierFlags, contextNode: Node): MethodDeclaration | FunctionDeclaration | MethodSignature;
            function typeToAutoImportableTypeNode(checker: TypeChecker, importAdder: ImportAdder, type: Type, contextNode: Node | undefined, scriptTarget: ScriptTarget, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker): TypeNode | undefined;
            function typeNodeToAutoImportableTypeNode(typeNode: TypeNode, importAdder: ImportAdder, scriptTarget: ScriptTarget): TypeNode | undefined;
            function typeToMinimizedReferenceType(checker: TypeChecker, type: Type, contextNode: Node | undefined, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker): TypeNode | undefined;
            function typePredicateToAutoImportableTypeNode(checker: TypeChecker, importAdder: ImportAdder, typePredicate: TypePredicate, contextNode: Node | undefined, scriptTarget: ScriptTarget, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker): TypeNode | undefined;
            function createStubbedBody(text: string, quotePreference: QuotePreference): Block;
            function setJsonCompilerOptionValues(changeTracker: textChanges.ChangeTracker, configFile: TsConfigSourceFile, options: [
                string,
                Expression
            ][]): undefined;
            function setJsonCompilerOptionValue(changeTracker: textChanges.ChangeTracker, configFile: TsConfigSourceFile, optionName: string, optionValue: Expression): void;
            function tryGetAutoImportableReferenceFromTypeNode(importTypeNode: TypeNode | undefined, scriptTarget: ScriptTarget): {
                typeNode: TypeNode;
                symbols: Symbol[];
            } | undefined;
            function importSymbols(importAdder: ImportAdder, symbols: readonly Symbol[]): void;
            function findAncestorMatchingSpan(sourceFile: SourceFile, span: TextSpan): Node;
            interface TypeConstructionContext {
                program: Program;
                host: LanguageServiceHost;
            }
            type AddNode = PropertyDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration | FunctionExpression | ArrowFunction;
            enum PreserveOptionalFlags {
                Method = 1,
                Property = 2,
                All = 3
            }
            interface ArgumentTypeParameterAndConstraint {
                argumentType: Type;
                constraint?: TypeNode;
            }
            function generateAccessorFromProperty(file: SourceFile, program: Program, start: number, end: number, context: textChanges.TextChangesContext, _actionName: string): FileTextChanges[] | undefined;
            function getAccessorConvertiblePropertyAtPosition(file: SourceFile, program: Program, start: number, end: number, considerEmptySpans?: boolean): AccessorOrRefactorErrorInfo | undefined;
            function getAllSupers(decl: ClassOrInterface | undefined, checker: TypeChecker): readonly ClassOrInterface[];
            type AcceptedDeclaration = ParameterPropertyDeclaration | PropertyDeclaration | PropertyAssignment;
            type AcceptedNameType = Identifier | StringLiteral;
            type ContainerDeclaration = ClassLikeDeclaration | ObjectLiteralExpression;
            type AccessorOrRefactorErrorInfo = AccessorInfo | refactor.RefactorErrorInfo;
            interface AccessorInfo {
                readonly container: ContainerDeclaration;
                readonly isStatic: boolean;
                readonly isReadonly: boolean;
                readonly type: TypeNode | undefined;
                readonly declaration: AcceptedDeclaration;
                readonly fieldName: AcceptedNameType;
                readonly accessorName: AcceptedNameType;
                readonly originalName: string;
                readonly renameAccessor: boolean;
            }
            type ClassOrInterface = ClassLikeDeclaration | InterfaceDeclaration;
        }
        namespace Completions {
            namespace StringCompletions {
                function getStringLiteralCompletions(sourceFile: SourceFile, position: number, contextToken: Node | undefined, options: CompilerOptions, host: LanguageServiceHost, program: Program, log: Log, preferences: UserPreferences, includeSymbol: boolean): CompletionInfo | undefined;
                function getStringLiteralCompletionDetails(name: string, sourceFile: SourceFile, position: number, contextToken: Node | undefined, program: Program, host: LanguageServiceHost, cancellationToken: CancellationToken, preferences: UserPreferences): CompletionEntryDetails | undefined;
            }
            function getDefaultCommitCharacters(isNewIdentifierLocation: boolean): string[];
            function getCompletionsAtPosition(host: LanguageServiceHost, program: Program, log: Log, sourceFile: SourceFile, position: number, preferences: UserPreferences, triggerCharacter: CompletionsTriggerCharacter | undefined, completionKind: CompletionTriggerKind | undefined, cancellationToken: CancellationToken, formatContext?: formatting.FormatContext, includeSymbol?: boolean): CompletionInfo | undefined;
            function getCompletionEntriesFromSymbols(symbols: readonly Symbol[], entries: SortedArray<CompletionEntry>, replacementToken: Node | undefined, contextToken: Node | undefined, location: Node, position: number, sourceFile: SourceFile, host: LanguageServiceHost, program: Program, target: ScriptTarget, log: Log, kind: CompletionKind, preferences: UserPreferences, compilerOptions: CompilerOptions, formatContext: formatting.FormatContext | undefined, isTypeOnlyLocation?: boolean, propertyAccessToConvert?: PropertyAccessExpression, jsxIdentifierExpected?: boolean, isJsxInitializer?: IsJsxInitializer, importStatementCompletion?: ImportStatementCompletionInfo, recommendedCompletion?: Symbol, symbolToOriginInfoMap?: SymbolOriginInfoMap, symbolToSortTextMap?: SymbolSortTextMap, isJsxIdentifierExpected?: boolean, isRightOfOpenTag?: boolean, includeSymbol?: boolean): UniqueNameSet;
            function getCompletionEntryDetails(program: Program, log: Log, sourceFile: SourceFile, position: number, entryId: CompletionEntryIdentifier, host: LanguageServiceHost, formatContext: formatting.FormatContext, preferences: UserPreferences, cancellationToken: CancellationToken): CompletionEntryDetails | undefined;
            function createCompletionDetailsForSymbol(symbol: Symbol, name: string, checker: TypeChecker, sourceFile: SourceFile, location: Node, cancellationToken: CancellationToken, codeActions?: CodeAction[], sourceDisplay?: SymbolDisplayPart[]): CompletionEntryDetails;
            function createCompletionDetails(name: string, kindModifiers: string, kind: ScriptElementKind, displayParts: SymbolDisplayPart[], documentation?: SymbolDisplayPart[], tags?: JSDocTagInfo[], codeActions?: CodeAction[], source?: SymbolDisplayPart[]): CompletionEntryDetails;
            function getCompletionEntrySymbol(program: Program, log: Log, sourceFile: SourceFile, position: number, entryId: CompletionEntryIdentifier, host: LanguageServiceHost, preferences: UserPreferences): Symbol | undefined;
            function getPropertiesForObjectExpression(contextualType: Type, completionsType: Type | undefined, obj: ObjectLiteralExpression | JsxAttributes, checker: TypeChecker): Symbol[];
            const moduleSpecifierResolutionLimit = 100;
            const moduleSpecifierResolutionCacheAttemptLimit = 1000;
            type Log = (message: string) => void;
            type SortText = string & {
                __sortText: any;
            };
            const SortText: {
                LocalDeclarationPriority: SortText;
                LocationPriority: SortText;
                OptionalMember: SortText;
                MemberDeclaredBySpreadAssignment: SortText;
                SuggestedClassMembers: SortText;
                GlobalsOrKeywords: SortText;
                AutoImportSuggestions: SortText;
                ClassMemberSnippets: SortText;
                JavascriptIdentifiers: SortText;
                Deprecated(sortText: SortText): SortText;
                ObjectLiteralProperty(presetSortText: SortText, symbolDisplayName: string): SortText;
                SortBelow(sortText: SortText): SortText;
            };
            enum CompletionSource {
                ThisProperty = "ThisProperty/",
                ClassMemberSnippet = "ClassMemberSnippet/",
                TypeOnlyAlias = "TypeOnlyAlias/",
                ObjectLiteralMethodSnippet = "ObjectLiteralMethodSnippet/",
                SwitchCases = "SwitchCases/",
                ObjectLiteralMemberWithComma = "ObjectLiteralMemberWithComma/"
            }
            enum SymbolOriginInfoKind {
                ThisType = 1,
                SymbolMember = 2,
                Export = 4,
                Promise = 8,
                Nullable = 16,
                ResolvedExport = 32,
                TypeOnlyAlias = 64,
                ObjectLiteralMethod = 128,
                Ignore = 256,
                ComputedPropertyName = 512,
                SymbolMemberNoExport = 2,
                SymbolMemberExport = 6
            }
            interface SymbolOriginInfo {
                kind: SymbolOriginInfoKind;
                isDefaultExport?: boolean;
                isFromPackageJson?: boolean;
                fileName?: string;
            }
            interface UniqueNameSet {
                add(name: string): void;
                has(name: string): boolean;
            }
            type SymbolOriginInfoMap = Record<number, SymbolOriginInfo>;
            type SymbolSortTextMap = (SortText | undefined)[];
            interface CompletionEntryIdentifier {
                name: string;
                source?: string;
                data?: CompletionEntryData;
            }
            type IsJsxInitializer = boolean | Identifier;
            enum CompletionKind {
                ObjectPropertyDeclaration = 0,
                Global = 1,
                PropertyAccess = 2,
                MemberLike = 3,
                String = 4,
                None = 5
            }
            interface ImportStatementCompletionInfo {
                isKeywordOnlyCompletion: boolean;
                keywordCompletion: TokenSyntaxKind | undefined;
                isNewIdentifierLocation: boolean;
                isTopLevelTypeOnly: boolean;
                couldBeTypeOnlyImportSpecifier: boolean;
                replacementSpan: TextSpan | undefined;
            }
        }
        namespace FindAllReferences {
            function createImportTracker(sourceFiles: readonly SourceFile[], sourceFilesSet: ReadonlySet<string>, checker: TypeChecker, cancellationToken: CancellationToken | undefined): ImportTracker;
            function findModuleReferences(program: Program, sourceFiles: readonly SourceFile[], searchModuleSymbol: Symbol): ModuleReference[];
            function getImportOrExportSymbol(node: Node, symbol: Symbol, checker: TypeChecker, comingFromExport: boolean): ImportedSymbol | ExportedSymbol | undefined;
            function getExportInfo(exportSymbol: Symbol, exportKind: ExportKind, checker: TypeChecker): ExportInfo | undefined;
            interface ImportsResult {
                importSearches: readonly [
                    ModuleExportName,
                    Symbol
                ][];
                singleReferences: readonly (Identifier | StringLiteral)[];
                indirectUsers: readonly SourceFile[];
            }
            type ImportTracker = (exportSymbol: Symbol, exportInfo: ExportInfo, isForRename: boolean) => ImportsResult;
            interface ExportInfo {
                exportingModuleSymbol: Symbol;
                exportKind: ExportKind;
            }
            enum ExportKind {
                Named = 0,
                Default = 1,
                ExportEquals = 2
            }
            enum ImportExport {
                Import = 0,
                Export = 1
            }
            type ModuleReference = {
                kind: "import";
                literal: StringLiteralLike;
            } | {
                kind: "reference";
                referencingFile: SourceFile;
                ref: FileReference;
            } | {
                kind: "implicit";
                literal: StringLiteralLike;
                referencingFile: SourceFile;
            };
            interface ImportedSymbol {
                kind: ImportExport.Import;
                symbol: Symbol;
            }
            interface ExportedSymbol {
                kind: ImportExport.Export;
                symbol: Symbol;
                exportInfo: ExportInfo;
            }
            function isContextWithStartAndEndNode(node: ContextNode): node is ContextWithStartAndEndNode;
            function getContextNode(node: NamedDeclaration | BinaryExpression | ForInOrOfStatement | SwitchStatement | undefined): ContextNode | undefined;
            function toContextSpan(textSpan: TextSpan, sourceFile: SourceFile, context: ContextNode | undefined): {
                contextSpan: TextSpan;
            } | undefined;
            function findReferencedSymbols(program: Program, cancellationToken: CancellationToken, sourceFiles: readonly SourceFile[], sourceFile: SourceFile, position: number): ReferencedSymbol[] | undefined;
            function getImplementationsAtPosition(program: Program, cancellationToken: CancellationToken, sourceFiles: readonly SourceFile[], sourceFile: SourceFile, position: number): ImplementationLocation[] | undefined;
            function findReferenceOrRenameEntries<T>(program: Program, cancellationToken: CancellationToken, sourceFiles: readonly SourceFile[], node: Node, position: number, options: Options | undefined, convertEntry: ToReferenceOrRenameEntry<T>): T[] | undefined;
            function getReferenceEntriesForNode(position: number, node: Node, program: Program, sourceFiles: readonly SourceFile[], cancellationToken: CancellationToken, options?: Options, sourceFilesSet?: ReadonlySet<string>): readonly Entry[] | undefined;
            function toRenameLocation(entry: Entry, originalNode: Node, checker: TypeChecker, providePrefixAndSuffixText: boolean, quotePreference: QuotePreference): RenameLocation;
            function toReferenceEntry(entry: Entry): ReferenceEntry;
            function toHighlightSpan(entry: Entry): {
                fileName: string;
                span: HighlightSpan;
            };
            function isWriteAccessForReference(node: Node): boolean;
            function isDeclarationOfSymbol(node: Node, target: Symbol | undefined): boolean;
            interface SymbolAndEntries {
                readonly definition: Definition | undefined;
                readonly references: readonly Entry[];
            }
            enum DefinitionKind {
                Symbol = 0,
                Label = 1,
                Keyword = 2,
                This = 3,
                String = 4,
                TripleSlashReference = 5
            }
            type Definition = {
                readonly type: DefinitionKind.Symbol;
                readonly symbol: Symbol;
            } | {
                readonly type: DefinitionKind.Label;
                readonly node: Identifier;
            } | {
                readonly type: DefinitionKind.Keyword;
                readonly node: Node;
            } | {
                readonly type: DefinitionKind.This;
                readonly node: Node;
            } | {
                readonly type: DefinitionKind.String;
                readonly node: StringLiteralLike;
            } | {
                readonly type: DefinitionKind.TripleSlashReference;
                readonly reference: FileReference;
                readonly file: SourceFile;
            };
            enum EntryKind {
                Span = 0,
                Node = 1,
                StringLiteral = 2,
                SearchedLocalFoundProperty = 3,
                SearchedPropertyFoundLocal = 4
            }
            type NodeEntryKind = EntryKind.Node | EntryKind.StringLiteral | EntryKind.SearchedLocalFoundProperty | EntryKind.SearchedPropertyFoundLocal;
            type Entry = NodeEntry | SpanEntry;
            interface ContextWithStartAndEndNode {
                start: Node;
                end: Node;
            }
            type ContextNode = Node | ContextWithStartAndEndNode;
            interface NodeEntry {
                readonly kind: NodeEntryKind;
                readonly node: Node;
                readonly context?: ContextNode;
            }
            interface SpanEntry {
                readonly kind: EntryKind.Span;
                readonly fileName: string;
                readonly textSpan: TextSpan;
            }
            enum FindReferencesUse {
                Other = 0,
                References = 1,
                Rename = 2
            }
            interface Options {
                readonly findInStrings?: boolean;
                readonly findInComments?: boolean;
                readonly use?: FindReferencesUse;
                readonly implementations?: boolean;
                readonly providePrefixAndSuffixTextForRename?: boolean;
            }
            type ToReferenceOrRenameEntry<T> = (entry: Entry, originalNode: Node, checker: TypeChecker) => T;
            namespace Core {
                function getReferencedSymbolsForNode(position: number, node: Node, program: Program, sourceFiles: readonly SourceFile[], cancellationToken: CancellationToken, options?: Options, sourceFilesSet?: ReadonlySet<string>): readonly SymbolAndEntries[] | undefined;
                function getAdjustedNode(node: Node, options: Options): Node;
                function getReferencesForFileName(fileName: string, program: Program, sourceFiles: readonly SourceFile[], sourceFilesSet?: ReadonlySet<string>): readonly Entry[];
                function eachExportReference(sourceFiles: readonly SourceFile[], checker: TypeChecker, cancellationToken: CancellationToken | undefined, exportSymbol: Symbol, exportingModuleSymbol: Symbol, exportName: string, isDefaultExport: boolean, cb: (ref: ModuleExportName) => void): void;
                function isSymbolReferencedInFile(definition: Identifier, checker: TypeChecker, sourceFile: SourceFile, searchContainer?: Node): boolean;
                function eachSymbolReferenceInFile<T>(definition: Identifier, checker: TypeChecker, sourceFile: SourceFile, cb: (token: Identifier) => T, searchContainer?: Node): T | undefined;
                function getTopMostDeclarationNamesInFile(declarationName: string, sourceFile: SourceFile): readonly Node[];
                function someSignatureUsage(signature: SignatureDeclaration, sourceFiles: readonly SourceFile[], checker: TypeChecker, cb: (name: Identifier, call?: CallExpression) => boolean): boolean;
                function getIntersectingMeaningFromDeclarations(node: Node, symbol: Symbol): SemanticMeaning;
                function getReferenceEntriesForShorthandPropertyAssignment(node: Node, checker: TypeChecker, addReference: (node: Node) => void): void;
            }
        }
        namespace GoToDefinition {
            function getDefinitionAtPosition(program: Program, sourceFile: SourceFile, position: number, searchOtherFilesOnly?: boolean, stopAtAlias?: boolean): readonly DefinitionInfo[] | undefined;
            function getReferenceAtPosition(sourceFile: SourceFile, position: number, program: Program): {
                reference: FileReference;
                fileName: string;
                unverified: boolean;
                file?: SourceFile;
            } | undefined;
            function getTypeDefinitionAtPosition(typeChecker: TypeChecker, sourceFile: SourceFile, position: number): readonly DefinitionInfo[] | undefined;
            function getDefinitionAndBoundSpan(program: Program, sourceFile: SourceFile, position: number): DefinitionInfoAndBoundSpan | undefined;
            function createDefinitionInfo(declaration: Declaration, checker: TypeChecker, symbol: Symbol, node: Node, unverified?: boolean, failedAliasResolution?: boolean): DefinitionInfo;
        }
        namespace InlayHints {
            function provideInlayHints(context: InlayHintsContext): InlayHint[];
        }
        namespace MapCode {
            function mapCode(sourceFile: SourceFile, contents: string[], focusLocations: TextSpan[][] | undefined, host: LanguageServiceHost, formatContext: formatting.FormatContext, preferences: UserPreferences): FileTextChanges[];
        }
        namespace JsDoc {
            function getJsDocCommentsFromDeclarations(declarations: readonly Declaration[], checker?: TypeChecker): SymbolDisplayPart[];
            function getJsDocTagsFromDeclarations(declarations?: Declaration[], checker?: TypeChecker): JSDocTagInfo[];
            function getJSDocTagNameCompletions(): CompletionEntry[];
            function getJSDocTagCompletions(): CompletionEntry[];
            function getJSDocTagCompletionDetails(name: string): CompletionEntryDetails;
            function getJSDocParameterNameCompletions(tag: JSDocParameterTag): CompletionEntry[];
            function getJSDocParameterNameCompletionDetails(name: string): CompletionEntryDetails;
            function getDocCommentTemplateAtPosition(newLine: string, sourceFile: SourceFile, position: number, options?: DocCommentTemplateOptions): TextInsertion | undefined;
            const getJSDocTagNameCompletionDetails: typeof getJSDocTagCompletionDetails;
        }
        namespace NavigateTo {
            function getNavigateToItems(sourceFiles: readonly SourceFile[], checker: TypeChecker, cancellationToken: CancellationToken, searchValue: string, maxResultCount: number | undefined, excludeDtsFiles: boolean, excludeLibFiles?: boolean): NavigateToItem[];
        }
        namespace NavigationBar {
            function getNavigationBarItems(sourceFile: SourceFile, cancellationToken: CancellationToken): NavigationBarItem[];
            function getNavigationTree(sourceFile: SourceFile, cancellationToken: CancellationToken): NavigationTree;
        }
        namespace OrganizeImports {
            function organizeImports(sourceFile: SourceFile, formatContext: formatting.FormatContext, host: LanguageServiceHost, program: Program, preferences: UserPreferences, mode: OrganizeImportsMode): FileTextChanges[];
            function getOrganizeImportsStringComparerWithDetection(originalImportDecls: readonly AnyImportOrRequireStatement[], preferences: UserPreferences): {
                comparer: Comparer<string>;
                isSorted: boolean;
            };
            function getNamedImportSpecifierComparerWithDetection(importDecl: ImportDeclaration | JSDocImportTag, preferences: UserPreferences, sourceFile?: SourceFile): {
                specifierComparer: Comparer<ImportSpecifier>;
                isSorted: boolean | undefined;
            };
            function getImportDeclarationInsertionIndex(sortedImports: readonly AnyImportOrRequireStatement[], newImport: AnyImportOrRequireStatement, comparer: Comparer<string>): number;
            function getImportSpecifierInsertionIndex(sortedImports: readonly ImportSpecifier[], newImport: ImportSpecifier, comparer: Comparer<ImportSpecifier>): number;
            function compareImportsOrRequireStatements(s1: AnyImportOrRequireStatement, s2: AnyImportOrRequireStatement, comparer: Comparer<string>): Comparison;
            function testCoalesceImports(importGroup: readonly ImportDeclaration[], ignoreCase: boolean, sourceFile?: SourceFile, preferences?: UserPreferences): readonly ImportDeclaration[];
            function testCoalesceExports(exportGroup: readonly ExportDeclaration[], ignoreCase: boolean, preferences?: UserPreferences): readonly ExportDeclaration[];
            function compareModuleSpecifiers(m1: Expression | undefined, m2: Expression | undefined, ignoreCase?: boolean): Comparison;
        }
        namespace OutliningElementsCollector {
            function collectElements(sourceFile: SourceFile, cancellationToken: CancellationToken): OutliningSpan[];
        }
        namespace refactor {
            namespace extractSymbol {
                function getRefactorActionsToExtractSymbol(context: RefactorContext): readonly ApplicableRefactorInfo[];
                function getRefactorEditsToExtractSymbol(context: RefactorContext, actionName: string): RefactorEditInfo | undefined;
                function getRangeToExtract(sourceFile: SourceFile, span: TextSpan, invoked?: boolean): RangeToExtract;
                namespace Messages {
                    const cannotExtractRange: DiagnosticMessage;
                    const cannotExtractImport: DiagnosticMessage;
                    const cannotExtractSuper: DiagnosticMessage;
                    const cannotExtractJSDoc: DiagnosticMessage;
                    const cannotExtractEmpty: DiagnosticMessage;
                    const expressionExpected: DiagnosticMessage;
                    const uselessConstantType: DiagnosticMessage;
                    const statementOrExpressionExpected: DiagnosticMessage;
                    const cannotExtractRangeContainingConditionalBreakOrContinueStatements: DiagnosticMessage;
                    const cannotExtractRangeContainingConditionalReturnStatement: DiagnosticMessage;
                    const cannotExtractRangeContainingLabeledBreakOrContinueStatementWithTargetOutsideOfTheRange: DiagnosticMessage;
                    const cannotExtractRangeThatContainsWritesToReferencesLocatedOutsideOfTheTargetRangeInGenerators: DiagnosticMessage;
                    const typeWillNotBeVisibleInTheNewScope: DiagnosticMessage;
                    const functionWillNotBeVisibleInTheNewScope: DiagnosticMessage;
                    const cannotExtractIdentifier: DiagnosticMessage;
                    const cannotExtractExportedEntity: DiagnosticMessage;
                    const cannotWriteInExpression: DiagnosticMessage;
                    const cannotExtractReadonlyPropertyInitializerOutsideConstructor: DiagnosticMessage;
                    const cannotExtractAmbientBlock: DiagnosticMessage;
                    const cannotAccessVariablesFromNestedScopes: DiagnosticMessage;
                    const cannotExtractToJSClass: DiagnosticMessage;
                    const cannotExtractToExpressionArrowFunction: DiagnosticMessage;
                    const cannotExtractFunctionsContainingThisToMethod: DiagnosticMessage;
                }
                enum RangeFacts {
                    None = 0,
                    HasReturn = 1,
                    IsGenerator = 2,
                    IsAsyncFunction = 4,
                    UsesThis = 8,
                    UsesThisInFunction = 16,
                    InStaticRegion = 32
                }
                interface TargetRange {
                    readonly range: Expression | Statement[];
                    readonly facts: RangeFacts;
                    readonly thisNode: Node | undefined;
                }
                type RangeToExtract = {
                    readonly targetRange?: never;
                    readonly errors: readonly Diagnostic[];
                } | {
                    readonly targetRange: TargetRange;
                    readonly errors?: never;
                };
            }
            function registerRefactor(name: string, refactor: Refactor): void;
            function getApplicableRefactors(context: RefactorContext, includeInteractiveActions?: boolean): ApplicableRefactorInfo[];
            function getEditsForRefactor(context: RefactorContext, refactorName: string, actionName: string, interactiveRefactorArguments?: InteractiveRefactorArguments): RefactorEditInfo | undefined;
            function doChangeNamedToNamespaceOrDefault(sourceFile: SourceFile, program: Program, changes: textChanges.ChangeTracker, toConvert: NamedImports, shouldUseDefault?: boolean): void;
            function isRefactorErrorInfo(info: unknown): info is RefactorErrorInfo;
            function refactorKindBeginsWith(known: string, requested: string | undefined): boolean;
            function getIdentifierForNode(node: Node, scope: FunctionLikeDeclaration | SourceFile | ModuleBlock | ClassLikeDeclaration, checker: TypeChecker, file: SourceFile): string;
            function addTargetFileImports(oldFile: SourceFile, importsToCopy: Map<Symbol, [
                boolean,
                codefix.ImportOrRequireAliasDeclaration | undefined
            ]>, targetFileImportsFromOldFile: Map<Symbol, boolean>, checker: TypeChecker, program: Program, importAdder: codefix.ImportAdder): void;
            interface RefactorErrorInfo {
                error: string;
            }
            function getNewStatementsAndRemoveFromOldFile(oldFile: SourceFile, targetFile: SourceFile | FutureSourceFile, usage: UsageInfo, changes: textChanges.ChangeTracker, toMove: ToMove, program: Program, host: LanguageServiceHost, preferences: UserPreferences, importAdderForNewFile: codefix.ImportAdder, importAdderForOldFile: codefix.ImportAdder): void;
            function addNewFileToTsconfig(program: Program, changes: textChanges.ChangeTracker, oldFileName: string, newFileNameWithExtension: string, getCanonicalFileName: GetCanonicalFileName): void;
            function addExportsInOldFile(oldFile: SourceFile, targetFileImportsFromOldFile: Map<Symbol, boolean>, changes: textChanges.ChangeTracker, useEsModuleSyntax: boolean): void;
            function addImportsForMovedSymbols(symbols: Map<Symbol, boolean>, targetFileName: string, importAdder: codefix.ImportAdder, program: Program): void;
            function createNewFileName(oldFile: SourceFile, program: Program, host: LanguageServiceHost, toMove: ToMove | undefined): string;
            function getStatementsToMove(context: RefactorContext): ToMove | undefined;
            function containsJsx(statements: readonly Statement[] | undefined): Statement | undefined;
            function getUsageInfo(oldFile: SourceFile, toMove: readonly Statement[], checker: TypeChecker, existingTargetLocals?: ReadonlySet<Symbol>, enclosingRange?: TextRange): UsageInfo;
            function isInImport(decl: Declaration): boolean;
            function getExistingLocals(sourceFile: SourceFile, statements: readonly Statement[], checker: TypeChecker): Set<Symbol>;
            type SupportedImport = ImportDeclaration & {
                moduleSpecifier: StringLiteralLike;
            } | ImportEqualsDeclaration & {
                moduleReference: ExternalModuleReference & {
                    expression: StringLiteralLike;
                };
            } | VariableDeclaration & {
                initializer: RequireOrImportCall;
            };
            type SupportedImportStatement = ImportDeclaration | ImportEqualsDeclaration | VariableStatement;
            type TopLevelDeclarationStatement = NonVariableTopLevelDeclaration | VariableStatement;
            interface ToMove {
                readonly all: readonly Statement[];
                readonly ranges: readonly StatementRange[];
            }
            interface StatementRange {
                readonly first: Statement;
                readonly afterLast: Statement | undefined;
            }
            interface UsageInfo {
                readonly movedSymbols: Set<Symbol>;
                readonly targetFileImportsFromOldFile: Map<Symbol, boolean>;
                readonly oldFileImportsFromTargetFile: Map<Symbol, boolean>;
                readonly oldImportsNeededByTargetFile: Map<Symbol, [
                    boolean,
                    codefix.ImportOrRequireAliasDeclaration | undefined
                ]>;
                readonly unusedImportsFromOldFile: Set<Symbol>;
            }
            type TopLevelExpressionStatement = ExpressionStatement & {
                expression: BinaryExpression & {
                    left: PropertyAccessExpression;
                };
            };
            type NonVariableTopLevelDeclaration = FunctionDeclaration | ClassDeclaration | EnumDeclaration | TypeAliasDeclaration | InterfaceDeclaration | ModuleDeclaration | TopLevelExpressionStatement | ImportEqualsDeclaration;
            interface TopLevelVariableDeclaration extends VariableDeclaration {
                parent: VariableDeclarationList & {
                    parent: VariableStatement;
                };
            }
            type TopLevelDeclaration = NonVariableTopLevelDeclaration | TopLevelVariableDeclaration | BindingElement;
        }
        namespace Rename {
            function getRenameInfo(program: Program, sourceFile: SourceFile, position: number, preferences: UserPreferences): RenameInfo;
            function nodeIsEligibleForRename(node: Node): boolean;
        }
        namespace SignatureHelp {
            function getSignatureHelpItems(program: Program, sourceFile: SourceFile, position: number, triggerReason: SignatureHelpTriggerReason | undefined, cancellationToken: CancellationToken): SignatureHelpItems | undefined;
            function getArgumentInfoForCompletions(node: Node, position: number, sourceFile: SourceFile, checker: TypeChecker): ArgumentInfoForCompletions | undefined;
            interface ArgumentInfoForCompletions {
                readonly invocation: CallLikeExpression;
                readonly argumentIndex: number;
                readonly argumentCount: number;
            }
        }
        namespace SmartSelectionRange {
            function getSmartSelectionRange(pos: number, sourceFile: SourceFile): SelectionRange;
        }
        namespace SymbolDisplay {
            function getSymbolKind(typeChecker: TypeChecker, symbol: Symbol, location: Node): ScriptElementKind;
            function getSymbolModifiers(typeChecker: TypeChecker, symbol: Symbol): string;
            function getSymbolDisplayPartsDocumentationAndSymbolKind(typeChecker: TypeChecker, symbol: Symbol, sourceFile: SourceFile, enclosingDeclaration: Node | undefined, location: Node, semanticMeaning?: SemanticMeaning, alias?: Symbol, verbosityLevel?: number): SymbolDisplayPartsDocumentationAndSymbolKind;
            interface SymbolDisplayPartsDocumentationAndSymbolKind {
                displayParts: SymbolDisplayPart[];
                documentation: SymbolDisplayPart[];
                symbolKind: ScriptElementKind;
                tags: JSDocTagInfo[] | undefined;
                canIncreaseVerbosityLevel?: boolean;
            }
        }
        namespace textChanges {
            function getAdjustedEndPosition(sourceFile: SourceFile, node: Node, options: ConfigurableEnd): number;
            function isThisTypeAnnotatable(containingFunction: SignatureDeclaration): containingFunction is ThisTypeAnnotatable;
            function applyChanges(text: string, changes: readonly TextChange[]): string;
            function assignPositionsToNode(node: Node): Node;
            function createWriter(newLine: string): TextChangesWriter;
            function isValidLocationToAddComment(sourceFile: SourceFile, position: number): boolean;
            function deleteNode(changes: ChangeTracker, sourceFile: SourceFile, node: Node, options?: ConfigurableStartEnd): void;
            interface ConfigurableStart {
                leadingTriviaOption?: LeadingTriviaOption;
            }
            interface ConfigurableEnd {
                trailingTriviaOption?: TrailingTriviaOption;
            }
            enum LeadingTriviaOption {
                Exclude = 0,
                IncludeAll = 1,
                JSDoc = 2,
                StartLine = 3
            }
            enum TrailingTriviaOption {
                Exclude = 0,
                ExcludeWhitespace = 1,
                Include = 2
            }
            interface ConfigurableStartEnd extends ConfigurableStart, ConfigurableEnd {
            }
            interface InsertNodeOptions {
                prefix?: string;
                suffix?: string;
                indentation?: number;
                delta?: number;
            }
            interface ReplaceWithMultipleNodesOptions extends InsertNodeOptions {
                readonly joiner?: string;
            }
            interface ChangeNodeOptions extends ConfigurableStartEnd, InsertNodeOptions {
            }
            interface TextChangesContext {
                host: LanguageServiceHost;
                formatContext: formatting.FormatContext;
                preferences: UserPreferences;
            }
            type TypeAnnotatable = SignatureDeclaration | VariableDeclaration | ParameterDeclaration | PropertyDeclaration | PropertySignature;
            type ThisTypeAnnotatable = FunctionDeclaration | FunctionExpression;
            class ChangeTracker {
                private readonly newLineCharacter;
                private readonly formatContext;
                private readonly changes;
                private newFileChanges?;
                private readonly classesWithNodesInsertedAtStart;
                private readonly deletedNodes;
                static fromContext(context: TextChangesContext): ChangeTracker;
                static with(context: TextChangesContext, cb: (tracker: ChangeTracker) => void): FileTextChanges[];
                constructor(newLineCharacter: string, formatContext: formatting.FormatContext);
                pushRaw(sourceFile: SourceFile, change: FileTextChanges): void;
                deleteRange(sourceFile: SourceFile, range: TextRange): void;
                delete(sourceFile: SourceFile, node: Node | NodeArray<TypeParameterDeclaration>): void;
                deleteNode(sourceFile: SourceFile, node: Node, options?: ConfigurableStartEnd): void;
                deleteNodes(sourceFile: SourceFile, nodes: readonly Node[], options: ConfigurableStartEnd | undefined, hasTrailingComment: boolean): void;
                deleteModifier(sourceFile: SourceFile, modifier: Modifier): void;
                deleteNodeRange(sourceFile: SourceFile, startNode: Node, endNode: Node, options?: ConfigurableStartEnd): void;
                deleteNodeRangeExcludingEnd(sourceFile: SourceFile, startNode: Node, afterEndNode: Node | undefined, options?: ConfigurableStartEnd): void;
                replaceRange(sourceFile: SourceFile, range: TextRange, newNode: Node, options?: InsertNodeOptions): void;
                replaceNode(sourceFile: SourceFile, oldNode: Node, newNode: Node, options?: ChangeNodeOptions): void;
                replaceNodeRange(sourceFile: SourceFile, startNode: Node, endNode: Node, newNode: Node, options?: ChangeNodeOptions): void;
                private replaceRangeWithNodes;
                replaceNodeWithNodes(sourceFile: SourceFile, oldNode: Node, newNodes: readonly Node[], options?: ChangeNodeOptions): void;
                replaceNodeWithText(sourceFile: SourceFile, oldNode: Node, text: string): void;
                replaceNodeRangeWithNodes(sourceFile: SourceFile, startNode: Node, endNode: Node, newNodes: readonly Node[], options?: ReplaceWithMultipleNodesOptions & ConfigurableStartEnd): void;
                nodeHasTrailingComment(sourceFile: SourceFile, oldNode: Node, configurableEnd?: ConfigurableEnd): boolean;
                private nextCommaToken;
                replacePropertyAssignment(sourceFile: SourceFile, oldNode: PropertyAssignment, newNode: PropertyAssignment): void;
                insertNodeAt(sourceFile: SourceFile, pos: number, newNode: Node, options?: InsertNodeOptions): void;
                private insertNodesAt;
                insertNodeAtTopOfFile(sourceFile: SourceFile, newNode: Statement, blankLineBetween: boolean): void;
                insertNodesAtTopOfFile(sourceFile: SourceFile, newNodes: readonly Statement[], blankLineBetween: boolean): void;
                private insertAtTopOfFile;
                insertNodesAtEndOfFile(sourceFile: SourceFile, newNodes: readonly Statement[], blankLineBetween: boolean): void;
                private insertAtEndOfFile;
                insertStatementsInNewFile(fileName: string, statements: readonly (Statement | SyntaxKind.NewLineTrivia)[], oldFile?: SourceFile): void;
                insertFirstParameter(sourceFile: SourceFile, parameters: NodeArray<ParameterDeclaration>, newParam: ParameterDeclaration): void;
                insertNodeBefore(sourceFile: SourceFile, before: Node, newNode: Node, blankLineBetween?: boolean, options?: ConfigurableStartEnd): void;
                insertNodesBefore(sourceFile: SourceFile, before: Node, newNodes: readonly Node[], blankLineBetween?: boolean, options?: ConfigurableStartEnd): void;
                insertModifierAt(sourceFile: SourceFile, pos: number, modifier: SyntaxKind, options?: InsertNodeOptions): void;
                insertModifierBefore(sourceFile: SourceFile, modifier: SyntaxKind, before: Node): void;
                insertCommentBeforeLine(sourceFile: SourceFile, lineNumber: number, position: number, commentText: string): void;
                insertJsdocCommentBefore(sourceFile: SourceFile, node: HasJSDoc, tag: JSDoc): void;
                private createJSDocText;
                replaceJSDocComment(sourceFile: SourceFile, node: HasJSDoc, tags: readonly JSDocTag[]): void;
                addJSDocTags(sourceFile: SourceFile, parent: HasJSDoc, newTags: readonly JSDocTag[]): void;
                filterJSDocTags(sourceFile: SourceFile, parent: HasJSDoc, predicate: (tag: JSDocTag) => boolean): void;
                replaceRangeWithText(sourceFile: SourceFile, range: TextRange, text: string): void;
                insertText(sourceFile: SourceFile, pos: number, text: string): void;
                tryInsertTypeAnnotation(sourceFile: SourceFile, node: TypeAnnotatable, type: TypeNode): boolean;
                tryInsertThisTypeAnnotation(sourceFile: SourceFile, node: ThisTypeAnnotatable, type: TypeNode): void;
                insertTypeParameters(sourceFile: SourceFile, node: SignatureDeclaration, typeParameters: readonly TypeParameterDeclaration[]): void;
                private getOptionsForInsertNodeBefore;
                insertNodeAtConstructorStart(sourceFile: SourceFile, ctr: ConstructorDeclaration, newStatement: Statement): void;
                insertNodeAtConstructorStartAfterSuperCall(sourceFile: SourceFile, ctr: ConstructorDeclaration, newStatement: Statement): void;
                insertNodeAtConstructorEnd(sourceFile: SourceFile, ctr: ConstructorDeclaration, newStatement: Statement): void;
                private replaceConstructorBody;
                insertNodeAtEndOfScope(sourceFile: SourceFile, scope: Node, newNode: Node): void;
                insertMemberAtStart(sourceFile: SourceFile, node: ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode | EnumDeclaration, newElement: ClassElement | PropertySignature | MethodSignature | EnumMember): void;
                insertNodeAtObjectStart(sourceFile: SourceFile, obj: ObjectLiteralExpression, newElement: ObjectLiteralElementLike): void;
                private insertNodeAtStartWorker;
                private guessIndentationFromExistingMembers;
                private computeIndentationForNewMember;
                private getInsertNodeAtStartInsertOptions;
                insertNodeAfterComma(sourceFile: SourceFile, after: Node, newNode: Node): void;
                insertNodeAfter(sourceFile: SourceFile, after: Node, newNode: Node): void;
                insertNodeAtEndOfList(sourceFile: SourceFile, list: NodeArray<Node>, newNode: Node): void;
                insertNodesAfter(sourceFile: SourceFile, after: Node, newNodes: readonly Node[]): void;
                private insertNodeAfterWorker;
                private getInsertNodeAfterOptions;
                private getInsertNodeAfterOptionsWorker;
                insertName(sourceFile: SourceFile, node: FunctionExpression | ClassExpression | ArrowFunction, name: string): void;
                insertExportModifier(sourceFile: SourceFile, node: DeclarationStatement | VariableStatement): void;
                insertImportSpecifierAtIndex(sourceFile: SourceFile, importSpecifier: ImportSpecifier, namedImports: NamedImports, index: number): void;
                insertNodeInListAfter(sourceFile: SourceFile, after: Node, newNode: Node, containingList?: NodeArray<Node> | undefined): void;
                parenthesizeExpression(sourceFile: SourceFile, expression: Expression): void;
                private finishClassesWithNodesInsertedAtStart;
                private finishDeleteDeclarations;
                getChanges(validate?: ValidateNonFormattedText): FileTextChanges[];
                createNewFile(oldFile: SourceFile | undefined, fileName: string, statements: readonly (Statement | SyntaxKind.NewLineTrivia)[]): void;
            }
            type ValidateNonFormattedText = (node: Node, text: string) => void;
            interface TextChangesWriter extends EmitTextWriter, PrintHandlers {
            }
        }
        namespace formatting {
            enum FormattingRequestKind {
                FormatDocument = 0,
                FormatSelection = 1,
                FormatOnEnter = 2,
                FormatOnSemicolon = 3,
                FormatOnOpeningCurlyBrace = 4,
                FormatOnClosingCurlyBrace = 5
            }
            class FormattingContext {
                readonly sourceFile: SourceFileLike;
                formattingRequestKind: FormattingRequestKind;
                options: FormatCodeSettings;
                currentTokenSpan: TextRangeWithKind;
                nextTokenSpan: TextRangeWithKind;
                contextNode: Node;
                currentTokenParent: Node;
                nextTokenParent: Node;
                private contextNodeAllOnSameLine;
                private nextNodeAllOnSameLine;
                private tokensAreOnSameLine;
                private contextNodeBlockIsOnOneLine;
                private nextNodeBlockIsOnOneLine;
                constructor(sourceFile: SourceFileLike, formattingRequestKind: FormattingRequestKind, options: FormatCodeSettings);
                updateContext(currentRange: TextRangeWithKind, currentTokenParent: Node, nextRange: TextRangeWithKind, nextTokenParent: Node, commonParent: Node): void;
                ContextNodeAllOnSameLine(): boolean;
                NextNodeAllOnSameLine(): boolean;
                TokensAreOnSameLine(): boolean;
                ContextNodeBlockIsOnOneLine(): boolean;
                NextNodeBlockIsOnOneLine(): boolean;
                private NodeIsOnOneLine;
                private BlockIsOnOneLine;
            }
            function getFormattingScanner<T>(text: string, languageVariant: LanguageVariant, startPos: number, endPos: number, cb: (scanner: FormattingScanner) => T): T;
            interface FormattingScanner {
                advance(): void;
                getTokenFullStart(): number;
                getStartPos(): number;
                isOnToken(): boolean;
                isOnEOF(): boolean;
                readTokenInfo(n: Node): TokenInfo;
                readEOFTokenRange(): TextRangeWithKind;
                getCurrentLeadingTrivia(): TextRangeWithKind[] | undefined;
                lastTrailingTriviaWasNewLine(): boolean;
                skipToEndOf(node: Node | NodeArray<Node>): void;
                skipToStartOf(node: Node): void;
            }
            interface Rule {
                readonly debugName: string;
                readonly context: readonly ContextPredicate[];
                readonly action: RuleAction;
                readonly flags: RuleFlags;
            }
            type ContextPredicate = (context: FormattingContext) => boolean;
            const anyContext: readonly ContextPredicate[];
            enum RuleAction {
                None = 0,
                StopProcessingSpaceActions = 1,
                StopProcessingTokenActions = 2,
                InsertSpace = 4,
                InsertNewLine = 8,
                DeleteSpace = 16,
                DeleteToken = 32,
                InsertTrailingSemicolon = 64,
                StopAction = 3,
                ModifySpaceAction = 28,
                ModifyTokenAction = 96
            }
            enum RuleFlags {
                None = 0,
                CanDeleteNewLines = 1
            }
            interface TokenRange {
                readonly tokens: readonly SyntaxKind[];
                readonly isSpecific: boolean;
            }
            function getAllRules(): RuleSpec[];
            interface RuleSpec {
                readonly leftTokenRange: TokenRange;
                readonly rightTokenRange: TokenRange;
                readonly rule: Rule;
            }
            function getFormatContext(options: FormatCodeSettings, host: FormattingHost): FormatContext;
            type RulesMap = (context: FormattingContext) => readonly Rule[] | undefined;
            function createTextRangeWithKind<T extends SyntaxKind>(pos: number, end: number, kind: T): TextRangeWithKind<T>;
            function formatOnEnter(position: number, sourceFile: SourceFile, formatContext: FormatContext): TextChange[];
            function formatOnSemicolon(position: number, sourceFile: SourceFile, formatContext: FormatContext): TextChange[];
            function formatOnOpeningCurly(position: number, sourceFile: SourceFile, formatContext: FormatContext): TextChange[];
            function formatOnClosingCurly(position: number, sourceFile: SourceFile, formatContext: FormatContext): TextChange[];
            function formatDocument(sourceFile: SourceFile, formatContext: FormatContext): TextChange[];
            function formatSelection(start: number, end: number, sourceFile: SourceFile, formatContext: FormatContext): TextChange[];
            function formatNodeGivenIndentation(node: Node, sourceFileLike: SourceFileLike, languageVariant: LanguageVariant, initialIndentation: number, delta: number, formatContext: FormatContext): TextChange[];
            function getRangeOfEnclosingComment(sourceFile: SourceFile, position: number, precedingToken?: Node | null, tokenAtPosition?: Node): CommentRange | undefined;
            function getIndentationString(indentation: number, options: EditorSettings): string;
            interface FormatContext {
                readonly options: FormatCodeSettings;
                readonly getRules: RulesMap;
                readonly host: FormattingHost;
            }
            interface TextRangeWithKind<T extends SyntaxKind = SyntaxKind> extends TextRange {
                kind: T;
            }
            type TextRangeWithTriviaKind = TextRangeWithKind<TriviaSyntaxKind>;
            interface TokenInfo {
                leadingTrivia: TextRangeWithTriviaKind[] | undefined;
                token: TextRangeWithKind;
                trailingTrivia: TextRangeWithTriviaKind[] | undefined;
            }
            namespace SmartIndenter {
                function getIndentation(position: number, sourceFile: SourceFile, options: EditorSettings, assumeNewLineBeforeCloseBrace?: boolean): number;
                function getIndentationForNode(n: Node, ignoreActualIndentationRange: TextRange, sourceFile: SourceFile, options: EditorSettings): number;
                function getBaseIndentation(options: EditorSettings): number;
                function isArgumentAndStartLineOverlapsExpressionBeingCalled(parent: Node, child: Node, childStartLine: number, sourceFile: SourceFileLike): boolean;
                function childStartsOnTheSameLineWithElseInIfStatement(parent: Node, child: TextRangeWithKind, childStartLine: number, sourceFile: SourceFileLike): boolean;
                function childIsUnindentedBranchOfConditionalExpression(parent: Node, child: TextRangeWithKind, childStartLine: number, sourceFile: SourceFileLike): boolean;
                function argumentStartsOnSameLineAsPreviousArgument(parent: Node, child: TextRangeWithKind, childStartLine: number, sourceFile: SourceFileLike): boolean;
                function getContainingList(node: Node, sourceFile: SourceFile): NodeArray<Node> | undefined;
                function findFirstNonWhitespaceCharacterAndColumn(startPos: number, endPos: number, sourceFile: SourceFileLike, options: EditorSettings): {
                    column: number;
                    character: number;
                };
                function findFirstNonWhitespaceColumn(startPos: number, endPos: number, sourceFile: SourceFileLike, options: EditorSettings): number;
                function nodeWillIndentChild(settings: FormatCodeSettings, parent: TextRangeWithKind, child: TextRangeWithKind | undefined, sourceFile: SourceFileLike | undefined, indentByDefault: boolean): boolean;
                function shouldIndentChildNode(settings: FormatCodeSettings, parent: TextRangeWithKind, child?: Node, sourceFile?: SourceFileLike, isNextChild?: boolean): boolean;
            }
        }
        namespace PreparePasteEdits {
            function preparePasteEdits(sourceFile: SourceFile, copiedFromRange: TextRange[], checker: TypeChecker): boolean;
        }
        namespace pasteEdits {
            function pasteEditsProvider(targetFile: SourceFile, pastedText: string[], pasteLocations: TextRange[], copiedFrom: {
                file: SourceFile;
                range: TextRange[];
            } | undefined, host: LanguageServiceHost, preferences: UserPreferences, formatContext: formatting.FormatContext, cancellationToken: CancellationToken): PasteEdits;
        }
        const versionMajorMinor = "5.9";
        const version: string;
        interface MapLike<T> {
            [index: string]: T;
        }
        interface SortedReadonlyArray<T> extends ReadonlyArray<T> {
            " __sortedArrayBrand": any;
        }
        interface SortedArray<T> extends Array<T> {
            " __sortedArrayBrand": any;
        }
        interface ReadonlyCollection<K> {
            readonly size: number;
            has(key: K): boolean;
            keys(): IterableIterator<K>;
        }
        type EqualityComparer<T> = (a: T, b: T) => boolean;
        type Comparer<T> = (a: T, b: T) => Comparison;
        enum Comparison {
            LessThan = -1,
            EqualTo = 0,
            GreaterThan = 1
        }
        function length(array: readonly any[] | undefined): number;
        function forEach<T, U>(array: readonly T[] | undefined, callback: (element: T, index: number) => U | undefined): U | undefined;
        function forEachRight<T, U>(array: readonly T[] | undefined, callback: (element: T, index: number) => U | undefined): U | undefined;
        function firstDefined<T, U>(array: readonly T[] | undefined, callback: (element: T, index: number) => U | undefined): U | undefined;
        function firstDefinedIterator<T, U>(iter: Iterable<T>, callback: (element: T) => U | undefined): U | undefined;
        function reduceLeftIterator<T, U>(iterator: Iterable<T> | undefined, f: (memo: U, value: T, i: number) => U, initial: U): U;
        function zipWith<T, U, V>(arrayA: readonly T[], arrayB: readonly U[], callback: (a: T, b: U, index: number) => V): V[];
        function intersperse<T>(input: T[], element: T): T[];
        function every<T, U extends T>(array: readonly T[], callback: (element: T, index: number) => element is U): array is readonly U[];
        function every<T, U extends T>(array: readonly T[] | undefined, callback: (element: T, index: number) => element is U): array is readonly U[] | undefined;
        function every<T>(array: readonly T[] | undefined, callback: (element: T, index: number) => boolean): boolean;
        function find<T, U extends T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => element is U, startIndex?: number): U | undefined;
        function find<T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => boolean, startIndex?: number): T | undefined;
        function findLast<T, U extends T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => element is U, startIndex?: number): U | undefined;
        function findLast<T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => boolean, startIndex?: number): T | undefined;
        function findIndex<T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => boolean, startIndex?: number): number;
        function findLastIndex<T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => boolean, startIndex?: number): number;
        function contains<T>(array: readonly T[] | undefined, value: T, equalityComparer?: EqualityComparer<T>): boolean;
        function indexOfAnyCharCode(text: string, charCodes: readonly number[], start?: number): number;
        function countWhere<T>(array: readonly T[] | undefined, predicate: (x: T, i: number) => boolean): number;
        function filter<T, U extends T>(array: T[], f: (x: T) => x is U): U[];
        function filter<T>(array: T[], f: (x: T) => boolean): T[];
        function filter<T, U extends T>(array: readonly T[], f: (x: T) => x is U): readonly U[];
        function filter<T>(array: readonly T[], f: (x: T) => boolean): readonly T[];
        function filter<T, U extends T>(array: T[] | undefined, f: (x: T) => x is U): U[] | undefined;
        function filter<T>(array: T[] | undefined, f: (x: T) => boolean): T[] | undefined;
        function filter<T, U extends T>(array: readonly T[] | undefined, f: (x: T) => x is U): readonly U[] | undefined;
        function filter<T>(array: readonly T[] | undefined, f: (x: T) => boolean): readonly T[] | undefined;
        function filterMutate<T>(array: T[], f: (x: T, i: number, array: T[]) => boolean): void;
        function clear(array: unknown[]): void;
        function map<T, U>(array: readonly T[], f: (x: T, i: number) => U): U[];
        function map<T, U>(array: readonly T[] | undefined, f: (x: T, i: number) => U): U[] | undefined;
        function mapIterator<T, U>(iter: Iterable<T>, mapFn: (x: T) => U): Generator<U, void, unknown>;
        function sameMap<T, U = T>(array: T[], f: (x: T, i: number) => U): U[];
        function sameMap<T, U = T>(array: readonly T[], f: (x: T, i: number) => U): readonly U[];
        function sameMap<T, U = T>(array: T[] | undefined, f: (x: T, i: number) => U): U[] | undefined;
        function sameMap<T, U = T>(array: readonly T[] | undefined, f: (x: T, i: number) => U): readonly U[] | undefined;
        function flatten<T>(array: T[][] | readonly (T | readonly T[] | undefined)[]): T[];
        function flatMap<T, U extends {}>(array: readonly T[] | undefined, mapfn: (x: T, i: number) => U | readonly U[] | undefined): readonly U[];
        function flatMapToMutable<T, U>(array: readonly T[] | undefined, mapfn: (x: T, i: number) => U | readonly U[] | undefined): U[];
        function flatMapIterator<T, U>(iter: Iterable<T>, mapfn: (x: T) => readonly U[] | Iterable<U> | undefined): Generator<U, void, any>;
        function sameFlatMap<T>(array: T[], mapfn: (x: T, i: number) => T | readonly T[]): T[];
        function sameFlatMap<T>(array: readonly T[], mapfn: (x: T, i: number) => T | readonly T[]): readonly T[];
        function mapAllOrFail<T, U>(array: readonly T[], mapFn: (x: T, i: number) => U | undefined): U[] | undefined;
        function mapDefined<T, U>(array: readonly T[] | undefined, mapFn: (x: T, i: number) => U | undefined): U[];
        function mapDefinedIterator<T, U>(iter: Iterable<T>, mapFn: (x: T) => U | undefined): Generator<U & ({} | null), void, unknown>;
        function getOrUpdate<K, V>(map: Map<K, V>, key: K, callback: () => V): V;
        function tryAddToSet<T>(set: Set<T>, value: T): boolean;
        function singleIterator<T>(value: T): Generator<T, void, unknown>;
        function spanMap<T, K, U>(array: readonly T[], keyfn: (x: T, i: number) => K, mapfn: (chunk: T[], key: K, start: number, end: number) => U): U[];
        function spanMap<T, K, U>(array: readonly T[] | undefined, keyfn: (x: T, i: number) => K, mapfn: (chunk: T[], key: K, start: number, end: number) => U): U[] | undefined;
        function mapEntries<K1, V1, K2, V2>(map: ReadonlyMap<K1, V1>, f: (key: K1, value: V1) => readonly [
            K2,
            V2
        ]): Map<K2, V2>;
        function mapEntries<K1, V1, K2, V2>(map: ReadonlyMap<K1, V1> | undefined, f: (key: K1, value: V1) => readonly [
            K2,
            V2
        ]): Map<K2, V2> | undefined;
        function some<T>(array: readonly T[] | undefined): array is readonly T[];
        function some<T>(array: readonly T[] | undefined, predicate: (value: T) => boolean): boolean;
        function getRangesWhere<T>(arr: readonly T[], pred: (t: T) => boolean, cb: (start: number, afterEnd: number) => void): void;
        function concatenate<T>(array1: T[], array2: T[]): T[];
        function concatenate<T>(array1: readonly T[], array2: readonly T[]): readonly T[];
        function concatenate<T>(array1: T[], array2: T[] | undefined): T[];
        function concatenate<T>(array1: T[] | undefined, array2: T[]): T[];
        function concatenate<T>(array1: readonly T[], array2: readonly T[] | undefined): readonly T[];
        function concatenate<T>(array1: readonly T[] | undefined, array2: readonly T[]): readonly T[];
        function concatenate<T>(array1: T[] | undefined, array2: T[] | undefined): T[] | undefined;
        function concatenate<T>(array1: readonly T[] | undefined, array2: readonly T[] | undefined): readonly T[] | undefined;
        function indicesOf(array: readonly unknown[]): number[];
        function deduplicate<T>(array: readonly T[], equalityComparer: EqualityComparer<T>, comparer?: Comparer<T>): T[];
        function createSortedArray<T>(): SortedArray<T>;
        function insertSorted<T>(array: SortedArray<T>, insert: T, compare: Comparer<T>, equalityComparer?: EqualityComparer<T>, allowDuplicates?: boolean): boolean;
        function sortAndDeduplicate(array: readonly string[]): SortedReadonlyArray<string>;
        function sortAndDeduplicate<T>(array: readonly T[], comparer: Comparer<T>, equalityComparer?: EqualityComparer<T>): SortedReadonlyArray<T>;
        function arrayIsEqualTo<T>(array1: readonly T[] | undefined, array2: readonly T[] | undefined, equalityComparer?: (a: T, b: T, index: number) => boolean): boolean;
        function compact<T>(array: (T | undefined | null | false | 0 | "")[]): T[];
        function compact<T>(array: readonly (T | undefined | null | false | 0 | "")[]): readonly T[];
        function compact<T>(array: T[]): T[];
        function compact<T>(array: readonly T[]): readonly T[];
        function relativeComplement<T>(arrayA: T[] | undefined, arrayB: T[] | undefined, comparer: Comparer<T>): T[] | undefined;
        function append<T extends {}>(to: T[], value: T | undefined): T[];
        function append<T extends {}>(to: T[] | undefined, value: T): T[];
        function append<T extends {}>(to: T[] | undefined, value: T | undefined): T[] | undefined;
        function combine<T extends {}>(xs: T[] | undefined, ys: T[] | undefined): T[] | undefined;
        function combine<T extends {}>(xs: T | readonly T[] | undefined, ys: T | readonly T[] | undefined): T | readonly T[] | undefined;
        function combine<T extends {}>(xs: T | T[] | undefined, ys: T | T[] | undefined): T | T[] | undefined;
        function addRange<T>(to: T[], from: readonly T[] | undefined, start?: number, end?: number): T[];
        function addRange<T>(to: T[] | undefined, from: readonly T[] | undefined, start?: number, end?: number): T[] | undefined;
        function pushIfUnique<T>(array: T[], toAdd: T, equalityComparer?: EqualityComparer<T>): boolean;
        function appendIfUnique<T>(array: T[] | undefined, toAdd: T, equalityComparer?: EqualityComparer<T>): T[];
        function toSorted<T>(array: readonly T[], comparer?: Comparer<T>): SortedReadonlyArray<T>;
        function arrayReverseIterator<T>(array: readonly T[]): Generator<T, void, unknown>;
        function rangeEquals<T>(array1: readonly T[], array2: readonly T[], pos: number, end: number): boolean;
        function firstOrUndefined<T>(array: readonly T[] | undefined): T | undefined;
        function firstOrUndefinedIterator<T>(iter: Iterable<T> | undefined): T | undefined;
        function first<T>(array: readonly T[]): T;
        function firstIterator<T>(iter: Iterable<T>): T;
        function lastOrUndefined<T>(array: readonly T[] | undefined): T | undefined;
        function last<T>(array: readonly T[]): T;
        function singleOrUndefined<T>(array: readonly T[] | undefined): T | undefined;
        function single<T>(array: readonly T[]): T;
        function singleOrMany<T>(array: T[]): T | T[];
        function singleOrMany<T>(array: readonly T[]): T | readonly T[];
        function singleOrMany<T>(array: T[] | undefined): T | T[] | undefined;
        function singleOrMany<T>(array: readonly T[] | undefined): T | readonly T[] | undefined;
        function replaceElement<T>(array: readonly T[], index: number, value: T): T[];
        function binarySearch<T, U>(array: readonly T[], value: T, keySelector: (v: T) => U, keyComparer: Comparer<U>, offset?: number): number;
        function binarySearchKey<T, U>(array: readonly T[], key: U, keySelector: (v: T, i: number) => U, keyComparer: Comparer<U>, offset?: number): number;
        function reduceLeft<T, U>(array: readonly T[] | undefined, f: (memo: U, value: T, i: number) => U, initial: U, start?: number, count?: number): U;
        function reduceLeft<T>(array: readonly T[], f: (memo: T, value: T, i: number) => T): T | undefined;
        function hasProperty(map: MapLike<any>, key: string): boolean;
        function getProperty<T>(map: MapLike<T>, key: string): T | undefined;
        function getOwnKeys<T>(map: MapLike<T>): string[];
        function getAllKeys(obj: object): string[];
        function getOwnValues<T>(collection: MapLike<T> | T[]): T[];
        function arrayOf<T>(count: number, f: (index: number) => T): T[];
        function arrayFrom<T, U>(iterator: Iterable<T>, map: (t: T) => U): U[];
        function arrayFrom<T>(iterator: Iterable<T>): T[];
        function assign<T extends object>(t: T, ...args: (T | undefined)[]): T;
        function equalOwnProperties<T>(left: MapLike<T> | undefined, right: MapLike<T> | undefined, equalityComparer?: EqualityComparer<T>): boolean;
        function arrayToMap<K, V>(array: readonly V[], makeKey: (value: V) => K | undefined): Map<K, V>;
        function arrayToMap<K, V1, V2>(array: readonly V1[], makeKey: (value: V1) => K | undefined, makeValue: (value: V1) => V2): Map<K, V2>;
        function arrayToMap<T>(array: readonly T[], makeKey: (value: T) => string | undefined): Map<string, T>;
        function arrayToMap<T, U>(array: readonly T[], makeKey: (value: T) => string | undefined, makeValue: (value: T) => U): Map<string, U>;
        function arrayToNumericMap<T>(array: readonly T[], makeKey: (value: T) => number): T[];
        function arrayToNumericMap<T, U>(array: readonly T[], makeKey: (value: T) => number, makeValue: (value: T) => U): U[];
        function arrayToMultiMap<K, V>(values: readonly V[], makeKey: (value: V) => K): MultiMap<K, V>;
        function arrayToMultiMap<K, V, U>(values: readonly V[], makeKey: (value: V) => K, makeValue: (value: V) => U): MultiMap<K, U>;
        function group<T, K>(values: readonly T[], getGroupId: (value: T) => K): readonly (readonly T[])[];
        function group<T, K, R>(values: readonly T[], getGroupId: (value: T) => K, resultSelector: (values: readonly T[]) => R): R[];
        function group<T>(values: readonly T[], getGroupId: (value: T) => string): readonly (readonly T[])[];
        function group<T, R>(values: readonly T[], getGroupId: (value: T) => string, resultSelector: (values: readonly T[]) => R): R[];
        function groupBy<T, U extends T>(values: readonly T[] | undefined, keySelector: (value: T) => value is U): {
            true?: U[];
            false?: Exclude<T, U>[];
        };
        function groupBy<T, K extends string | number | boolean | null | undefined>(values: readonly T[] | undefined, keySelector: (value: T) => K): {
            [P in K as `${P}`]?: T[];
        };
        function clone<T>(object: T): T;
        function extend<T1, T2>(first: T1, second: T2): T1 & T2;
        function copyProperties<T1 extends T2, T2>(first: T1, second: T2): void;
        function maybeBind<T, A extends any[], R>(obj: T, fn: ((this: T, ...args: A) => R) | undefined): ((...args: A) => R) | undefined;
        function createMultiMap<K, V>(): MultiMap<K, V>;
        function createQueue<T>(items?: readonly T[]): Queue<T>;
        function createSet<TElement, THash = number>(getHashCode: (element: TElement) => THash, equals: EqualityComparer<TElement>): Set<TElement>;
        function isArray(value: any): value is readonly unknown[];
        function toArray<T>(value: T | T[]): T[];
        function toArray<T>(value: T | readonly T[]): readonly T[];
        function isString(text: unknown): text is string;
        function isNumber(x: unknown): x is number;
        function tryCast<TOut extends TIn, TIn = any>(value: TIn | undefined, test: (value: TIn) => value is TOut): TOut | undefined;
        function cast<TOut extends TIn, TIn = any>(value: TIn | undefined, test: (value: TIn) => value is TOut): TOut;
        function noop(_?: unknown): void;
        function returnFalse(): false;
        function returnTrue(): true;
        function returnUndefined(): undefined;
        function identity<T>(x: T): T;
        function toFileNameLowerCase(x: string): string;
        function notImplemented(): never;
        function memoize<T>(callback: () => T): () => T;
        function memoizeOne<A extends string | number | boolean | undefined, T>(callback: (arg: A) => T): (arg: A) => T;
        function equateValues<T>(a: T, b: T): boolean;
        function equateStringsCaseInsensitive(a: string, b: string): boolean;
        function equateStringsCaseSensitive(a: string, b: string): boolean;
        function compareValues(a: number | undefined, b: number | undefined): Comparison;
        function compareTextSpans(a: Partial<TextSpan> | undefined, b: Partial<TextSpan> | undefined): Comparison;
        function maxBy<T>(arr: readonly T[], init: number, mapper: (x: T) => number): number;
        function min<T>(items: readonly [
            T,
            ...T[]
        ], compare: Comparer<T>): T;
        function min<T>(items: readonly T[], compare: Comparer<T>): T | undefined;
        function compareStringsCaseInsensitive(a: string, b: string): Comparison;
        function compareStringsCaseInsensitiveEslintCompatible(a: string, b: string): Comparison;
        function compareStringsCaseSensitive(a: string | undefined, b: string | undefined): Comparison;
        function getStringComparer(ignoreCase?: boolean): typeof compareStringsCaseInsensitive;
        function getUILocale(): string | undefined;
        function setUILocale(value: string | undefined): void;
        function compareStringsCaseSensitiveUI(a: string, b: string): Comparison;
        function compareProperties<T extends object, K extends keyof T>(a: T | undefined, b: T | undefined, key: K, comparer: Comparer<T[K]>): Comparison;
        function compareBooleans(a: boolean, b: boolean): Comparison;
        function getSpellingSuggestion<T>(name: string, candidates: Iterable<T>, getName: (candidate: T) => string | undefined): T | undefined;
        function endsWith(str: string, suffix: string, ignoreCase?: boolean): boolean;
        function removeSuffix(str: string, suffix: string): string;
        function tryRemoveSuffix(str: string, suffix: string): string | undefined;
        function removeMinAndVersionNumbers(fileName: string): string;
        function orderedRemoveItem<T>(array: T[], item: T): boolean;
        function orderedRemoveItemAt<T>(array: T[], index: number): void;
        function unorderedRemoveItem<T>(array: T[], item: T): boolean;
        function createGetCanonicalFileName(useCaseSensitiveFileNames: boolean): GetCanonicalFileName;
        function patternText({ prefix, suffix }: Pattern): string;
        function matchedText(pattern: Pattern, candidate: string): string;
        function findBestPatternMatch<T>(values: readonly T[], getPattern: (value: T) => Pattern, candidate: string): T | undefined;
        function startsWith(str: string, prefix: string, ignoreCase?: boolean): boolean;
        function removePrefix(str: string, prefix: string): string;
        function tryRemovePrefix(str: string, prefix: string, getCanonicalFileName?: GetCanonicalFileName): string | undefined;
        function isPatternMatch({ prefix, suffix }: Pattern, candidate: string): boolean;
        function and<T>(f: (arg: T) => boolean, g: (arg: T) => boolean): (arg: T) => boolean;
        function or<P, R1 extends P, R2 extends P>(f1: (p1: P) => p1 is R1, f2: (p2: P) => p2 is R2): (p: P) => p is R1 | R2;
        function or<P, R1 extends P, R2 extends P, R3 extends P>(f1: (p1: P) => p1 is R1, f2: (p2: P) => p2 is R2, f3: (p3: P) => p3 is R3): (p: P) => p is R1 | R2 | R3;
        function or<T extends unknown[], U>(...fs: ((...args: T) => U)[]): (...args: T) => U;
        function not<T extends unknown[]>(fn: (...args: T) => boolean): (...args: T) => boolean;
        function assertType<T>(_: T): void;
        function singleElementArray<T>(t: T | undefined): T[] | undefined;
        function enumerateInsertsAndDeletes<T, U>(newItems: readonly T[], oldItems: readonly U[], comparer: (a: T, b: U) => Comparison, inserted: (newItem: T) => void, deleted: (oldItem: U) => void, unchanged?: (oldItem: U, newItem: T) => void): boolean;
        function cartesianProduct<T>(arrays: readonly T[][]): T[][];
        function takeWhile<T, U extends T>(array: readonly T[], predicate: (element: T) => element is U): U[];
        function takeWhile<T, U extends T>(array: readonly T[] | undefined, predicate: (element: T) => element is U): U[] | undefined;
        function skipWhile<T, U extends T>(array: readonly T[], predicate: (element: T) => element is U): Exclude<T, U>[];
        function skipWhile<T, U extends T>(array: readonly T[] | undefined, predicate: (element: T) => element is U): Exclude<T, U>[] | undefined;
        function isNodeLikeSystem(): boolean;
        const emptyArray: never[];
        const emptyMap: ReadonlyMap<never, never>;
        const elementAt: <T>(array: readonly T[] | undefined, offset: number) => T | undefined;
        interface MultiMap<K, V> extends Map<K, V[]> {
            add(key: K, value: V): V[];
            remove(key: K, value: V): void;
        }
        enum AssertionLevel {
            None = 0,
            Normal = 1,
            Aggressive = 2,
            VeryAggressive = 3
        }
        type AnyFunction = (...args: never[]) => void;
        type GetCanonicalFileName = (fileName: string) => string;
        interface Pattern {
            prefix: string;
            suffix: string;
        }
        enum LogLevel {
            Off = 0,
            Error = 1,
            Warning = 2,
            Info = 3,
            Verbose = 4
        }
        interface LoggingHost {
            log(level: LogLevel, s: string): void;
        }
        namespace Debug {
            let currentLogLevel: LogLevel;
            let isDebugging: boolean;
            let loggingHost: LoggingHost | undefined;
            function shouldLog(level: LogLevel): boolean;
            function log(s: string): void;
            namespace log {
                function error(s: string): void;
                function warn(s: string): void;
                function log(s: string): void;
                function trace(s: string): void;
            }
            function getAssertionLevel(): AssertionLevel;
            function setAssertionLevel(level: AssertionLevel): void;
            function shouldAssert(level: AssertionLevel): boolean;
            function fail(message?: string, stackCrawlMark?: AnyFunction): never;
            function failBadSyntaxKind(node: Node, message?: string, stackCrawlMark?: AnyFunction): never;
            function assert(expression: unknown, message?: string, verboseDebugInfo?: string | (() => string), stackCrawlMark?: AnyFunction): asserts expression;
            function assertEqual<T>(a: T, b: T, msg?: string, msg2?: string, stackCrawlMark?: AnyFunction): void;
            function assertLessThan(a: number, b: number, msg?: string, stackCrawlMark?: AnyFunction): void;
            function assertLessThanOrEqual(a: number, b: number, stackCrawlMark?: AnyFunction): void;
            function assertGreaterThanOrEqual(a: number, b: number, stackCrawlMark?: AnyFunction): void;
            function assertIsDefined<T>(value: T, message?: string, stackCrawlMark?: AnyFunction): asserts value is NonNullable<T>;
            function checkDefined<T>(value: T | null | undefined, message?: string, stackCrawlMark?: AnyFunction): T;
            function assertEachIsDefined<T extends Node>(value: NodeArray<T>, message?: string, stackCrawlMark?: AnyFunction): asserts value is NodeArray<T>;
            function assertEachIsDefined<T>(value: readonly T[], message?: string, stackCrawlMark?: AnyFunction): asserts value is readonly NonNullable<T>[];
            function checkEachDefined<T, A extends readonly T[]>(value: A, message?: string, stackCrawlMark?: AnyFunction): A;
            function assertNever(member: never, message?: string, stackCrawlMark?: AnyFunction): never;
            function assertEachNode<T extends Node, U extends T>(nodes: NodeArray<T>, test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts nodes is NodeArray<U>;
            function assertEachNode<T extends Node, U extends T>(nodes: readonly T[], test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts nodes is readonly U[];
            function assertEachNode<T extends Node, U extends T>(nodes: NodeArray<T> | undefined, test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts nodes is NodeArray<U> | undefined;
            function assertEachNode<T extends Node, U extends T>(nodes: readonly T[] | undefined, test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts nodes is readonly U[] | undefined;
            function assertEachNode(nodes: readonly Node[], test: ((node: Node) => boolean) | undefined, message?: string, stackCrawlMark?: AnyFunction): void;
            function assertNode<T extends Node, U extends T>(node: T | undefined, test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts node is U;
            function assertNode(node: Node | undefined, test: ((node: Node) => boolean) | undefined, message?: string, stackCrawlMark?: AnyFunction): void;
            function assertNotNode<T extends Node, U extends T>(node: T | undefined, test: (node: Node) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts node is Exclude<T, U>;
            function assertNotNode(node: Node | undefined, test: ((node: Node) => boolean) | undefined, message?: string, stackCrawlMark?: AnyFunction): void;
            function assertOptionalNode<T extends Node, U extends T>(node: T, test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts node is U;
            function assertOptionalNode<T extends Node, U extends T>(node: T | undefined, test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts node is U | undefined;
            function assertOptionalNode(node: Node | undefined, test: ((node: Node) => boolean) | undefined, message?: string, stackCrawlMark?: AnyFunction): void;
            function assertOptionalToken<T extends Node, K extends SyntaxKind>(node: T, kind: K, message?: string, stackCrawlMark?: AnyFunction): asserts node is Extract<T, {
                readonly kind: K;
            }>;
            function assertOptionalToken<T extends Node, K extends SyntaxKind>(node: T | undefined, kind: K, message?: string, stackCrawlMark?: AnyFunction): asserts node is Extract<T, {
                readonly kind: K;
            }> | undefined;
            function assertOptionalToken(node: Node | undefined, kind: SyntaxKind | undefined, message?: string, stackCrawlMark?: AnyFunction): void;
            function assertMissingNode(node: Node | undefined, message?: string, stackCrawlMark?: AnyFunction): asserts node is undefined;
            function type<T>(value: unknown): asserts value is T;
            function getFunctionName(func: AnyFunction): string;
            function formatSymbol(symbol: Symbol): string;
            function formatEnum(value: number | undefined, enumObject: any, isFlags?: boolean): string;
            function formatSyntaxKind(kind: SyntaxKind | undefined): string;
            function formatSnippetKind(kind: SnippetKind | undefined): string;
            function formatScriptKind(kind: ScriptKind | undefined): string;
            function formatNodeFlags(flags: NodeFlags | undefined): string;
            function formatNodeCheckFlags(flags: NodeCheckFlags | undefined): string;
            function formatModifierFlags(flags: ModifierFlags | undefined): string;
            function formatTransformFlags(flags: TransformFlags | undefined): string;
            function formatEmitFlags(flags: EmitFlags | undefined): string;
            function formatSymbolFlags(flags: SymbolFlags | undefined): string;
            function formatTypeFlags(flags: TypeFlags | undefined): string;
            function formatSignatureFlags(flags: SignatureFlags | undefined): string;
            function formatObjectFlags(flags: ObjectFlags | undefined): string;
            function formatFlowFlags(flags: FlowFlags | undefined): string;
            function formatRelationComparisonResult(result: RelationComparisonResult | undefined): string;
            function formatCheckMode(mode: CheckMode | undefined): string;
            function formatSignatureCheckMode(mode: SignatureCheckMode | undefined): string;
            function formatTypeFacts(facts: TypeFacts | undefined): string;
            function attachFlowNodeDebugInfo(flowNode: FlowNode): FlowNode;
            function attachNodeArrayDebugInfo(array: NodeArray<Node>): void;
            function enableDebugInfo(): void;
            function formatVariance(varianceFlags: VarianceFlags): string;
            type DebugType = Type & {
                __debugTypeToString(): string;
            };
            class DebugTypeMapper {
                kind: TypeMapKind;
                __debugToString(): string;
            }
            function attachDebugPrototypeIfDebug(mapper: TypeMapper): TypeMapper;
            function printControlFlowGraph(flowNode: FlowNode): void;
            function formatControlFlowGraph(flowNode: FlowNode): string;
        }
        class Version {
            static readonly zero: Version;
            readonly major: number;
            readonly minor: number;
            readonly patch: number;
            readonly prerelease: readonly string[];
            readonly build: readonly string[];
            constructor(text: string);
            constructor(major: number, minor?: number, patch?: number, prerelease?: string | readonly string[], build?: string | readonly string[]);
            static tryParse(text: string): Version | undefined;
            compareTo(other: Version | undefined): Comparison;
            increment(field: "major" | "minor" | "patch"): Version;
            with(fields: {
                major?: number;
                minor?: number;
                patch?: number;
                prerelease?: string | readonly string[];
                build?: string | readonly string[];
            }): Version;
            toString(): string;
        }
        class VersionRange {
            private _alternatives;
            constructor(spec: string);
            static tryParse(text: string): VersionRange | undefined;
            test(version: Version | string): boolean;
            toString(): string;
        }
        function tryGetNativePerformanceHooks(): PerformanceHooks | undefined;
        interface PerformanceHooks {
            shouldWriteNativeEvents: boolean;
            performance?: Performance;
            performanceTime?: PerformanceTime;
        }
        interface PerformanceTime {
            now(): number;
            timeOrigin: number;
        }
        interface Performance extends PerformanceTime {
            mark(name: string): void;
            measure(name: string, startMark?: string, endMark?: string): void;
            clearMeasures(name?: string): void;
            clearMarks(name?: string): void;
        }
        const timestamp: () => number;
        let tracing: typeof tracingEnabled | undefined;
        namespace tracingEnabled {
            type Mode = "project" | "build" | "server";
            interface Args {
                [key: string]: string | number | boolean | null | undefined | Args | readonly (string | number | boolean | null | undefined | Args)[];
            }
            export function startTracing(tracingMode: Mode, traceDir: string, configFilePath?: string): void;
            export function stopTracing(): void;
            export function recordType(type: Type): void;
            export const enum Phase {
                Parse = "parse",
                Program = "program",
                Bind = "bind",
                Check = "check",
                CheckTypes = "checkTypes",
                Emit = "emit",
                Session = "session"
            }
            export function instant(phase: Phase, name: string, args?: Args): void;
            export function push(phase: Phase, name: string, args?: Args, separateBeginAndEnd?: boolean): void;
            export function pop(results?: Args): void;
            export function popAll(): void;
            export function dumpLegend(): void;
            export {};
        }
        const startTracing: typeof tracingEnabled.startTracing;
        const dumpTracingLegend: typeof tracingEnabled.dumpLegend;
        interface TracingNode {
            tracingPath?: Path;
        }
        function diagnosticCategoryName(d: {
            category: DiagnosticCategory;
        }, lowerCase?: boolean): string;
        type Path = string & {
            __pathBrand: any;
        };
        type MatchingKeys<TRecord, TMatch, K extends keyof TRecord = keyof TRecord> = K extends (TRecord[K] extends TMatch ? K : never) ? K : never;
        interface TextRange {
            pos: number;
            end: number;
        }
        interface ReadonlyTextRange {
            readonly pos: number;
            readonly end: number;
        }
        enum SyntaxKind {
            Unknown = 0,
            EndOfFileToken = 1,
            SingleLineCommentTrivia = 2,
            MultiLineCommentTrivia = 3,
            NewLineTrivia = 4,
            WhitespaceTrivia = 5,
            ShebangTrivia = 6,
            ConflictMarkerTrivia = 7,
            NonTextFileMarkerTrivia = 8,
            NumericLiteral = 9,
            BigIntLiteral = 10,
            StringLiteral = 11,
            JsxText = 12,
            JsxTextAllWhiteSpaces = 13,
            RegularExpressionLiteral = 14,
            NoSubstitutionTemplateLiteral = 15,
            TemplateHead = 16,
            TemplateMiddle = 17,
            TemplateTail = 18,
            OpenBraceToken = 19,
            CloseBraceToken = 20,
            OpenParenToken = 21,
            CloseParenToken = 22,
            OpenBracketToken = 23,
            CloseBracketToken = 24,
            DotToken = 25,
            DotDotDotToken = 26,
            SemicolonToken = 27,
            CommaToken = 28,
            QuestionDotToken = 29,
            LessThanToken = 30,
            LessThanSlashToken = 31,
            GreaterThanToken = 32,
            LessThanEqualsToken = 33,
            GreaterThanEqualsToken = 34,
            EqualsEqualsToken = 35,
            ExclamationEqualsToken = 36,
            EqualsEqualsEqualsToken = 37,
            ExclamationEqualsEqualsToken = 38,
            EqualsGreaterThanToken = 39,
            PlusToken = 40,
            MinusToken = 41,
            AsteriskToken = 42,
            AsteriskAsteriskToken = 43,
            SlashToken = 44,
            PercentToken = 45,
            PlusPlusToken = 46,
            MinusMinusToken = 47,
            LessThanLessThanToken = 48,
            GreaterThanGreaterThanToken = 49,
            GreaterThanGreaterThanGreaterThanToken = 50,
            AmpersandToken = 51,
            BarToken = 52,
            CaretToken = 53,
            ExclamationToken = 54,
            TildeToken = 55,
            AmpersandAmpersandToken = 56,
            BarBarToken = 57,
            QuestionToken = 58,
            ColonToken = 59,
            AtToken = 60,
            QuestionQuestionToken = 61,
            BacktickToken = 62,
            HashToken = 63,
            EqualsToken = 64,
            PlusEqualsToken = 65,
            MinusEqualsToken = 66,
            AsteriskEqualsToken = 67,
            AsteriskAsteriskEqualsToken = 68,
            SlashEqualsToken = 69,
            PercentEqualsToken = 70,
            LessThanLessThanEqualsToken = 71,
            GreaterThanGreaterThanEqualsToken = 72,
            GreaterThanGreaterThanGreaterThanEqualsToken = 73,
            AmpersandEqualsToken = 74,
            BarEqualsToken = 75,
            BarBarEqualsToken = 76,
            AmpersandAmpersandEqualsToken = 77,
            QuestionQuestionEqualsToken = 78,
            CaretEqualsToken = 79,
            Identifier = 80,
            PrivateIdentifier = 81,
            JSDocCommentTextToken = 82,
            BreakKeyword = 83,
            CaseKeyword = 84,
            CatchKeyword = 85,
            ClassKeyword = 86,
            ConstKeyword = 87,
            ContinueKeyword = 88,
            DebuggerKeyword = 89,
            DefaultKeyword = 90,
            DeleteKeyword = 91,
            DoKeyword = 92,
            ElseKeyword = 93,
            EnumKeyword = 94,
            ExportKeyword = 95,
            ExtendsKeyword = 96,
            FalseKeyword = 97,
            FinallyKeyword = 98,
            ForKeyword = 99,
            FunctionKeyword = 100,
            IfKeyword = 101,
            ImportKeyword = 102,
            InKeyword = 103,
            InstanceOfKeyword = 104,
            NewKeyword = 105,
            NullKeyword = 106,
            ReturnKeyword = 107,
            SuperKeyword = 108,
            SwitchKeyword = 109,
            ThisKeyword = 110,
            ThrowKeyword = 111,
            TrueKeyword = 112,
            TryKeyword = 113,
            TypeOfKeyword = 114,
            VarKeyword = 115,
            VoidKeyword = 116,
            WhileKeyword = 117,
            WithKeyword = 118,
            ImplementsKeyword = 119,
            InterfaceKeyword = 120,
            LetKeyword = 121,
            PackageKeyword = 122,
            PrivateKeyword = 123,
            ProtectedKeyword = 124,
            PublicKeyword = 125,
            StaticKeyword = 126,
            YieldKeyword = 127,
            AbstractKeyword = 128,
            AccessorKeyword = 129,
            AsKeyword = 130,
            AssertsKeyword = 131,
            AssertKeyword = 132,
            AnyKeyword = 133,
            AsyncKeyword = 134,
            AwaitKeyword = 135,
            BooleanKeyword = 136,
            ConstructorKeyword = 137,
            DeclareKeyword = 138,
            GetKeyword = 139,
            InferKeyword = 140,
            IntrinsicKeyword = 141,
            IsKeyword = 142,
            KeyOfKeyword = 143,
            ModuleKeyword = 144,
            NamespaceKeyword = 145,
            NeverKeyword = 146,
            OutKeyword = 147,
            ReadonlyKeyword = 148,
            RequireKeyword = 149,
            NumberKeyword = 150,
            ObjectKeyword = 151,
            SatisfiesKeyword = 152,
            SetKeyword = 153,
            StringKeyword = 154,
            SymbolKeyword = 155,
            TypeKeyword = 156,
            UndefinedKeyword = 157,
            UniqueKeyword = 158,
            UnknownKeyword = 159,
            UsingKeyword = 160,
            FromKeyword = 161,
            GlobalKeyword = 162,
            BigIntKeyword = 163,
            OverrideKeyword = 164,
            OfKeyword = 165,
            QualifiedName = 166,
            ComputedPropertyName = 167,
            TypeParameter = 168,
            Parameter = 169,
            Decorator = 170,
            PropertySignature = 171,
            PropertyDeclaration = 172,
            MethodSignature = 173,
            MethodDeclaration = 174,
            ClassStaticBlockDeclaration = 175,
            Constructor = 176,
            GetAccessor = 177,
            SetAccessor = 178,
            CallSignature = 179,
            ConstructSignature = 180,
            IndexSignature = 181,
            TypePredicate = 182,
            TypeReference = 183,
            FunctionType = 184,
            ConstructorType = 185,
            TypeQuery = 186,
            TypeLiteral = 187,
            ArrayType = 188,
            TupleType = 189,
            OptionalType = 190,
            RestType = 191,
            UnionType = 192,
            IntersectionType = 193,
            ConditionalType = 194,
            InferType = 195,
            ParenthesizedType = 196,
            ThisType = 197,
            TypeOperator = 198,
            IndexedAccessType = 199,
            MappedType = 200,
            LiteralType = 201,
            NamedTupleMember = 202,
            TemplateLiteralType = 203,
            TemplateLiteralTypeSpan = 204,
            ImportType = 205,
            ObjectBindingPattern = 206,
            ArrayBindingPattern = 207,
            BindingElement = 208,
            ArrayLiteralExpression = 209,
            ObjectLiteralExpression = 210,
            PropertyAccessExpression = 211,
            ElementAccessExpression = 212,
            CallExpression = 213,
            NewExpression = 214,
            TaggedTemplateExpression = 215,
            TypeAssertionExpression = 216,
            ParenthesizedExpression = 217,
            FunctionExpression = 218,
            ArrowFunction = 219,
            DeleteExpression = 220,
            TypeOfExpression = 221,
            VoidExpression = 222,
            AwaitExpression = 223,
            PrefixUnaryExpression = 224,
            PostfixUnaryExpression = 225,
            BinaryExpression = 226,
            ConditionalExpression = 227,
            TemplateExpression = 228,
            YieldExpression = 229,
            SpreadElement = 230,
            ClassExpression = 231,
            OmittedExpression = 232,
            ExpressionWithTypeArguments = 233,
            AsExpression = 234,
            NonNullExpression = 235,
            MetaProperty = 236,
            SyntheticExpression = 237,
            SatisfiesExpression = 238,
            TemplateSpan = 239,
            SemicolonClassElement = 240,
            Block = 241,
            EmptyStatement = 242,
            VariableStatement = 243,
            ExpressionStatement = 244,
            IfStatement = 245,
            DoStatement = 246,
            WhileStatement = 247,
            ForStatement = 248,
            ForInStatement = 249,
            ForOfStatement = 250,
            ContinueStatement = 251,
            BreakStatement = 252,
            ReturnStatement = 253,
            WithStatement = 254,
            SwitchStatement = 255,
            LabeledStatement = 256,
            ThrowStatement = 257,
            TryStatement = 258,
            DebuggerStatement = 259,
            VariableDeclaration = 260,
            VariableDeclarationList = 261,
            FunctionDeclaration = 262,
            ClassDeclaration = 263,
            InterfaceDeclaration = 264,
            TypeAliasDeclaration = 265,
            EnumDeclaration = 266,
            ModuleDeclaration = 267,
            ModuleBlock = 268,
            CaseBlock = 269,
            NamespaceExportDeclaration = 270,
            ImportEqualsDeclaration = 271,
            ImportDeclaration = 272,
            ImportClause = 273,
            NamespaceImport = 274,
            NamedImports = 275,
            ImportSpecifier = 276,
            ExportAssignment = 277,
            ExportDeclaration = 278,
            NamedExports = 279,
            NamespaceExport = 280,
            ExportSpecifier = 281,
            MissingDeclaration = 282,
            ExternalModuleReference = 283,
            JsxElement = 284,
            JsxSelfClosingElement = 285,
            JsxOpeningElement = 286,
            JsxClosingElement = 287,
            JsxFragment = 288,
            JsxOpeningFragment = 289,
            JsxClosingFragment = 290,
            JsxAttribute = 291,
            JsxAttributes = 292,
            JsxSpreadAttribute = 293,
            JsxExpression = 294,
            JsxNamespacedName = 295,
            CaseClause = 296,
            DefaultClause = 297,
            HeritageClause = 298,
            CatchClause = 299,
            ImportAttributes = 300,
            ImportAttribute = 301,
            AssertClause = 300,
            AssertEntry = 301,
            ImportTypeAssertionContainer = 302,
            PropertyAssignment = 303,
            ShorthandPropertyAssignment = 304,
            SpreadAssignment = 305,
            EnumMember = 306,
            SourceFile = 307,
            Bundle = 308,
            JSDocTypeExpression = 309,
            JSDocNameReference = 310,
            JSDocMemberName = 311,
            JSDocAllType = 312,
            JSDocUnknownType = 313,
            JSDocNullableType = 314,
            JSDocNonNullableType = 315,
            JSDocOptionalType = 316,
            JSDocFunctionType = 317,
            JSDocVariadicType = 318,
            JSDocNamepathType = 319,
            JSDoc = 320,
            JSDocComment = 320,
            JSDocText = 321,
            JSDocTypeLiteral = 322,
            JSDocSignature = 323,
            JSDocLink = 324,
            JSDocLinkCode = 325,
            JSDocLinkPlain = 326,
            JSDocTag = 327,
            JSDocAugmentsTag = 328,
            JSDocImplementsTag = 329,
            JSDocAuthorTag = 330,
            JSDocDeprecatedTag = 331,
            JSDocClassTag = 332,
            JSDocPublicTag = 333,
            JSDocPrivateTag = 334,
            JSDocProtectedTag = 335,
            JSDocReadonlyTag = 336,
            JSDocOverrideTag = 337,
            JSDocCallbackTag = 338,
            JSDocOverloadTag = 339,
            JSDocEnumTag = 340,
            JSDocParameterTag = 341,
            JSDocReturnTag = 342,
            JSDocThisTag = 343,
            JSDocTypeTag = 344,
            JSDocTemplateTag = 345,
            JSDocTypedefTag = 346,
            JSDocSeeTag = 347,
            JSDocPropertyTag = 348,
            JSDocThrowsTag = 349,
            JSDocSatisfiesTag = 350,
            JSDocImportTag = 351,
            SyntaxList = 352,
            NotEmittedStatement = 353,
            NotEmittedTypeElement = 354,
            PartiallyEmittedExpression = 355,
            CommaListExpression = 356,
            SyntheticReferenceExpression = 357,
            Count = 358,
            FirstAssignment = 64,
            LastAssignment = 79,
            FirstCompoundAssignment = 65,
            LastCompoundAssignment = 79,
            FirstReservedWord = 83,
            LastReservedWord = 118,
            FirstKeyword = 83,
            LastKeyword = 165,
            FirstFutureReservedWord = 119,
            LastFutureReservedWord = 127,
            FirstTypeNode = 182,
            LastTypeNode = 205,
            FirstPunctuation = 19,
            LastPunctuation = 79,
            FirstToken = 0,
            LastToken = 165,
            FirstTriviaToken = 2,
            LastTriviaToken = 7,
            FirstLiteralToken = 9,
            LastLiteralToken = 15,
            FirstTemplateToken = 15,
            LastTemplateToken = 18,
            FirstBinaryOperator = 30,
            LastBinaryOperator = 79,
            FirstStatement = 243,
            LastStatement = 259,
            FirstNode = 166,
            FirstJSDocNode = 309,
            LastJSDocNode = 351,
            FirstJSDocTagNode = 327,
            LastJSDocTagNode = 351,
            FirstContextualKeyword = 128,
            LastContextualKeyword = 165
        }
        type TriviaSyntaxKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia | SyntaxKind.NewLineTrivia | SyntaxKind.WhitespaceTrivia | SyntaxKind.ShebangTrivia | SyntaxKind.ConflictMarkerTrivia;
        type LiteralSyntaxKind = SyntaxKind.NumericLiteral | SyntaxKind.BigIntLiteral | SyntaxKind.StringLiteral | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.RegularExpressionLiteral | SyntaxKind.NoSubstitutionTemplateLiteral;
        type PseudoLiteralSyntaxKind = SyntaxKind.TemplateHead | SyntaxKind.TemplateMiddle | SyntaxKind.TemplateTail;
        type PunctuationSyntaxKind = SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.OpenParenToken | SyntaxKind.CloseParenToken | SyntaxKind.OpenBracketToken | SyntaxKind.CloseBracketToken | SyntaxKind.DotToken | SyntaxKind.DotDotDotToken | SyntaxKind.SemicolonToken | SyntaxKind.CommaToken | SyntaxKind.QuestionDotToken | SyntaxKind.LessThanToken | SyntaxKind.LessThanSlashToken | SyntaxKind.GreaterThanToken | SyntaxKind.LessThanEqualsToken | SyntaxKind.GreaterThanEqualsToken | SyntaxKind.EqualsEqualsToken | SyntaxKind.ExclamationEqualsToken | SyntaxKind.EqualsEqualsEqualsToken | SyntaxKind.ExclamationEqualsEqualsToken | SyntaxKind.EqualsGreaterThanToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.AsteriskToken | SyntaxKind.AsteriskAsteriskToken | SyntaxKind.SlashToken | SyntaxKind.PercentToken | SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.LessThanLessThanToken | SyntaxKind.GreaterThanGreaterThanToken | SyntaxKind.GreaterThanGreaterThanGreaterThanToken | SyntaxKind.AmpersandToken | SyntaxKind.BarToken | SyntaxKind.CaretToken | SyntaxKind.ExclamationToken | SyntaxKind.TildeToken | SyntaxKind.AmpersandAmpersandToken | SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.BarBarToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.QuestionQuestionToken | SyntaxKind.QuestionQuestionEqualsToken | SyntaxKind.QuestionToken | SyntaxKind.ColonToken | SyntaxKind.AtToken | SyntaxKind.BacktickToken | SyntaxKind.HashToken | SyntaxKind.EqualsToken | SyntaxKind.PlusEqualsToken | SyntaxKind.MinusEqualsToken | SyntaxKind.AsteriskEqualsToken | SyntaxKind.AsteriskAsteriskEqualsToken | SyntaxKind.SlashEqualsToken | SyntaxKind.PercentEqualsToken | SyntaxKind.LessThanLessThanEqualsToken | SyntaxKind.GreaterThanGreaterThanEqualsToken | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken | SyntaxKind.AmpersandEqualsToken | SyntaxKind.BarEqualsToken | SyntaxKind.CaretEqualsToken;
        type PunctuationOrKeywordSyntaxKind = PunctuationSyntaxKind | KeywordSyntaxKind;
        type KeywordSyntaxKind = SyntaxKind.AbstractKeyword | SyntaxKind.AccessorKeyword | SyntaxKind.AnyKeyword | SyntaxKind.AsKeyword | SyntaxKind.AssertsKeyword | SyntaxKind.AssertKeyword | SyntaxKind.AsyncKeyword | SyntaxKind.AwaitKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.BreakKeyword | SyntaxKind.CaseKeyword | SyntaxKind.CatchKeyword | SyntaxKind.ClassKeyword | SyntaxKind.ConstKeyword | SyntaxKind.ConstructorKeyword | SyntaxKind.ContinueKeyword | SyntaxKind.DebuggerKeyword | SyntaxKind.DeclareKeyword | SyntaxKind.DefaultKeyword | SyntaxKind.DeleteKeyword | SyntaxKind.DoKeyword | SyntaxKind.ElseKeyword | SyntaxKind.EnumKeyword | SyntaxKind.ExportKeyword | SyntaxKind.ExtendsKeyword | SyntaxKind.FalseKeyword | SyntaxKind.FinallyKeyword | SyntaxKind.ForKeyword | SyntaxKind.FromKeyword | SyntaxKind.FunctionKeyword | SyntaxKind.GetKeyword | SyntaxKind.GlobalKeyword | SyntaxKind.IfKeyword | SyntaxKind.ImplementsKeyword | SyntaxKind.ImportKeyword | SyntaxKind.InferKeyword | SyntaxKind.InKeyword | SyntaxKind.InstanceOfKeyword | SyntaxKind.InterfaceKeyword | SyntaxKind.IntrinsicKeyword | SyntaxKind.IsKeyword | SyntaxKind.KeyOfKeyword | SyntaxKind.LetKeyword | SyntaxKind.ModuleKeyword | SyntaxKind.NamespaceKeyword | SyntaxKind.NeverKeyword | SyntaxKind.NewKeyword | SyntaxKind.NullKeyword | SyntaxKind.NumberKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.OfKeyword | SyntaxKind.PackageKeyword | SyntaxKind.PrivateKeyword | SyntaxKind.ProtectedKeyword | SyntaxKind.PublicKeyword | SyntaxKind.ReadonlyKeyword | SyntaxKind.OutKeyword | SyntaxKind.OverrideKeyword | SyntaxKind.RequireKeyword | SyntaxKind.ReturnKeyword | SyntaxKind.SatisfiesKeyword | SyntaxKind.SetKeyword | SyntaxKind.StaticKeyword | SyntaxKind.StringKeyword | SyntaxKind.SuperKeyword | SyntaxKind.SwitchKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.ThisKeyword | SyntaxKind.ThrowKeyword | SyntaxKind.TrueKeyword | SyntaxKind.TryKeyword | SyntaxKind.TypeKeyword | SyntaxKind.TypeOfKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.UsingKeyword | SyntaxKind.VarKeyword | SyntaxKind.VoidKeyword | SyntaxKind.WhileKeyword | SyntaxKind.WithKeyword | SyntaxKind.YieldKeyword;
        type ModifierSyntaxKind = SyntaxKind.AbstractKeyword | SyntaxKind.AccessorKeyword | SyntaxKind.AsyncKeyword | SyntaxKind.ConstKeyword | SyntaxKind.DeclareKeyword | SyntaxKind.DefaultKeyword | SyntaxKind.ExportKeyword | SyntaxKind.InKeyword | SyntaxKind.PrivateKeyword | SyntaxKind.ProtectedKeyword | SyntaxKind.PublicKeyword | SyntaxKind.ReadonlyKeyword | SyntaxKind.OutKeyword | SyntaxKind.OverrideKeyword | SyntaxKind.StaticKeyword;
        type KeywordTypeSyntaxKind = SyntaxKind.AnyKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.IntrinsicKeyword | SyntaxKind.NeverKeyword | SyntaxKind.NumberKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.StringKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.VoidKeyword;
        type TypeNodeSyntaxKind = KeywordTypeSyntaxKind | SyntaxKind.TypePredicate | SyntaxKind.TypeReference | SyntaxKind.FunctionType | SyntaxKind.ConstructorType | SyntaxKind.TypeQuery | SyntaxKind.TypeLiteral | SyntaxKind.ArrayType | SyntaxKind.TupleType | SyntaxKind.NamedTupleMember | SyntaxKind.OptionalType | SyntaxKind.RestType | SyntaxKind.UnionType | SyntaxKind.IntersectionType | SyntaxKind.ConditionalType | SyntaxKind.InferType | SyntaxKind.ParenthesizedType | SyntaxKind.ThisType | SyntaxKind.TypeOperator | SyntaxKind.IndexedAccessType | SyntaxKind.MappedType | SyntaxKind.LiteralType | SyntaxKind.TemplateLiteralType | SyntaxKind.TemplateLiteralTypeSpan | SyntaxKind.ImportType | SyntaxKind.ExpressionWithTypeArguments | SyntaxKind.JSDocTypeExpression | SyntaxKind.JSDocAllType | SyntaxKind.JSDocUnknownType | SyntaxKind.JSDocNonNullableType | SyntaxKind.JSDocNullableType | SyntaxKind.JSDocOptionalType | SyntaxKind.JSDocFunctionType | SyntaxKind.JSDocVariadicType | SyntaxKind.JSDocNamepathType | SyntaxKind.JSDocSignature | SyntaxKind.JSDocTypeLiteral;
        type TokenSyntaxKind = SyntaxKind.Unknown | SyntaxKind.EndOfFileToken | TriviaSyntaxKind | LiteralSyntaxKind | PseudoLiteralSyntaxKind | PunctuationSyntaxKind | SyntaxKind.Identifier | KeywordSyntaxKind;
        type JsxTokenSyntaxKind = SyntaxKind.LessThanSlashToken | SyntaxKind.EndOfFileToken | SyntaxKind.ConflictMarkerTrivia | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.OpenBraceToken | SyntaxKind.LessThanToken;
        type JSDocSyntaxKind = SyntaxKind.EndOfFileToken | SyntaxKind.WhitespaceTrivia | SyntaxKind.AtToken | SyntaxKind.NewLineTrivia | SyntaxKind.AsteriskToken | SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.LessThanToken | SyntaxKind.GreaterThanToken | SyntaxKind.OpenBracketToken | SyntaxKind.CloseBracketToken | SyntaxKind.OpenParenToken | SyntaxKind.CloseParenToken | SyntaxKind.EqualsToken | SyntaxKind.CommaToken | SyntaxKind.DotToken | SyntaxKind.Identifier | SyntaxKind.BacktickToken | SyntaxKind.HashToken | SyntaxKind.Unknown | KeywordSyntaxKind;
        enum NodeFlags {
            None = 0,
            Let = 1,
            Const = 2,
            Using = 4,
            AwaitUsing = 6,
            NestedNamespace = 8,
            Synthesized = 16,
            Namespace = 32,
            OptionalChain = 64,
            ExportContext = 128,
            ContainsThis = 256,
            HasImplicitReturn = 512,
            HasExplicitReturn = 1024,
            GlobalAugmentation = 2048,
            HasAsyncFunctions = 4096,
            DisallowInContext = 8192,
            YieldContext = 16384,
            DecoratorContext = 32768,
            AwaitContext = 65536,
            DisallowConditionalTypesContext = 131072,
            ThisNodeHasError = 262144,
            JavaScriptFile = 524288,
            ThisNodeOrAnySubNodesHasError = 1048576,
            HasAggregatedChildData = 2097152,
            PossiblyContainsDynamicImport = 4194304,
            PossiblyContainsImportMeta = 8388608,
            JSDoc = 16777216,
            Ambient = 33554432,
            InWithStatement = 67108864,
            JsonFile = 134217728,
            TypeCached = 268435456,
            Deprecated = 536870912,
            BlockScoped = 7,
            Constant = 6,
            ReachabilityCheckFlags = 1536,
            ReachabilityAndEmitFlags = 5632,
            ContextFlags = 101441536,
            TypeExcludesFlags = 81920,
            PermanentlySetIncrementalFlags = 12582912,
            IdentifierHasExtendedUnicodeEscape = 256,
            IdentifierIsInJSDocNamespace = 4096
        }
        enum ModifierFlags {
            None = 0,
            Public = 1,
            Private = 2,
            Protected = 4,
            Readonly = 8,
            Override = 16,
            Export = 32,
            Abstract = 64,
            Ambient = 128,
            Static = 256,
            Accessor = 512,
            Async = 1024,
            Default = 2048,
            Const = 4096,
            In = 8192,
            Out = 16384,
            Decorator = 32768,
            Deprecated = 65536,
            JSDocPublic = 8388608,
            JSDocPrivate = 16777216,
            JSDocProtected = 33554432,
            JSDocReadonly = 67108864,
            JSDocOverride = 134217728,
            SyntacticOrJSDocModifiers = 31,
            SyntacticOnlyModifiers = 65504,
            SyntacticModifiers = 65535,
            JSDocCacheOnlyModifiers = 260046848,
            JSDocOnlyModifiers = 65536,
            NonCacheOnlyModifiers = 131071,
            HasComputedJSDocModifiers = 268435456,
            HasComputedFlags = 536870912,
            AccessibilityModifier = 7,
            ParameterPropertyModifier = 31,
            NonPublicAccessibilityModifier = 6,
            TypeScriptModifier = 28895,
            ExportDefault = 2080,
            All = 131071,
            Modifier = 98303
        }
        enum JsxFlags {
            None = 0,
            IntrinsicNamedElement = 1,
            IntrinsicIndexedElement = 2,
            IntrinsicElement = 3
        }
        enum RelationComparisonResult {
            None = 0,
            Succeeded = 1,
            Failed = 2,
            ReportsUnmeasurable = 8,
            ReportsUnreliable = 16,
            ReportsMask = 24,
            ComplexityOverflow = 32,
            StackDepthOverflow = 64,
            Overflow = 96
        }
        enum PredicateSemantics {
            None = 0,
            Always = 1,
            Never = 2,
            Sometimes = 3
        }
        type NodeId = number;
        interface Node extends ReadonlyTextRange {
            readonly kind: SyntaxKind;
            readonly flags: NodeFlags;
            modifierFlagsCache: ModifierFlags;
            readonly transformFlags: TransformFlags;
            id?: NodeId;
            readonly parent: Node;
            original?: Node;
            emitNode?: EmitNode;
        }
        interface Node {
            getSourceFile(): SourceFile;
            getChildCount(sourceFile?: SourceFile): number;
            getChildAt(index: number, sourceFile?: SourceFile): Node;
            getChildren(sourceFile?: SourceFile): readonly Node[];
            getChildren(sourceFile?: SourceFileLike): readonly Node[];
            getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number;
            getStart(sourceFile?: SourceFileLike, includeJsDocComment?: boolean): number;
            getFullStart(): number;
            getEnd(): number;
            getWidth(sourceFile?: SourceFileLike): number;
            getFullWidth(): number;
            getLeadingTriviaWidth(sourceFile?: SourceFile): number;
            getFullText(sourceFile?: SourceFile): string;
            getText(sourceFile?: SourceFile): string;
            getFirstToken(sourceFile?: SourceFile): Node | undefined;
            getFirstToken(sourceFile?: SourceFileLike): Node | undefined;
            getLastToken(sourceFile?: SourceFile): Node | undefined;
            getLastToken(sourceFile?: SourceFileLike): Node | undefined;
            forEachChild<T>(cbNode: (node: Node) => T | undefined, cbNodeArray?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
        }
        interface JSDocContainer extends Node {
            _jsdocContainerBrand: any;
            jsDoc?: JSDocArray;
        }
        interface JSDocArray extends Array<JSDoc> {
            jsDocCache?: readonly JSDocTag[];
        }
        interface LocalsContainer extends Node {
            _localsContainerBrand: any;
            locals?: SymbolTable;
            nextContainer?: HasLocals;
        }
        interface FlowContainer extends Node {
            _flowContainerBrand: any;
            flowNode?: FlowNode;
        }
        type HasFlowNode = Identifier | ThisExpression | SuperExpression | QualifiedName | MetaProperty | ElementAccessExpression | PropertyAccessExpression | BindingElement | FunctionExpression | ArrowFunction | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | VariableStatement | ExpressionStatement | IfStatement | DoStatement | WhileStatement | ForStatement | ForInStatement | ForOfStatement | ContinueStatement | BreakStatement | ReturnStatement | WithStatement | SwitchStatement | LabeledStatement | ThrowStatement | TryStatement | DebuggerStatement;
        type ForEachChildNodes = HasChildren | MissingDeclaration | JSDocTypeExpression | JSDocNonNullableType | JSDocNullableType | JSDocOptionalType | JSDocVariadicType | JSDocFunctionType | JSDoc | JSDocSeeTag | JSDocNameReference | JSDocMemberName | JSDocParameterTag | JSDocPropertyTag | JSDocAuthorTag | JSDocImplementsTag | JSDocAugmentsTag | JSDocTemplateTag | JSDocTypedefTag | JSDocCallbackTag | JSDocReturnTag | JSDocTypeTag | JSDocThisTag | JSDocEnumTag | JSDocSignature | JSDocLink | JSDocLinkCode | JSDocLinkPlain | JSDocTypeLiteral | JSDocUnknownTag | JSDocClassTag | JSDocPublicTag | JSDocPrivateTag | JSDocProtectedTag | JSDocReadonlyTag | JSDocDeprecatedTag | JSDocThrowsTag | JSDocOverrideTag | JSDocSatisfiesTag | JSDocOverloadTag | JSDocImportTag;
        type HasChildren = QualifiedName | ComputedPropertyName | TypeParameterDeclaration | ParameterDeclaration | Decorator | PropertySignature | PropertyDeclaration | MethodSignature | MethodDeclaration | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ClassStaticBlockDeclaration | CallSignatureDeclaration | ConstructSignatureDeclaration | IndexSignatureDeclaration | TypePredicateNode | TypeReferenceNode | FunctionTypeNode | ConstructorTypeNode | TypeQueryNode | TypeLiteralNode | ArrayTypeNode | TupleTypeNode | OptionalTypeNode | RestTypeNode | UnionTypeNode | IntersectionTypeNode | ConditionalTypeNode | InferTypeNode | ImportTypeNode | ImportTypeAssertionContainer | NamedTupleMember | ParenthesizedTypeNode | TypeOperatorNode | IndexedAccessTypeNode | MappedTypeNode | LiteralTypeNode | TemplateLiteralTypeNode | TemplateLiteralTypeSpan | ObjectBindingPattern | ArrayBindingPattern | BindingElement | ArrayLiteralExpression | ObjectLiteralExpression | PropertyAccessExpression | ElementAccessExpression | CallExpression | NewExpression | TaggedTemplateExpression | TypeAssertion | ParenthesizedExpression | FunctionExpression | ArrowFunction | DeleteExpression | TypeOfExpression | VoidExpression | AwaitExpression | PrefixUnaryExpression | PostfixUnaryExpression | BinaryExpression | ConditionalExpression | TemplateExpression | YieldExpression | SpreadElement | ClassExpression | ExpressionWithTypeArguments | AsExpression | NonNullExpression | SatisfiesExpression | MetaProperty | TemplateSpan | Block | VariableStatement | ExpressionStatement | IfStatement | DoStatement | WhileStatement | ForStatement | ForInStatement | ForOfStatement | ContinueStatement | BreakStatement | ReturnStatement | WithStatement | SwitchStatement | LabeledStatement | ThrowStatement | TryStatement | VariableDeclaration | VariableDeclarationList | FunctionDeclaration | ClassDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumDeclaration | ModuleDeclaration | ModuleBlock | CaseBlock | NamespaceExportDeclaration | ImportEqualsDeclaration | ImportDeclaration | AssertClause | AssertEntry | ImportAttributes | ImportAttribute | ImportClause | NamespaceImport | NamespaceExport | NamedImports | ImportSpecifier | ExportAssignment | ExportDeclaration | NamedExports | ExportSpecifier | ExternalModuleReference | JsxElement | JsxSelfClosingElement | JsxOpeningElement | JsxClosingElement | JsxFragment | JsxAttribute | JsxAttributes | JsxSpreadAttribute | JsxExpression | JsxNamespacedName | CaseClause | DefaultClause | HeritageClause | CatchClause | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | EnumMember | SourceFile | PartiallyEmittedExpression | CommaListExpression;
        type HasJSDoc = AccessorDeclaration | ArrowFunction | BinaryExpression | Block | BreakStatement | CallSignatureDeclaration | CaseClause | ClassLikeDeclaration | ClassStaticBlockDeclaration | ConstructorDeclaration | ConstructorTypeNode | ConstructSignatureDeclaration | ContinueStatement | DebuggerStatement | DoStatement | ElementAccessExpression | EmptyStatement | EndOfFileToken | EnumDeclaration | EnumMember | ExportAssignment | ExportDeclaration | ExportSpecifier | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | FunctionTypeNode | Identifier | IfStatement | ImportDeclaration | ImportEqualsDeclaration | IndexSignatureDeclaration | InterfaceDeclaration | JSDocFunctionType | JSDocSignature | LabeledStatement | MethodDeclaration | MethodSignature | ModuleDeclaration | NamedTupleMember | NamespaceExportDeclaration | ObjectLiteralExpression | ParameterDeclaration | ParenthesizedExpression | PropertyAccessExpression | PropertyAssignment | PropertyDeclaration | PropertySignature | ReturnStatement | SemicolonClassElement | ShorthandPropertyAssignment | SpreadAssignment | SwitchStatement | ThrowStatement | TryStatement | TypeAliasDeclaration | TypeParameterDeclaration | VariableDeclaration | VariableStatement | WhileStatement | WithStatement;
        type HasType = SignatureDeclaration | VariableDeclaration | ParameterDeclaration | PropertySignature | PropertyDeclaration | TypePredicateNode | ParenthesizedTypeNode | TypeOperatorNode | MappedTypeNode | AssertionExpression | TypeAliasDeclaration | JSDocTypeExpression | JSDocNonNullableType | JSDocNullableType | JSDocOptionalType | JSDocVariadicType;
        type HasIllegalType = ConstructorDeclaration | SetAccessorDeclaration;
        type HasIllegalTypeParameters = ConstructorDeclaration | SetAccessorDeclaration | GetAccessorDeclaration;
        type HasTypeArguments = CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement | JsxSelfClosingElement;
        type HasInitializer = HasExpressionInitializer | ForStatement | ForInStatement | ForOfStatement | JsxAttribute;
        type HasExpressionInitializer = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | EnumMember;
        type HasIllegalExpressionInitializer = PropertySignature;
        type HasDecorators = ParameterDeclaration | PropertyDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ClassExpression | ClassDeclaration;
        type HasIllegalDecorators = PropertyAssignment | ShorthandPropertyAssignment | FunctionDeclaration | ConstructorDeclaration | IndexSignatureDeclaration | ClassStaticBlockDeclaration | MissingDeclaration | VariableStatement | InterfaceDeclaration | TypeAliasDeclaration | EnumDeclaration | ModuleDeclaration | ImportEqualsDeclaration | ImportDeclaration | NamespaceExportDeclaration | ExportDeclaration | ExportAssignment;
        type HasModifiers = TypeParameterDeclaration | ParameterDeclaration | ConstructorTypeNode | PropertySignature | PropertyDeclaration | MethodSignature | MethodDeclaration | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | IndexSignatureDeclaration | FunctionExpression | ArrowFunction | ClassExpression | VariableStatement | FunctionDeclaration | ClassDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumDeclaration | ModuleDeclaration | ImportEqualsDeclaration | ImportDeclaration | ExportAssignment | ExportDeclaration;
        type HasIllegalModifiers = ClassStaticBlockDeclaration | PropertyAssignment | ShorthandPropertyAssignment | MissingDeclaration | NamespaceExportDeclaration;
        type PrimitiveLiteral = BooleanLiteral | NumericLiteral | StringLiteral | NoSubstitutionTemplateLiteral | BigIntLiteral | PrefixUnaryExpression & {
            operator: SyntaxKind.PlusToken;
            operand: NumericLiteral;
        } | PrefixUnaryExpression & {
            operator: SyntaxKind.MinusToken;
            operand: NumericLiteral | BigIntLiteral;
        };
        type IsContainer = ClassExpression | ClassDeclaration | EnumDeclaration | ObjectLiteralExpression | TypeLiteralNode | JSDocTypeLiteral | JsxAttributes | InterfaceDeclaration | ModuleDeclaration | TypeAliasDeclaration | MappedTypeNode | IndexSignatureDeclaration | SourceFile | GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration | ConstructorDeclaration | FunctionDeclaration | MethodSignature | CallSignatureDeclaration | JSDocSignature | JSDocFunctionType | FunctionTypeNode | ConstructSignatureDeclaration | ConstructorTypeNode | ClassStaticBlockDeclaration | FunctionExpression | ArrowFunction;
        type IsBlockScopedContainer = IsContainer | CatchClause | ForStatement | ForInStatement | ForOfStatement | CaseBlock | Block;
        type IsControlFlowContainer = SourceFile | GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration | ConstructorDeclaration | FunctionDeclaration | MethodSignature | CallSignatureDeclaration | JSDocSignature | JSDocFunctionType | FunctionTypeNode | ConstructSignatureDeclaration | ConstructorTypeNode | ClassStaticBlockDeclaration | FunctionExpression | ArrowFunction | ModuleBlock | PropertyDeclaration;
        type IsFunctionLike = GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration | ConstructorDeclaration | FunctionDeclaration | MethodSignature | CallSignatureDeclaration | JSDocSignature | JSDocFunctionType | FunctionTypeNode | ConstructSignatureDeclaration | ConstructorTypeNode | ClassStaticBlockDeclaration | FunctionExpression | ArrowFunction;
        type IsFunctionExpression = FunctionExpression | ArrowFunction;
        type HasLocals = ArrowFunction | Block | CallSignatureDeclaration | CaseBlock | CatchClause | ClassStaticBlockDeclaration | ConditionalTypeNode | ConstructorDeclaration | ConstructorTypeNode | ConstructSignatureDeclaration | ForStatement | ForInStatement | ForOfStatement | FunctionDeclaration | FunctionExpression | FunctionTypeNode | GetAccessorDeclaration | IndexSignatureDeclaration | JSDocCallbackTag | JSDocEnumTag | JSDocFunctionType | JSDocSignature | JSDocTypedefTag | MappedTypeNode | MethodDeclaration | MethodSignature | ModuleDeclaration | SetAccessorDeclaration | SourceFile | TypeAliasDeclaration;
        type IsInterface = InterfaceDeclaration;
        type IsObjectLiteralOrClassExpressionMethodOrAccessor = GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration;
        type HasContainerFlags = IsContainer | IsBlockScopedContainer | IsControlFlowContainer | IsFunctionLike | IsFunctionExpression | HasLocals | IsInterface | IsObjectLiteralOrClassExpressionMethodOrAccessor;
        interface MutableNodeArray<T extends Node> extends Array<T>, TextRange {
            hasTrailingComma: boolean;
            transformFlags: TransformFlags;
        }
        interface NodeArray<T extends Node> extends ReadonlyArray<T>, ReadonlyTextRange {
            readonly hasTrailingComma: boolean;
            transformFlags: TransformFlags;
        }
        interface Token<TKind extends SyntaxKind> extends Node {
            readonly kind: TKind;
        }
        type EndOfFileToken = Token<SyntaxKind.EndOfFileToken> & JSDocContainer;
        interface PunctuationToken<TKind extends PunctuationSyntaxKind> extends Token<TKind> {
        }
        type DotToken = PunctuationToken<SyntaxKind.DotToken>;
        type DotDotDotToken = PunctuationToken<SyntaxKind.DotDotDotToken>;
        type QuestionToken = PunctuationToken<SyntaxKind.QuestionToken>;
        type ExclamationToken = PunctuationToken<SyntaxKind.ExclamationToken>;
        type ColonToken = PunctuationToken<SyntaxKind.ColonToken>;
        type EqualsToken = PunctuationToken<SyntaxKind.EqualsToken>;
        type AmpersandAmpersandEqualsToken = PunctuationToken<SyntaxKind.AmpersandAmpersandEqualsToken>;
        type BarBarEqualsToken = PunctuationToken<SyntaxKind.BarBarEqualsToken>;
        type QuestionQuestionEqualsToken = PunctuationToken<SyntaxKind.QuestionQuestionEqualsToken>;
        type AsteriskToken = PunctuationToken<SyntaxKind.AsteriskToken>;
        type EqualsGreaterThanToken = PunctuationToken<SyntaxKind.EqualsGreaterThanToken>;
        type PlusToken = PunctuationToken<SyntaxKind.PlusToken>;
        type MinusToken = PunctuationToken<SyntaxKind.MinusToken>;
        type QuestionDotToken = PunctuationToken<SyntaxKind.QuestionDotToken>;
        interface KeywordToken<TKind extends KeywordSyntaxKind> extends Token<TKind> {
        }
        type AssertsKeyword = KeywordToken<SyntaxKind.AssertsKeyword>;
        type AssertKeyword = KeywordToken<SyntaxKind.AssertKeyword>;
        type AwaitKeyword = KeywordToken<SyntaxKind.AwaitKeyword>;
        type CaseKeyword = KeywordToken<SyntaxKind.CaseKeyword>;
        interface ModifierToken<TKind extends ModifierSyntaxKind> extends KeywordToken<TKind> {
        }
        type AbstractKeyword = ModifierToken<SyntaxKind.AbstractKeyword>;
        type AccessorKeyword = ModifierToken<SyntaxKind.AccessorKeyword>;
        type AsyncKeyword = ModifierToken<SyntaxKind.AsyncKeyword>;
        type ConstKeyword = ModifierToken<SyntaxKind.ConstKeyword>;
        type DeclareKeyword = ModifierToken<SyntaxKind.DeclareKeyword>;
        type DefaultKeyword = ModifierToken<SyntaxKind.DefaultKeyword>;
        type ExportKeyword = ModifierToken<SyntaxKind.ExportKeyword>;
        type InKeyword = ModifierToken<SyntaxKind.InKeyword>;
        type PrivateKeyword = ModifierToken<SyntaxKind.PrivateKeyword>;
        type ProtectedKeyword = ModifierToken<SyntaxKind.ProtectedKeyword>;
        type PublicKeyword = ModifierToken<SyntaxKind.PublicKeyword>;
        type ReadonlyKeyword = ModifierToken<SyntaxKind.ReadonlyKeyword>;
        type OutKeyword = ModifierToken<SyntaxKind.OutKeyword>;
        type OverrideKeyword = ModifierToken<SyntaxKind.OverrideKeyword>;
        type StaticKeyword = ModifierToken<SyntaxKind.StaticKeyword>;
        type Modifier = AbstractKeyword | AccessorKeyword | AsyncKeyword | ConstKeyword | DeclareKeyword | DefaultKeyword | ExportKeyword | InKeyword | PrivateKeyword | ProtectedKeyword | PublicKeyword | OutKeyword | OverrideKeyword | ReadonlyKeyword | StaticKeyword;
        type ModifierLike = Modifier | Decorator;
        type AccessibilityModifier = PublicKeyword | PrivateKeyword | ProtectedKeyword;
        type ParameterPropertyModifier = AccessibilityModifier | ReadonlyKeyword;
        type ClassMemberModifier = AccessibilityModifier | ReadonlyKeyword | StaticKeyword | AccessorKeyword;
        type ModifiersArray = NodeArray<Modifier>;
        enum GeneratedIdentifierFlags {
            None = 0,
            Auto = 1,
            Loop = 2,
            Unique = 3,
            Node = 4,
            KindMask = 7,
            ReservedInNestedScopes = 8,
            Optimistic = 16,
            FileLevel = 32,
            AllowNameSubstitution = 64
        }
        interface Identifier extends PrimaryExpression, Declaration, JSDocContainer, FlowContainer {
            readonly kind: SyntaxKind.Identifier;
            readonly escapedText: __String;
        }
        interface Identifier {
            readonly text: string;
        }
        interface TransientIdentifier extends Identifier {
            resolvedSymbol: Symbol;
        }
        interface AutoGenerateInfo {
            flags: GeneratedIdentifierFlags;
            readonly id: number;
            readonly prefix?: string | GeneratedNamePart;
            readonly suffix?: string;
        }
        interface GeneratedIdentifier extends Identifier {
            readonly emitNode: EmitNode & {
                autoGenerate: AutoGenerateInfo;
            };
        }
        interface QualifiedName extends Node, FlowContainer {
            readonly kind: SyntaxKind.QualifiedName;
            readonly left: EntityName;
            readonly right: Identifier;
        }
        type EntityName = Identifier | QualifiedName;
        type PropertyName = Identifier | StringLiteral | NoSubstitutionTemplateLiteral | NumericLiteral | ComputedPropertyName | PrivateIdentifier | BigIntLiteral;
        type MemberName = Identifier | PrivateIdentifier;
        type DeclarationName = PropertyName | JsxAttributeName | StringLiteralLike | ElementAccessExpression | BindingPattern | EntityNameExpression;
        interface Declaration extends Node {
            _declarationBrand: any;
            symbol: Symbol;
            localSymbol?: Symbol;
        }
        interface NamedDeclaration extends Declaration {
            readonly name?: DeclarationName;
        }
        interface DynamicNamedDeclaration extends NamedDeclaration {
            readonly name: ComputedPropertyName;
        }
        interface DynamicNamedBinaryExpression extends BinaryExpression {
            readonly left: ElementAccessExpression;
        }
        interface LateBoundDeclaration extends DynamicNamedDeclaration {
            readonly name: LateBoundName;
        }
        interface LateBoundBinaryExpressionDeclaration extends DynamicNamedBinaryExpression {
            readonly left: LateBoundElementAccessExpression;
        }
        interface LateBoundElementAccessExpression extends ElementAccessExpression {
            readonly argumentExpression: EntityNameExpression;
        }
        interface DeclarationStatement extends NamedDeclaration, Statement {
            readonly name?: Identifier | StringLiteral | NumericLiteral;
        }
        interface ComputedPropertyName extends Node {
            readonly kind: SyntaxKind.ComputedPropertyName;
            readonly parent: Declaration;
            readonly expression: Expression;
        }
        interface PrivateIdentifier extends PrimaryExpression {
            readonly kind: SyntaxKind.PrivateIdentifier;
            readonly escapedText: __String;
        }
        interface PrivateIdentifier {
            readonly text: string;
        }
        interface GeneratedPrivateIdentifier extends PrivateIdentifier {
            readonly emitNode: EmitNode & {
                autoGenerate: AutoGenerateInfo;
            };
        }
        interface LateBoundName extends ComputedPropertyName {
            readonly expression: EntityNameExpression;
        }
        interface Decorator extends Node {
            readonly kind: SyntaxKind.Decorator;
            readonly parent: NamedDeclaration;
            readonly expression: LeftHandSideExpression;
        }
        interface TypeParameterDeclaration extends NamedDeclaration, JSDocContainer {
            readonly kind: SyntaxKind.TypeParameter;
            readonly parent: DeclarationWithTypeParameterChildren | InferTypeNode;
            readonly modifiers?: NodeArray<Modifier>;
            readonly name: Identifier;
            readonly constraint?: TypeNode;
            readonly default?: TypeNode;
            expression?: Expression;
        }
        interface SignatureDeclarationBase extends NamedDeclaration, JSDocContainer {
            readonly kind: SignatureDeclaration["kind"];
            readonly name?: PropertyName;
            readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined;
            readonly parameters: NodeArray<ParameterDeclaration>;
            readonly type?: TypeNode | undefined;
            typeArguments?: NodeArray<TypeNode>;
        }
        type SignatureDeclaration = CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | AccessorDeclaration | FunctionExpression | ArrowFunction;
        interface CallSignatureDeclaration extends SignatureDeclarationBase, TypeElement, LocalsContainer {
            readonly kind: SyntaxKind.CallSignature;
        }
        interface ConstructSignatureDeclaration extends SignatureDeclarationBase, TypeElement, LocalsContainer {
            readonly kind: SyntaxKind.ConstructSignature;
        }
        type BindingName = Identifier | BindingPattern;
        interface VariableDeclaration extends NamedDeclaration, JSDocContainer {
            readonly kind: SyntaxKind.VariableDeclaration;
            readonly parent: VariableDeclarationList | CatchClause;
            readonly name: BindingName;
            readonly exclamationToken?: ExclamationToken;
            readonly type?: TypeNode;
            readonly initializer?: Expression;
        }
        type InitializedVariableDeclaration = VariableDeclaration & {
            readonly initializer: Expression;
        };
        interface VariableDeclarationList extends Node {
            readonly kind: SyntaxKind.VariableDeclarationList;
            readonly parent: VariableStatement | ForStatement | ForOfStatement | ForInStatement;
            readonly declarations: NodeArray<VariableDeclaration>;
        }
        interface ParameterDeclaration extends NamedDeclaration, JSDocContainer {
            readonly kind: SyntaxKind.Parameter;
            readonly parent: SignatureDeclaration;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly dotDotDotToken?: DotDotDotToken;
            readonly name: BindingName;
            readonly questionToken?: QuestionToken;
            readonly type?: TypeNode;
            readonly initializer?: Expression;
        }
        interface BindingElement extends NamedDeclaration, FlowContainer {
            readonly kind: SyntaxKind.BindingElement;
            readonly parent: BindingPattern;
            readonly propertyName?: PropertyName;
            readonly dotDotDotToken?: DotDotDotToken;
            readonly name: BindingName;
            readonly initializer?: Expression;
        }
        type BindingElementGrandparent = BindingElement["parent"]["parent"];
        interface PropertySignature extends TypeElement, JSDocContainer {
            readonly kind: SyntaxKind.PropertySignature;
            readonly parent: TypeLiteralNode | InterfaceDeclaration;
            readonly modifiers?: NodeArray<Modifier>;
            readonly name: PropertyName;
            readonly questionToken?: QuestionToken;
            readonly type?: TypeNode;
            readonly initializer?: Expression | undefined;
        }
        interface PropertyDeclaration extends ClassElement, JSDocContainer {
            readonly kind: SyntaxKind.PropertyDeclaration;
            readonly parent: ClassLikeDeclaration;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly name: PropertyName;
            readonly questionToken?: QuestionToken;
            readonly exclamationToken?: ExclamationToken;
            readonly type?: TypeNode;
            readonly initializer?: Expression;
        }
        interface AutoAccessorPropertyDeclaration extends PropertyDeclaration {
            _autoAccessorBrand: any;
        }
        interface PrivateIdentifierPropertyDeclaration extends PropertyDeclaration {
            name: PrivateIdentifier;
        }
        interface PrivateIdentifierAutoAccessorPropertyDeclaration extends AutoAccessorPropertyDeclaration {
            name: PrivateIdentifier;
        }
        interface PrivateIdentifierMethodDeclaration extends MethodDeclaration {
            name: PrivateIdentifier;
        }
        interface PrivateIdentifierGetAccessorDeclaration extends GetAccessorDeclaration {
            name: PrivateIdentifier;
        }
        interface PrivateIdentifierSetAccessorDeclaration extends SetAccessorDeclaration {
            name: PrivateIdentifier;
        }
        type PrivateIdentifierAccessorDeclaration = PrivateIdentifierGetAccessorDeclaration | PrivateIdentifierSetAccessorDeclaration;
        type PrivateClassElementDeclaration = PrivateIdentifierPropertyDeclaration | PrivateIdentifierAutoAccessorPropertyDeclaration | PrivateIdentifierMethodDeclaration | PrivateIdentifierGetAccessorDeclaration | PrivateIdentifierSetAccessorDeclaration;
        type InitializedPropertyDeclaration = PropertyDeclaration & {
            readonly initializer: Expression;
        };
        interface ObjectLiteralElement extends NamedDeclaration {
            _objectLiteralBrand: any;
            readonly name?: PropertyName;
        }
        type ObjectLiteralElementLike = PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | AccessorDeclaration;
        interface PropertyAssignment extends ObjectLiteralElement, JSDocContainer {
            readonly kind: SyntaxKind.PropertyAssignment;
            readonly parent: ObjectLiteralExpression;
            readonly name: PropertyName;
            readonly initializer: Expression;
            readonly modifiers?: NodeArray<ModifierLike> | undefined;
            readonly questionToken?: QuestionToken | undefined;
            readonly exclamationToken?: ExclamationToken | undefined;
        }
        interface ShorthandPropertyAssignment extends ObjectLiteralElement, JSDocContainer {
            readonly kind: SyntaxKind.ShorthandPropertyAssignment;
            readonly parent: ObjectLiteralExpression;
            readonly name: Identifier;
            readonly equalsToken?: EqualsToken;
            readonly objectAssignmentInitializer?: Expression;
            readonly modifiers?: NodeArray<ModifierLike> | undefined;
            readonly questionToken?: QuestionToken | undefined;
            readonly exclamationToken?: ExclamationToken | undefined;
        }
        interface SpreadAssignment extends ObjectLiteralElement, JSDocContainer {
            readonly kind: SyntaxKind.SpreadAssignment;
            readonly parent: ObjectLiteralExpression;
            readonly expression: Expression;
        }
        type VariableLikeDeclaration = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | PropertySignature | JsxAttribute | ShorthandPropertyAssignment | EnumMember | JSDocPropertyTag | JSDocParameterTag;
        interface ObjectBindingPattern extends Node {
            readonly kind: SyntaxKind.ObjectBindingPattern;
            readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;
            readonly elements: NodeArray<BindingElement>;
        }
        interface ArrayBindingPattern extends Node {
            readonly kind: SyntaxKind.ArrayBindingPattern;
            readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;
            readonly elements: NodeArray<ArrayBindingElement>;
        }
        type BindingPattern = ObjectBindingPattern | ArrayBindingPattern;
        type ArrayBindingElement = BindingElement | OmittedExpression;
        interface FunctionLikeDeclarationBase extends SignatureDeclarationBase {
            _functionLikeDeclarationBrand: any;
            readonly asteriskToken?: AsteriskToken | undefined;
            readonly questionToken?: QuestionToken | undefined;
            readonly exclamationToken?: ExclamationToken | undefined;
            readonly body?: Block | Expression | undefined;
            endFlowNode?: FlowNode;
            returnFlowNode?: FlowNode;
        }
        type FunctionLikeDeclaration = FunctionDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ConstructorDeclaration | FunctionExpression | ArrowFunction;
        type FunctionLike = SignatureDeclaration;
        interface FunctionDeclaration extends FunctionLikeDeclarationBase, DeclarationStatement, LocalsContainer {
            readonly kind: SyntaxKind.FunctionDeclaration;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly name?: Identifier;
            readonly body?: FunctionBody;
        }
        interface MethodSignature extends SignatureDeclarationBase, TypeElement, LocalsContainer {
            readonly kind: SyntaxKind.MethodSignature;
            readonly parent: TypeLiteralNode | InterfaceDeclaration;
            readonly modifiers?: NodeArray<Modifier>;
            readonly name: PropertyName;
        }
        interface MethodDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {
            readonly kind: SyntaxKind.MethodDeclaration;
            readonly parent: ClassLikeDeclaration | ObjectLiteralExpression;
            readonly modifiers?: NodeArray<ModifierLike> | undefined;
            readonly name: PropertyName;
            readonly body?: FunctionBody | undefined;
            readonly exclamationToken?: ExclamationToken | undefined;
        }
        interface ConstructorDeclaration extends FunctionLikeDeclarationBase, ClassElement, JSDocContainer, LocalsContainer {
            readonly kind: SyntaxKind.Constructor;
            readonly parent: ClassLikeDeclaration;
            readonly modifiers?: NodeArray<ModifierLike> | undefined;
            readonly body?: FunctionBody | undefined;
            readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
            readonly type?: TypeNode;
        }
        interface SemicolonClassElement extends ClassElement, JSDocContainer {
            readonly kind: SyntaxKind.SemicolonClassElement;
            readonly parent: ClassLikeDeclaration;
        }
        interface GetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {
            readonly kind: SyntaxKind.GetAccessor;
            readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly name: PropertyName;
            readonly body?: FunctionBody;
            readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined;
        }
        interface SetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {
            readonly kind: SyntaxKind.SetAccessor;
            readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly name: PropertyName;
            readonly body?: FunctionBody;
            readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined;
            readonly type?: TypeNode | undefined;
        }
        type AccessorDeclaration = GetAccessorDeclaration | SetAccessorDeclaration;
        interface IndexSignatureDeclaration extends SignatureDeclarationBase, ClassElement, TypeElement, LocalsContainer {
            readonly kind: SyntaxKind.IndexSignature;
            readonly parent: ObjectTypeDeclaration;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly type: TypeNode;
        }
        interface ClassStaticBlockDeclaration extends ClassElement, JSDocContainer, LocalsContainer {
            readonly kind: SyntaxKind.ClassStaticBlockDeclaration;
            readonly parent: ClassDeclaration | ClassExpression;
            readonly body: Block;
            endFlowNode?: FlowNode;
            returnFlowNode?: FlowNode;
            readonly modifiers?: NodeArray<ModifierLike> | undefined;
        }
        interface TypeNode extends Node {
            _typeNodeBrand: any;
        }
        interface TypeNode extends Node {
            readonly kind: TypeNodeSyntaxKind;
        }
        interface KeywordTypeNode<TKind extends KeywordTypeSyntaxKind = KeywordTypeSyntaxKind> extends KeywordToken<TKind>, TypeNode {
            readonly kind: TKind;
        }
        interface ImportTypeAssertionContainer extends Node {
            readonly kind: SyntaxKind.ImportTypeAssertionContainer;
            readonly parent: ImportTypeNode;
            readonly assertClause: AssertClause;
            readonly multiLine?: boolean;
        }
        interface ImportTypeNode extends NodeWithTypeArguments {
            readonly kind: SyntaxKind.ImportType;
            readonly isTypeOf: boolean;
            readonly argument: TypeNode;
            readonly assertions?: ImportTypeAssertionContainer;
            readonly attributes?: ImportAttributes;
            readonly qualifier?: EntityName;
        }
        type LiteralImportTypeNode = ImportTypeNode & {
            readonly argument: LiteralTypeNode & {
                readonly literal: StringLiteral;
            };
        };
        interface ThisTypeNode extends TypeNode {
            readonly kind: SyntaxKind.ThisType;
        }
        type FunctionOrConstructorTypeNode = FunctionTypeNode | ConstructorTypeNode;
        interface FunctionOrConstructorTypeNodeBase extends TypeNode, SignatureDeclarationBase {
            readonly kind: SyntaxKind.FunctionType | SyntaxKind.ConstructorType;
            readonly type: TypeNode;
        }
        interface FunctionTypeNode extends FunctionOrConstructorTypeNodeBase, LocalsContainer {
            readonly kind: SyntaxKind.FunctionType;
            readonly modifiers?: undefined;
        }
        interface ConstructorTypeNode extends FunctionOrConstructorTypeNodeBase, LocalsContainer {
            readonly kind: SyntaxKind.ConstructorType;
            readonly modifiers?: NodeArray<Modifier>;
        }
        interface NodeWithTypeArguments extends TypeNode {
            readonly typeArguments?: NodeArray<TypeNode>;
        }
        type TypeReferenceType = TypeReferenceNode | ExpressionWithTypeArguments;
        interface TypeReferenceNode extends NodeWithTypeArguments {
            readonly kind: SyntaxKind.TypeReference;
            readonly typeName: EntityName;
        }
        interface TypePredicateNode extends TypeNode {
            readonly kind: SyntaxKind.TypePredicate;
            readonly parent: SignatureDeclaration | JSDocTypeExpression;
            readonly assertsModifier?: AssertsKeyword;
            readonly parameterName: Identifier | ThisTypeNode;
            readonly type?: TypeNode;
        }
        interface TypeQueryNode extends NodeWithTypeArguments {
            readonly kind: SyntaxKind.TypeQuery;
            readonly exprName: EntityName;
        }
        interface TypeLiteralNode extends TypeNode, Declaration {
            readonly kind: SyntaxKind.TypeLiteral;
            readonly members: NodeArray<TypeElement>;
        }
        interface ArrayTypeNode extends TypeNode {
            readonly kind: SyntaxKind.ArrayType;
            readonly elementType: TypeNode;
        }
        interface TupleTypeNode extends TypeNode {
            readonly kind: SyntaxKind.TupleType;
            readonly elements: NodeArray<TypeNode | NamedTupleMember>;
        }
        interface NamedTupleMember extends TypeNode, Declaration, JSDocContainer {
            readonly kind: SyntaxKind.NamedTupleMember;
            readonly dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;
            readonly name: Identifier;
            readonly questionToken?: Token<SyntaxKind.QuestionToken>;
            readonly type: TypeNode;
        }
        interface OptionalTypeNode extends TypeNode {
            readonly kind: SyntaxKind.OptionalType;
            readonly type: TypeNode;
        }
        interface RestTypeNode extends TypeNode {
            readonly kind: SyntaxKind.RestType;
            readonly type: TypeNode;
        }
        type UnionOrIntersectionTypeNode = UnionTypeNode | IntersectionTypeNode;
        interface UnionTypeNode extends TypeNode {
            readonly kind: SyntaxKind.UnionType;
            readonly types: NodeArray<TypeNode>;
        }
        interface IntersectionTypeNode extends TypeNode {
            readonly kind: SyntaxKind.IntersectionType;
            readonly types: NodeArray<TypeNode>;
        }
        interface ConditionalTypeNode extends TypeNode, LocalsContainer {
            readonly kind: SyntaxKind.ConditionalType;
            readonly checkType: TypeNode;
            readonly extendsType: TypeNode;
            readonly trueType: TypeNode;
            readonly falseType: TypeNode;
        }
        interface InferTypeNode extends TypeNode {
            readonly kind: SyntaxKind.InferType;
            readonly typeParameter: TypeParameterDeclaration;
        }
        interface ParenthesizedTypeNode extends TypeNode {
            readonly kind: SyntaxKind.ParenthesizedType;
            readonly type: TypeNode;
        }
        interface TypeOperatorNode extends TypeNode {
            readonly kind: SyntaxKind.TypeOperator;
            readonly operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword;
            readonly type: TypeNode;
        }
        interface UniqueTypeOperatorNode extends TypeOperatorNode {
            readonly operator: SyntaxKind.UniqueKeyword;
        }
        interface IndexedAccessTypeNode extends TypeNode {
            readonly kind: SyntaxKind.IndexedAccessType;
            readonly objectType: TypeNode;
            readonly indexType: TypeNode;
        }
        interface MappedTypeNode extends TypeNode, Declaration, LocalsContainer {
            readonly kind: SyntaxKind.MappedType;
            readonly readonlyToken?: ReadonlyKeyword | PlusToken | MinusToken;
            readonly typeParameter: TypeParameterDeclaration;
            readonly nameType?: TypeNode;
            readonly questionToken?: QuestionToken | PlusToken | MinusToken;
            readonly type?: TypeNode;
            readonly members?: NodeArray<TypeElement>;
        }
        interface LiteralTypeNode extends TypeNode {
            readonly kind: SyntaxKind.LiteralType;
            readonly literal: NullLiteral | BooleanLiteral | LiteralExpression | PrefixUnaryExpression;
        }
        interface StringLiteral extends LiteralExpression, Declaration {
            readonly kind: SyntaxKind.StringLiteral;
            readonly textSourceNode?: Identifier | StringLiteralLike | NumericLiteral | PrivateIdentifier | JsxNamespacedName | BigIntLiteral;
            readonly singleQuote?: boolean;
        }
        type StringLiteralLike = StringLiteral | NoSubstitutionTemplateLiteral;
        type PropertyNameLiteral = Identifier | StringLiteralLike | NumericLiteral | JsxNamespacedName | BigIntLiteral;
        interface TemplateLiteralTypeNode extends TypeNode {
            kind: SyntaxKind.TemplateLiteralType;
            readonly head: TemplateHead;
            readonly templateSpans: NodeArray<TemplateLiteralTypeSpan>;
        }
        interface TemplateLiteralTypeSpan extends TypeNode {
            readonly kind: SyntaxKind.TemplateLiteralTypeSpan;
            readonly parent: TemplateLiteralTypeNode;
            readonly type: TypeNode;
            readonly literal: TemplateMiddle | TemplateTail;
        }
        interface Expression extends Node {
            _expressionBrand: any;
        }
        interface OmittedExpression extends Expression {
            readonly kind: SyntaxKind.OmittedExpression;
        }
        interface PartiallyEmittedExpression extends LeftHandSideExpression {
            readonly kind: SyntaxKind.PartiallyEmittedExpression;
            readonly expression: Expression;
        }
        interface UnaryExpression extends Expression {
            _unaryExpressionBrand: any;
        }
        type IncrementExpression = UpdateExpression;
        interface UpdateExpression extends UnaryExpression {
            _updateExpressionBrand: any;
        }
        type PrefixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.TildeToken | SyntaxKind.ExclamationToken;
        interface PrefixUnaryExpression extends UpdateExpression {
            readonly kind: SyntaxKind.PrefixUnaryExpression;
            readonly operator: PrefixUnaryOperator;
            readonly operand: UnaryExpression;
        }
        type PostfixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken;
        interface PostfixUnaryExpression extends UpdateExpression {
            readonly kind: SyntaxKind.PostfixUnaryExpression;
            readonly operand: LeftHandSideExpression;
            readonly operator: PostfixUnaryOperator;
        }
        interface LeftHandSideExpression extends UpdateExpression {
            _leftHandSideExpressionBrand: any;
        }
        interface MemberExpression extends LeftHandSideExpression {
            _memberExpressionBrand: any;
        }
        interface PrimaryExpression extends MemberExpression {
            _primaryExpressionBrand: any;
        }
        interface NullLiteral extends PrimaryExpression {
            readonly kind: SyntaxKind.NullKeyword;
        }
        interface TrueLiteral extends PrimaryExpression {
            readonly kind: SyntaxKind.TrueKeyword;
        }
        interface FalseLiteral extends PrimaryExpression {
            readonly kind: SyntaxKind.FalseKeyword;
        }
        type BooleanLiteral = TrueLiteral | FalseLiteral;
        interface ThisExpression extends PrimaryExpression, FlowContainer {
            readonly kind: SyntaxKind.ThisKeyword;
        }
        interface SuperExpression extends PrimaryExpression, FlowContainer {
            readonly kind: SyntaxKind.SuperKeyword;
        }
        interface ImportExpression extends PrimaryExpression {
            readonly kind: SyntaxKind.ImportKeyword;
        }
        interface DeleteExpression extends UnaryExpression {
            readonly kind: SyntaxKind.DeleteExpression;
            readonly expression: UnaryExpression;
        }
        interface TypeOfExpression extends UnaryExpression {
            readonly kind: SyntaxKind.TypeOfExpression;
            readonly expression: UnaryExpression;
        }
        interface VoidExpression extends UnaryExpression {
            readonly kind: SyntaxKind.VoidExpression;
            readonly expression: UnaryExpression;
        }
        interface AwaitExpression extends UnaryExpression {
            readonly kind: SyntaxKind.AwaitExpression;
            readonly expression: UnaryExpression;
        }
        interface YieldExpression extends Expression {
            readonly kind: SyntaxKind.YieldExpression;
            readonly asteriskToken?: AsteriskToken;
            readonly expression?: Expression;
        }
        interface SyntheticExpression extends Expression {
            readonly kind: SyntaxKind.SyntheticExpression;
            readonly isSpread: boolean;
            readonly type: Type;
            readonly tupleNameSource?: ParameterDeclaration | NamedTupleMember;
        }
        type ExponentiationOperator = SyntaxKind.AsteriskAsteriskToken;
        type MultiplicativeOperator = SyntaxKind.AsteriskToken | SyntaxKind.SlashToken | SyntaxKind.PercentToken;
        type MultiplicativeOperatorOrHigher = ExponentiationOperator | MultiplicativeOperator;
        type AdditiveOperator = SyntaxKind.PlusToken | SyntaxKind.MinusToken;
        type AdditiveOperatorOrHigher = MultiplicativeOperatorOrHigher | AdditiveOperator;
        type ShiftOperator = SyntaxKind.LessThanLessThanToken | SyntaxKind.GreaterThanGreaterThanToken | SyntaxKind.GreaterThanGreaterThanGreaterThanToken;
        type ShiftOperatorOrHigher = AdditiveOperatorOrHigher | ShiftOperator;
        type RelationalOperator = SyntaxKind.LessThanToken | SyntaxKind.LessThanEqualsToken | SyntaxKind.GreaterThanToken | SyntaxKind.GreaterThanEqualsToken | SyntaxKind.InstanceOfKeyword | SyntaxKind.InKeyword;
        type RelationalOperatorOrHigher = ShiftOperatorOrHigher | RelationalOperator;
        type EqualityOperator = SyntaxKind.EqualsEqualsToken | SyntaxKind.EqualsEqualsEqualsToken | SyntaxKind.ExclamationEqualsEqualsToken | SyntaxKind.ExclamationEqualsToken;
        type EqualityOperatorOrHigher = RelationalOperatorOrHigher | EqualityOperator;
        type BitwiseOperator = SyntaxKind.AmpersandToken | SyntaxKind.BarToken | SyntaxKind.CaretToken;
        type BitwiseOperatorOrHigher = EqualityOperatorOrHigher | BitwiseOperator;
        type LogicalOperator = SyntaxKind.AmpersandAmpersandToken | SyntaxKind.BarBarToken;
        type LogicalOperatorOrHigher = BitwiseOperatorOrHigher | LogicalOperator;
        type CompoundAssignmentOperator = SyntaxKind.PlusEqualsToken | SyntaxKind.MinusEqualsToken | SyntaxKind.AsteriskAsteriskEqualsToken | SyntaxKind.AsteriskEqualsToken | SyntaxKind.SlashEqualsToken | SyntaxKind.PercentEqualsToken | SyntaxKind.AmpersandEqualsToken | SyntaxKind.BarEqualsToken | SyntaxKind.CaretEqualsToken | SyntaxKind.LessThanLessThanEqualsToken | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken | SyntaxKind.GreaterThanGreaterThanEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;
        type AssignmentOperator = SyntaxKind.EqualsToken | CompoundAssignmentOperator;
        type AssignmentOperatorOrHigher = SyntaxKind.QuestionQuestionToken | LogicalOperatorOrHigher | AssignmentOperator;
        type BinaryOperator = AssignmentOperatorOrHigher | SyntaxKind.CommaToken;
        type LogicalOrCoalescingAssignmentOperator = SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;
        type BinaryOperatorToken = Token<BinaryOperator>;
        interface BinaryExpression extends Expression, Declaration, JSDocContainer {
            readonly kind: SyntaxKind.BinaryExpression;
            readonly left: Expression;
            readonly operatorToken: BinaryOperatorToken;
            readonly right: Expression;
        }
        type AssignmentOperatorToken = Token<AssignmentOperator>;
        interface AssignmentExpression<TOperator extends AssignmentOperatorToken> extends BinaryExpression {
            readonly left: LeftHandSideExpression;
            readonly operatorToken: TOperator;
        }
        interface ObjectDestructuringAssignment extends AssignmentExpression<EqualsToken> {
            readonly left: ObjectLiteralExpression;
        }
        interface ArrayDestructuringAssignment extends AssignmentExpression<EqualsToken> {
            readonly left: ArrayLiteralExpression;
        }
        type DestructuringAssignment = ObjectDestructuringAssignment | ArrayDestructuringAssignment;
        type BindingOrAssignmentElement = VariableDeclaration | ParameterDeclaration | ObjectBindingOrAssignmentElement | ArrayBindingOrAssignmentElement;
        type ObjectBindingOrAssignmentElement = BindingElement | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment;
        type ObjectAssignmentElement = Exclude<ObjectBindingOrAssignmentElement, BindingElement>;
        type ArrayBindingOrAssignmentElement = BindingElement | OmittedExpression | SpreadElement | ArrayLiteralExpression | ObjectLiteralExpression | AssignmentExpression<EqualsToken> | Identifier | PropertyAccessExpression | ElementAccessExpression;
        type ArrayAssignmentElement = Exclude<ArrayBindingOrAssignmentElement, BindingElement>;
        type BindingOrAssignmentElementRestIndicator = DotDotDotToken | SpreadElement | SpreadAssignment;
        type BindingOrAssignmentElementTarget = BindingOrAssignmentPattern | Identifier | PropertyAccessExpression | ElementAccessExpression | OmittedExpression;
        type AssignmentElementTarget = Exclude<BindingOrAssignmentElementTarget, BindingPattern>;
        type ObjectBindingOrAssignmentPattern = ObjectBindingPattern | ObjectLiteralExpression;
        type ArrayBindingOrAssignmentPattern = ArrayBindingPattern | ArrayLiteralExpression;
        type AssignmentPattern = ObjectLiteralExpression | ArrayLiteralExpression;
        type BindingOrAssignmentPattern = ObjectBindingOrAssignmentPattern | ArrayBindingOrAssignmentPattern;
        interface ConditionalExpression extends Expression {
            readonly kind: SyntaxKind.ConditionalExpression;
            readonly condition: Expression;
            readonly questionToken: QuestionToken;
            readonly whenTrue: Expression;
            readonly colonToken: ColonToken;
            readonly whenFalse: Expression;
            flowNodeWhenTrue: FlowNode | undefined;
            flowNodeWhenFalse: FlowNode | undefined;
        }
        type FunctionBody = Block;
        type ConciseBody = FunctionBody | Expression;
        interface FunctionExpression extends PrimaryExpression, FunctionLikeDeclarationBase, JSDocContainer, LocalsContainer, FlowContainer {
            readonly kind: SyntaxKind.FunctionExpression;
            readonly modifiers?: NodeArray<Modifier>;
            readonly name?: Identifier;
            readonly body: FunctionBody;
        }
        interface ArrowFunction extends Expression, FunctionLikeDeclarationBase, JSDocContainer, LocalsContainer, FlowContainer {
            readonly kind: SyntaxKind.ArrowFunction;
            readonly modifiers?: NodeArray<Modifier>;
            readonly equalsGreaterThanToken: EqualsGreaterThanToken;
            readonly body: ConciseBody;
            readonly name: never;
        }
        interface LiteralLikeNode extends Node {
            text: string;
            isUnterminated?: boolean;
            hasExtendedUnicodeEscape?: boolean;
        }
        interface TemplateLiteralLikeNode extends LiteralLikeNode {
            rawText?: string;
            templateFlags?: TokenFlags;
        }
        interface LiteralExpression extends LiteralLikeNode, PrimaryExpression {
            _literalExpressionBrand: any;
        }
        interface RegularExpressionLiteral extends LiteralExpression {
            readonly kind: SyntaxKind.RegularExpressionLiteral;
        }
        enum RegularExpressionFlags {
            None = 0,
            HasIndices = 1,
            Global = 2,
            IgnoreCase = 4,
            Multiline = 8,
            DotAll = 16,
            Unicode = 32,
            UnicodeSets = 64,
            Sticky = 128,
            AnyUnicodeMode = 96,
            Modifiers = 28
        }
        interface NoSubstitutionTemplateLiteral extends LiteralExpression, TemplateLiteralLikeNode, Declaration {
            readonly kind: SyntaxKind.NoSubstitutionTemplateLiteral;
            templateFlags?: TokenFlags;
        }
        enum TokenFlags {
            None = 0,
            PrecedingLineBreak = 1,
            PrecedingJSDocComment = 2,
            Unterminated = 4,
            ExtendedUnicodeEscape = 8,
            Scientific = 16,
            Octal = 32,
            HexSpecifier = 64,
            BinarySpecifier = 128,
            OctalSpecifier = 256,
            ContainsSeparator = 512,
            UnicodeEscape = 1024,
            ContainsInvalidEscape = 2048,
            HexEscape = 4096,
            ContainsLeadingZero = 8192,
            ContainsInvalidSeparator = 16384,
            PrecedingJSDocLeadingAsterisks = 32768,
            BinaryOrOctalSpecifier = 384,
            WithSpecifier = 448,
            StringLiteralFlags = 7176,
            NumericLiteralFlags = 25584,
            TemplateLiteralLikeFlags = 7176,
            IsInvalid = 26656
        }
        interface NumericLiteral extends LiteralExpression, Declaration {
            readonly kind: SyntaxKind.NumericLiteral;
            readonly numericLiteralFlags: TokenFlags;
        }
        interface BigIntLiteral extends LiteralExpression {
            readonly kind: SyntaxKind.BigIntLiteral;
        }
        type LiteralToken = NumericLiteral | BigIntLiteral | StringLiteral | JsxText | RegularExpressionLiteral | NoSubstitutionTemplateLiteral;
        interface TemplateHead extends TemplateLiteralLikeNode {
            readonly kind: SyntaxKind.TemplateHead;
            readonly parent: TemplateExpression | TemplateLiteralTypeNode;
            templateFlags?: TokenFlags;
        }
        interface TemplateMiddle extends TemplateLiteralLikeNode {
            readonly kind: SyntaxKind.TemplateMiddle;
            readonly parent: TemplateSpan | TemplateLiteralTypeSpan;
            templateFlags?: TokenFlags;
        }
        interface TemplateTail extends TemplateLiteralLikeNode {
            readonly kind: SyntaxKind.TemplateTail;
            readonly parent: TemplateSpan | TemplateLiteralTypeSpan;
            templateFlags?: TokenFlags;
        }
        type PseudoLiteralToken = TemplateHead | TemplateMiddle | TemplateTail;
        type TemplateLiteralToken = NoSubstitutionTemplateLiteral | PseudoLiteralToken;
        interface TemplateExpression extends PrimaryExpression {
            readonly kind: SyntaxKind.TemplateExpression;
            readonly head: TemplateHead;
            readonly templateSpans: NodeArray<TemplateSpan>;
        }
        type TemplateLiteral = TemplateExpression | NoSubstitutionTemplateLiteral;
        interface TemplateSpan extends Node {
            readonly kind: SyntaxKind.TemplateSpan;
            readonly parent: TemplateExpression;
            readonly expression: Expression;
            readonly literal: TemplateMiddle | TemplateTail;
        }
        interface ParenthesizedExpression extends PrimaryExpression, JSDocContainer {
            readonly kind: SyntaxKind.ParenthesizedExpression;
            readonly expression: Expression;
        }
        interface JSDocTypeAssertion extends ParenthesizedExpression {
            readonly _jsDocTypeAssertionBrand: never;
        }
        interface ArrayLiteralExpression extends PrimaryExpression {
            readonly kind: SyntaxKind.ArrayLiteralExpression;
            readonly elements: NodeArray<Expression>;
            multiLine?: boolean;
        }
        interface SpreadElement extends Expression {
            readonly kind: SyntaxKind.SpreadElement;
            readonly parent: ArrayLiteralExpression | CallExpression | NewExpression;
            readonly expression: Expression;
        }
        interface ObjectLiteralExpressionBase<T extends ObjectLiteralElement> extends PrimaryExpression, Declaration {
            readonly properties: NodeArray<T>;
        }
        interface ObjectLiteralExpression extends ObjectLiteralExpressionBase<ObjectLiteralElementLike>, JSDocContainer {
            readonly kind: SyntaxKind.ObjectLiteralExpression;
            multiLine?: boolean;
        }
        type EntityNameExpression = Identifier | PropertyAccessEntityNameExpression;
        type EntityNameOrEntityNameExpression = EntityName | EntityNameExpression;
        type AccessExpression = PropertyAccessExpression | ElementAccessExpression;
        interface PropertyAccessExpression extends MemberExpression, NamedDeclaration, JSDocContainer, FlowContainer {
            readonly kind: SyntaxKind.PropertyAccessExpression;
            readonly expression: LeftHandSideExpression;
            readonly questionDotToken?: QuestionDotToken;
            readonly name: MemberName;
        }
        interface PrivateIdentifierPropertyAccessExpression extends PropertyAccessExpression {
            readonly name: PrivateIdentifier;
        }
        interface PropertyAccessChain extends PropertyAccessExpression {
            _optionalChainBrand: any;
            readonly name: MemberName;
        }
        interface PropertyAccessChainRoot extends PropertyAccessChain {
            readonly questionDotToken: QuestionDotToken;
        }
        interface SuperPropertyAccessExpression extends PropertyAccessExpression {
            readonly expression: SuperExpression;
        }
        interface PropertyAccessEntityNameExpression extends PropertyAccessExpression {
            _propertyAccessExpressionLikeQualifiedNameBrand?: any;
            readonly expression: EntityNameExpression;
            readonly name: Identifier;
        }
        interface ElementAccessExpression extends MemberExpression, Declaration, JSDocContainer, FlowContainer {
            readonly kind: SyntaxKind.ElementAccessExpression;
            readonly expression: LeftHandSideExpression;
            readonly questionDotToken?: QuestionDotToken;
            readonly argumentExpression: Expression;
        }
        interface ElementAccessChain extends ElementAccessExpression {
            _optionalChainBrand: any;
        }
        interface ElementAccessChainRoot extends ElementAccessChain {
            readonly questionDotToken: QuestionDotToken;
        }
        interface SuperElementAccessExpression extends ElementAccessExpression {
            readonly expression: SuperExpression;
        }
        type SuperProperty = SuperPropertyAccessExpression | SuperElementAccessExpression;
        interface CallExpression extends LeftHandSideExpression, Declaration {
            readonly kind: SyntaxKind.CallExpression;
            readonly expression: LeftHandSideExpression;
            readonly questionDotToken?: QuestionDotToken;
            readonly typeArguments?: NodeArray<TypeNode>;
            readonly arguments: NodeArray<Expression>;
        }
        interface CallChain extends CallExpression {
            _optionalChainBrand: any;
        }
        interface CallChainRoot extends CallChain {
            readonly questionDotToken: QuestionDotToken;
        }
        type OptionalChain = PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;
        type OptionalChainRoot = PropertyAccessChainRoot | ElementAccessChainRoot | CallChainRoot;
        type BindableObjectDefinePropertyCall = CallExpression & {
            readonly arguments: readonly [
                BindableStaticNameExpression,
                StringLiteralLike | NumericLiteral,
                ObjectLiteralExpression
            ] & Readonly<TextRange>;
        };
        type BindableStaticNameExpression = EntityNameExpression | BindableStaticElementAccessExpression;
        type LiteralLikeElementAccessExpression = ElementAccessExpression & Declaration & {
            readonly argumentExpression: StringLiteralLike | NumericLiteral;
        };
        type BindableStaticElementAccessExpression = LiteralLikeElementAccessExpression & {
            readonly expression: BindableStaticNameExpression;
        };
        type BindableElementAccessExpression = ElementAccessExpression & {
            readonly expression: BindableStaticNameExpression;
        };
        type BindableStaticAccessExpression = PropertyAccessEntityNameExpression | BindableStaticElementAccessExpression;
        type BindableAccessExpression = PropertyAccessEntityNameExpression | BindableElementAccessExpression;
        interface BindableStaticPropertyAssignmentExpression extends BinaryExpression {
            readonly left: BindableStaticAccessExpression;
        }
        interface BindablePropertyAssignmentExpression extends BinaryExpression {
            readonly left: BindableAccessExpression;
        }
        interface SuperCall extends CallExpression {
            readonly expression: SuperExpression;
        }
        interface ImportCall extends CallExpression {
            readonly expression: ImportExpression;
        }
        interface ExpressionWithTypeArguments extends MemberExpression, NodeWithTypeArguments {
            readonly kind: SyntaxKind.ExpressionWithTypeArguments;
            readonly expression: LeftHandSideExpression;
        }
        interface NewExpression extends PrimaryExpression, Declaration {
            readonly kind: SyntaxKind.NewExpression;
            readonly expression: LeftHandSideExpression;
            readonly typeArguments?: NodeArray<TypeNode>;
            readonly arguments?: NodeArray<Expression>;
        }
        interface TaggedTemplateExpression extends MemberExpression {
            readonly kind: SyntaxKind.TaggedTemplateExpression;
            readonly tag: LeftHandSideExpression;
            readonly typeArguments?: NodeArray<TypeNode>;
            readonly template: TemplateLiteral;
            questionDotToken?: QuestionDotToken;
        }
        interface InstanceofExpression extends BinaryExpression {
            readonly operatorToken: Token<SyntaxKind.InstanceOfKeyword>;
        }
        type CallLikeExpression = CallExpression | NewExpression | TaggedTemplateExpression | Decorator | JsxCallLike | InstanceofExpression;
        interface AsExpression extends Expression {
            readonly kind: SyntaxKind.AsExpression;
            readonly expression: Expression;
            readonly type: TypeNode;
        }
        interface TypeAssertion extends UnaryExpression {
            readonly kind: SyntaxKind.TypeAssertionExpression;
            readonly type: TypeNode;
            readonly expression: UnaryExpression;
        }
        interface SatisfiesExpression extends Expression {
            readonly kind: SyntaxKind.SatisfiesExpression;
            readonly expression: Expression;
            readonly type: TypeNode;
        }
        type AssertionExpression = TypeAssertion | AsExpression;
        interface NonNullExpression extends LeftHandSideExpression {
            readonly kind: SyntaxKind.NonNullExpression;
            readonly expression: Expression;
        }
        interface NonNullChain extends NonNullExpression {
            _optionalChainBrand: any;
        }
        interface MetaProperty extends PrimaryExpression, FlowContainer {
            readonly kind: SyntaxKind.MetaProperty;
            readonly keywordToken: SyntaxKind.NewKeyword | SyntaxKind.ImportKeyword;
            readonly name: Identifier;
        }
        interface ImportMetaProperty extends MetaProperty {
            readonly keywordToken: SyntaxKind.ImportKeyword;
            readonly name: Identifier & {
                readonly escapedText: __String & "meta";
            };
        }
        interface JsxElement extends PrimaryExpression {
            readonly kind: SyntaxKind.JsxElement;
            readonly openingElement: JsxOpeningElement;
            readonly children: NodeArray<JsxChild>;
            readonly closingElement: JsxClosingElement;
        }
        type JsxOpeningLikeElement = JsxSelfClosingElement | JsxOpeningElement;
        type JsxCallLike = JsxOpeningLikeElement | JsxOpeningFragment;
        type JsxAttributeLike = JsxAttribute | JsxSpreadAttribute;
        type JsxAttributeName = Identifier | JsxNamespacedName;
        type JsxTagNameExpression = Identifier | ThisExpression | JsxTagNamePropertyAccess | JsxNamespacedName;
        interface JsxTagNamePropertyAccess extends PropertyAccessExpression {
            readonly expression: Identifier | ThisExpression | JsxTagNamePropertyAccess;
        }
        interface JsxAttributes extends PrimaryExpression, Declaration {
            readonly properties: NodeArray<JsxAttributeLike>;
            readonly kind: SyntaxKind.JsxAttributes;
            readonly parent: JsxOpeningLikeElement;
        }
        interface JsxNamespacedName extends Node {
            readonly kind: SyntaxKind.JsxNamespacedName;
            readonly name: Identifier;
            readonly namespace: Identifier;
        }
        interface JsxOpeningElement extends Expression {
            readonly kind: SyntaxKind.JsxOpeningElement;
            readonly parent: JsxElement;
            readonly tagName: JsxTagNameExpression;
            readonly typeArguments?: NodeArray<TypeNode>;
            readonly attributes: JsxAttributes;
        }
        interface JsxSelfClosingElement extends PrimaryExpression {
            readonly kind: SyntaxKind.JsxSelfClosingElement;
            readonly tagName: JsxTagNameExpression;
            readonly typeArguments?: NodeArray<TypeNode>;
            readonly attributes: JsxAttributes;
        }
        interface JsxFragment extends PrimaryExpression {
            readonly kind: SyntaxKind.JsxFragment;
            readonly openingFragment: JsxOpeningFragment;
            readonly children: NodeArray<JsxChild>;
            readonly closingFragment: JsxClosingFragment;
        }
        interface JsxOpeningFragment extends Expression {
            readonly kind: SyntaxKind.JsxOpeningFragment;
            readonly parent: JsxFragment;
        }
        interface JsxClosingFragment extends Expression {
            readonly kind: SyntaxKind.JsxClosingFragment;
            readonly parent: JsxFragment;
        }
        interface JsxAttribute extends Declaration {
            readonly kind: SyntaxKind.JsxAttribute;
            readonly parent: JsxAttributes;
            readonly name: JsxAttributeName;
            readonly initializer?: JsxAttributeValue;
        }
        type JsxAttributeValue = StringLiteral | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;
        interface JsxSpreadAttribute extends ObjectLiteralElement {
            readonly kind: SyntaxKind.JsxSpreadAttribute;
            readonly parent: JsxAttributes;
            readonly expression: Expression;
        }
        interface JsxClosingElement extends Node {
            readonly kind: SyntaxKind.JsxClosingElement;
            readonly parent: JsxElement;
            readonly tagName: JsxTagNameExpression;
        }
        interface JsxExpression extends Expression {
            readonly kind: SyntaxKind.JsxExpression;
            readonly parent: JsxElement | JsxFragment | JsxAttributeLike;
            readonly dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;
            readonly expression?: Expression;
        }
        interface JsxText extends LiteralLikeNode {
            readonly kind: SyntaxKind.JsxText;
            readonly parent: JsxElement | JsxFragment;
            readonly containsOnlyTriviaWhiteSpaces: boolean;
        }
        type JsxChild = JsxText | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;
        interface Statement extends Node, JSDocContainer {
            _statementBrand: any;
        }
        interface NotEmittedStatement extends Statement {
            readonly kind: SyntaxKind.NotEmittedStatement;
        }
        interface NotEmittedTypeElement extends TypeElement {
            readonly kind: SyntaxKind.NotEmittedTypeElement;
        }
        interface CommaListExpression extends Expression {
            readonly kind: SyntaxKind.CommaListExpression;
            readonly elements: NodeArray<Expression>;
        }
        interface SyntheticReferenceExpression extends LeftHandSideExpression {
            readonly kind: SyntaxKind.SyntheticReferenceExpression;
            readonly expression: Expression;
            readonly thisArg: Expression;
        }
        interface EmptyStatement extends Statement {
            readonly kind: SyntaxKind.EmptyStatement;
        }
        interface DebuggerStatement extends Statement, FlowContainer {
            readonly kind: SyntaxKind.DebuggerStatement;
        }
        interface MissingDeclaration extends DeclarationStatement, PrimaryExpression {
            readonly kind: SyntaxKind.MissingDeclaration;
            readonly name?: Identifier;
            readonly modifiers?: NodeArray<ModifierLike> | undefined;
        }
        type BlockLike = SourceFile | Block | ModuleBlock | CaseOrDefaultClause;
        interface Block extends Statement, LocalsContainer {
            readonly kind: SyntaxKind.Block;
            readonly statements: NodeArray<Statement>;
            multiLine?: boolean;
        }
        interface VariableStatement extends Statement, FlowContainer {
            readonly kind: SyntaxKind.VariableStatement;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly declarationList: VariableDeclarationList;
        }
        interface ExpressionStatement extends Statement, FlowContainer {
            readonly kind: SyntaxKind.ExpressionStatement;
            readonly expression: Expression;
        }
        interface PrologueDirective extends ExpressionStatement {
            readonly expression: StringLiteral;
        }
        interface IfStatement extends Statement, FlowContainer {
            readonly kind: SyntaxKind.IfStatement;
            readonly expression: Expression;
            readonly thenStatement: Statement;
            readonly elseStatement?: Statement;
        }
        interface IterationStatement extends Statement {
            readonly statement: Statement;
        }
        interface DoStatement extends IterationStatement, FlowContainer {
            readonly kind: SyntaxKind.DoStatement;
            readonly expression: Expression;
        }
        interface WhileStatement extends IterationStatement, FlowContainer {
            readonly kind: SyntaxKind.WhileStatement;
            readonly expression: Expression;
        }
        type ForInitializer = VariableDeclarationList | Expression;
        interface ForStatement extends IterationStatement, LocalsContainer, FlowContainer {
            readonly kind: SyntaxKind.ForStatement;
            readonly initializer?: ForInitializer;
            readonly condition?: Expression;
            readonly incrementor?: Expression;
        }
        type ForInOrOfStatement = ForInStatement | ForOfStatement;
        interface ForInStatement extends IterationStatement, LocalsContainer, FlowContainer {
            readonly kind: SyntaxKind.ForInStatement;
            readonly initializer: ForInitializer;
            readonly expression: Expression;
        }
        interface ForOfStatement extends IterationStatement, LocalsContainer, FlowContainer {
            readonly kind: SyntaxKind.ForOfStatement;
            readonly awaitModifier?: AwaitKeyword;
            readonly initializer: ForInitializer;
            readonly expression: Expression;
        }
        interface BreakStatement extends Statement, FlowContainer {
            readonly kind: SyntaxKind.BreakStatement;
            readonly label?: Identifier;
        }
        interface ContinueStatement extends Statement, FlowContainer {
            readonly kind: SyntaxKind.ContinueStatement;
            readonly label?: Identifier;
        }
        type BreakOrContinueStatement = BreakStatement | ContinueStatement;
        interface ReturnStatement extends Statement, FlowContainer {
            readonly kind: SyntaxKind.ReturnStatement;
            readonly expression?: Expression;
        }
        interface WithStatement extends Statement, FlowContainer {
            readonly kind: SyntaxKind.WithStatement;
            readonly expression: Expression;
            readonly statement: Statement;
        }
        interface SwitchStatement extends Statement, FlowContainer {
            readonly kind: SyntaxKind.SwitchStatement;
            readonly expression: Expression;
            readonly caseBlock: CaseBlock;
            possiblyExhaustive?: boolean;
        }
        interface CaseBlock extends Node, LocalsContainer {
            readonly kind: SyntaxKind.CaseBlock;
            readonly parent: SwitchStatement;
            readonly clauses: NodeArray<CaseOrDefaultClause>;
        }
        interface CaseClause extends Node, JSDocContainer {
            readonly kind: SyntaxKind.CaseClause;
            readonly parent: CaseBlock;
            readonly expression: Expression;
            readonly statements: NodeArray<Statement>;
            fallthroughFlowNode?: FlowNode;
        }
        interface DefaultClause extends Node {
            readonly kind: SyntaxKind.DefaultClause;
            readonly parent: CaseBlock;
            readonly statements: NodeArray<Statement>;
            fallthroughFlowNode?: FlowNode;
        }
        type CaseOrDefaultClause = CaseClause | DefaultClause;
        interface LabeledStatement extends Statement, FlowContainer {
            readonly kind: SyntaxKind.LabeledStatement;
            readonly label: Identifier;
            readonly statement: Statement;
        }
        interface ThrowStatement extends Statement, FlowContainer {
            readonly kind: SyntaxKind.ThrowStatement;
            readonly expression: Expression;
        }
        interface TryStatement extends Statement, FlowContainer {
            readonly kind: SyntaxKind.TryStatement;
            readonly tryBlock: Block;
            readonly catchClause?: CatchClause;
            readonly finallyBlock?: Block;
        }
        interface CatchClause extends Node, LocalsContainer {
            readonly kind: SyntaxKind.CatchClause;
            readonly parent: TryStatement;
            readonly variableDeclaration?: VariableDeclaration;
            readonly block: Block;
        }
        type ObjectTypeDeclaration = ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode;
        type DeclarationWithTypeParameters = DeclarationWithTypeParameterChildren | JSDocTypedefTag | JSDocCallbackTag | JSDocSignature;
        type DeclarationWithTypeParameterChildren = SignatureDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | JSDocTemplateTag;
        interface ClassLikeDeclarationBase extends NamedDeclaration, JSDocContainer {
            readonly kind: SyntaxKind.ClassDeclaration | SyntaxKind.ClassExpression;
            readonly name?: Identifier;
            readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
            readonly heritageClauses?: NodeArray<HeritageClause>;
            readonly members: NodeArray<ClassElement>;
        }
        interface ClassDeclaration extends ClassLikeDeclarationBase, DeclarationStatement {
            readonly kind: SyntaxKind.ClassDeclaration;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly name?: Identifier;
        }
        interface ClassExpression extends ClassLikeDeclarationBase, PrimaryExpression {
            readonly kind: SyntaxKind.ClassExpression;
            readonly modifiers?: NodeArray<ModifierLike>;
        }
        type ClassLikeDeclaration = ClassDeclaration | ClassExpression;
        interface ClassElement extends NamedDeclaration {
            _classElementBrand: any;
            readonly name?: PropertyName;
        }
        interface TypeElement extends NamedDeclaration {
            _typeElementBrand: any;
            readonly name?: PropertyName;
            readonly questionToken?: QuestionToken | undefined;
        }
        interface InterfaceDeclaration extends DeclarationStatement, JSDocContainer {
            readonly kind: SyntaxKind.InterfaceDeclaration;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly name: Identifier;
            readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
            readonly heritageClauses?: NodeArray<HeritageClause>;
            readonly members: NodeArray<TypeElement>;
        }
        interface HeritageClause extends Node {
            readonly kind: SyntaxKind.HeritageClause;
            readonly parent: InterfaceDeclaration | ClassLikeDeclaration;
            readonly token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword;
            readonly types: NodeArray<ExpressionWithTypeArguments>;
        }
        interface TypeAliasDeclaration extends DeclarationStatement, JSDocContainer, LocalsContainer {
            readonly kind: SyntaxKind.TypeAliasDeclaration;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly name: Identifier;
            readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
            readonly type: TypeNode;
        }
        interface EnumMember extends NamedDeclaration, JSDocContainer {
            readonly kind: SyntaxKind.EnumMember;
            readonly parent: EnumDeclaration;
            readonly name: PropertyName;
            readonly initializer?: Expression;
        }
        interface EnumDeclaration extends DeclarationStatement, JSDocContainer {
            readonly kind: SyntaxKind.EnumDeclaration;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly name: Identifier;
            readonly members: NodeArray<EnumMember>;
        }
        type ModuleName = Identifier | StringLiteral;
        type ModuleBody = NamespaceBody | JSDocNamespaceBody;
        interface AmbientModuleDeclaration extends ModuleDeclaration {
            readonly body?: ModuleBlock;
        }
        interface ModuleDeclaration extends DeclarationStatement, JSDocContainer, LocalsContainer {
            readonly kind: SyntaxKind.ModuleDeclaration;
            readonly parent: ModuleBody | SourceFile;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly name: ModuleName;
            readonly body?: ModuleBody | JSDocNamespaceDeclaration;
        }
        type NamespaceBody = ModuleBlock | NamespaceDeclaration;
        interface NamespaceDeclaration extends ModuleDeclaration {
            readonly name: Identifier;
            readonly body: NamespaceBody;
        }
        type JSDocNamespaceBody = Identifier | JSDocNamespaceDeclaration;
        interface JSDocNamespaceDeclaration extends ModuleDeclaration {
            readonly name: Identifier;
            readonly body?: JSDocNamespaceBody;
        }
        interface ModuleBlock extends Node, Statement {
            readonly kind: SyntaxKind.ModuleBlock;
            readonly parent: ModuleDeclaration;
            readonly statements: NodeArray<Statement>;
        }
        type ModuleReference = EntityName | ExternalModuleReference;
        interface ImportEqualsDeclaration extends DeclarationStatement, JSDocContainer {
            readonly kind: SyntaxKind.ImportEqualsDeclaration;
            readonly parent: SourceFile | ModuleBlock;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly name: Identifier;
            readonly isTypeOnly: boolean;
            readonly moduleReference: ModuleReference;
        }
        interface ExternalModuleReference extends Node {
            readonly kind: SyntaxKind.ExternalModuleReference;
            readonly parent: ImportEqualsDeclaration;
            readonly expression: Expression;
        }
        interface ImportDeclaration extends Statement {
            readonly kind: SyntaxKind.ImportDeclaration;
            readonly parent: SourceFile | ModuleBlock;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly importClause?: ImportClause;
            readonly moduleSpecifier: Expression;
            readonly assertClause?: AssertClause;
            readonly attributes?: ImportAttributes;
        }
        type NamedImportBindings = NamespaceImport | NamedImports;
        type NamedExportBindings = NamespaceExport | NamedExports;
        interface ImportClause extends NamedDeclaration {
            readonly kind: SyntaxKind.ImportClause;
            readonly parent: ImportDeclaration | JSDocImportTag;
            readonly isTypeOnly: boolean;
            readonly name?: Identifier;
            readonly namedBindings?: NamedImportBindings;
        }
        type AssertionKey = ImportAttributeName;
        interface AssertEntry extends ImportAttribute {
        }
        interface AssertClause extends ImportAttributes {
        }
        type ImportAttributeName = Identifier | StringLiteral;
        interface ImportAttribute extends Node {
            readonly kind: SyntaxKind.ImportAttribute;
            readonly parent: ImportAttributes;
            readonly name: ImportAttributeName;
            readonly value: Expression;
        }
        interface ImportAttributes extends Node {
            readonly token: SyntaxKind.WithKeyword | SyntaxKind.AssertKeyword;
            readonly kind: SyntaxKind.ImportAttributes;
            readonly parent: ImportDeclaration | ExportDeclaration;
            readonly elements: NodeArray<ImportAttribute>;
            readonly multiLine?: boolean;
        }
        interface NamespaceImport extends NamedDeclaration {
            readonly kind: SyntaxKind.NamespaceImport;
            readonly parent: ImportClause;
            readonly name: Identifier;
        }
        interface NamespaceExport extends NamedDeclaration {
            readonly kind: SyntaxKind.NamespaceExport;
            readonly parent: ExportDeclaration;
            readonly name: ModuleExportName;
        }
        interface NamespaceExportDeclaration extends DeclarationStatement, JSDocContainer {
            readonly kind: SyntaxKind.NamespaceExportDeclaration;
            readonly name: Identifier;
            readonly modifiers?: NodeArray<ModifierLike> | undefined;
        }
        interface ExportDeclaration extends DeclarationStatement, JSDocContainer {
            readonly kind: SyntaxKind.ExportDeclaration;
            readonly parent: SourceFile | ModuleBlock;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly isTypeOnly: boolean;
            readonly exportClause?: NamedExportBindings;
            readonly moduleSpecifier?: Expression;
            readonly assertClause?: AssertClause;
            readonly attributes?: ImportAttributes;
        }
        interface NamedImports extends Node {
            readonly kind: SyntaxKind.NamedImports;
            readonly parent: ImportClause;
            readonly elements: NodeArray<ImportSpecifier>;
        }
        interface NamedExports extends Node {
            readonly kind: SyntaxKind.NamedExports;
            readonly parent: ExportDeclaration;
            readonly elements: NodeArray<ExportSpecifier>;
        }
        type NamedImportsOrExports = NamedImports | NamedExports;
        interface ImportSpecifier extends NamedDeclaration {
            readonly kind: SyntaxKind.ImportSpecifier;
            readonly parent: NamedImports;
            readonly propertyName?: ModuleExportName;
            readonly name: Identifier;
            readonly isTypeOnly: boolean;
        }
        interface ExportSpecifier extends NamedDeclaration, JSDocContainer {
            readonly kind: SyntaxKind.ExportSpecifier;
            readonly parent: NamedExports;
            readonly isTypeOnly: boolean;
            readonly propertyName?: ModuleExportName;
            readonly name: ModuleExportName;
        }
        type ModuleExportName = Identifier | StringLiteral;
        type ImportOrExportSpecifier = ImportSpecifier | ExportSpecifier;
        type TypeOnlyCompatibleAliasDeclaration = ImportClause | ImportEqualsDeclaration | NamespaceImport | ImportOrExportSpecifier | ExportDeclaration | NamespaceExport;
        type TypeOnlyImportDeclaration = ImportClause & {
            readonly isTypeOnly: true;
            readonly name: Identifier;
        } | ImportEqualsDeclaration & {
            readonly isTypeOnly: true;
        } | NamespaceImport & {
            readonly parent: ImportClause & {
                readonly isTypeOnly: true;
            };
        } | ImportSpecifier & ({
            readonly isTypeOnly: true;
        } | {
            readonly parent: NamedImports & {
                readonly parent: ImportClause & {
                    readonly isTypeOnly: true;
                };
            };
        });
        type TypeOnlyExportDeclaration = ExportSpecifier & ({
            readonly isTypeOnly: true;
        } | {
            readonly parent: NamedExports & {
                readonly parent: ExportDeclaration & {
                    readonly isTypeOnly: true;
                };
            };
        }) | ExportDeclaration & {
            readonly isTypeOnly: true;
            readonly moduleSpecifier: Expression;
        } | NamespaceExport & {
            readonly parent: ExportDeclaration & {
                readonly isTypeOnly: true;
                readonly moduleSpecifier: Expression;
            };
        };
        type TypeOnlyAliasDeclaration = TypeOnlyImportDeclaration | TypeOnlyExportDeclaration;
        interface ExportAssignment extends DeclarationStatement, JSDocContainer {
            readonly kind: SyntaxKind.ExportAssignment;
            readonly parent: SourceFile;
            readonly modifiers?: NodeArray<ModifierLike>;
            readonly isExportEquals?: boolean;
            readonly expression: Expression;
        }
        interface FileReference extends TextRange {
            fileName: string;
            resolutionMode?: ResolutionMode;
            preserve?: boolean;
        }
        interface CheckJsDirective extends TextRange {
            enabled: boolean;
        }
        type CommentKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia;
        interface CommentRange extends TextRange {
            hasTrailingNewLine?: boolean;
            kind: CommentKind;
        }
        interface SynthesizedComment extends CommentRange {
            text: string;
            pos: -1;
            end: -1;
            hasLeadingNewline?: boolean;
        }
        interface JSDocTypeExpression extends TypeNode {
            readonly kind: SyntaxKind.JSDocTypeExpression;
            readonly type: TypeNode;
        }
        interface JSDocNameReference extends Node {
            readonly kind: SyntaxKind.JSDocNameReference;
            readonly name: EntityName | JSDocMemberName;
        }
        interface JSDocMemberName extends Node {
            readonly kind: SyntaxKind.JSDocMemberName;
            readonly left: EntityName | JSDocMemberName;
            readonly right: Identifier;
        }
        interface JSDocType extends TypeNode {
            _jsDocTypeBrand: any;
        }
        interface JSDocAllType extends JSDocType {
            readonly kind: SyntaxKind.JSDocAllType;
        }
        interface JSDocUnknownType extends JSDocType {
            readonly kind: SyntaxKind.JSDocUnknownType;
        }
        interface JSDocNonNullableType extends JSDocType {
            readonly kind: SyntaxKind.JSDocNonNullableType;
            readonly type: TypeNode;
            readonly postfix: boolean;
        }
        interface JSDocNullableType extends JSDocType {
            readonly kind: SyntaxKind.JSDocNullableType;
            readonly type: TypeNode;
            readonly postfix: boolean;
        }
        interface JSDocOptionalType extends JSDocType {
            readonly kind: SyntaxKind.JSDocOptionalType;
            readonly type: TypeNode;
        }
        interface JSDocFunctionType extends JSDocType, SignatureDeclarationBase, LocalsContainer {
            readonly kind: SyntaxKind.JSDocFunctionType;
        }
        interface JSDocVariadicType extends JSDocType {
            readonly kind: SyntaxKind.JSDocVariadicType;
            readonly type: TypeNode;
        }
        interface JSDocNamepathType extends JSDocType {
            readonly kind: SyntaxKind.JSDocNamepathType;
            readonly type: TypeNode;
        }
        type JSDocTypeReferencingNode = JSDocVariadicType | JSDocOptionalType | JSDocNullableType | JSDocNonNullableType;
        interface JSDoc extends Node {
            readonly kind: SyntaxKind.JSDoc;
            readonly parent: HasJSDoc;
            readonly tags?: NodeArray<JSDocTag>;
            readonly comment?: string | NodeArray<JSDocComment>;
        }
        interface JSDocTag extends Node {
            readonly parent: JSDoc | JSDocTypeLiteral;
            readonly tagName: Identifier;
            readonly comment?: string | NodeArray<JSDocComment>;
        }
        interface JSDocLink extends Node {
            readonly kind: SyntaxKind.JSDocLink;
            readonly name?: EntityName | JSDocMemberName;
            text: string;
        }
        interface JSDocLinkCode extends Node {
            readonly kind: SyntaxKind.JSDocLinkCode;
            readonly name?: EntityName | JSDocMemberName;
            text: string;
        }
        interface JSDocLinkPlain extends Node {
            readonly kind: SyntaxKind.JSDocLinkPlain;
            readonly name?: EntityName | JSDocMemberName;
            text: string;
        }
        type JSDocComment = JSDocText | JSDocLink | JSDocLinkCode | JSDocLinkPlain;
        interface JSDocText extends Node {
            readonly kind: SyntaxKind.JSDocText;
            text: string;
        }
        interface JSDocUnknownTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocTag;
        }
        interface JSDocAugmentsTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocAugmentsTag;
            readonly class: ExpressionWithTypeArguments & {
                readonly expression: Identifier | PropertyAccessEntityNameExpression;
            };
        }
        interface JSDocImplementsTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocImplementsTag;
            readonly class: ExpressionWithTypeArguments & {
                readonly expression: Identifier | PropertyAccessEntityNameExpression;
            };
        }
        interface JSDocAuthorTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocAuthorTag;
        }
        interface JSDocDeprecatedTag extends JSDocTag {
            kind: SyntaxKind.JSDocDeprecatedTag;
        }
        interface JSDocClassTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocClassTag;
        }
        interface JSDocPublicTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocPublicTag;
        }
        interface JSDocPrivateTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocPrivateTag;
        }
        interface JSDocProtectedTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocProtectedTag;
        }
        interface JSDocReadonlyTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocReadonlyTag;
        }
        interface JSDocOverrideTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocOverrideTag;
        }
        interface JSDocEnumTag extends JSDocTag, Declaration, LocalsContainer {
            readonly kind: SyntaxKind.JSDocEnumTag;
            readonly parent: JSDoc;
            readonly typeExpression: JSDocTypeExpression;
        }
        interface JSDocThisTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocThisTag;
            readonly typeExpression: JSDocTypeExpression;
        }
        interface JSDocTemplateTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocTemplateTag;
            readonly constraint: JSDocTypeExpression | undefined;
            readonly typeParameters: NodeArray<TypeParameterDeclaration>;
        }
        interface JSDocSeeTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocSeeTag;
            readonly name?: JSDocNameReference;
        }
        interface JSDocReturnTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocReturnTag;
            readonly typeExpression?: JSDocTypeExpression;
        }
        interface JSDocTypeTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocTypeTag;
            readonly typeExpression: JSDocTypeExpression;
        }
        interface JSDocTypedefTag extends JSDocTag, NamedDeclaration, LocalsContainer {
            readonly kind: SyntaxKind.JSDocTypedefTag;
            readonly parent: JSDoc;
            readonly fullName?: JSDocNamespaceDeclaration | Identifier;
            readonly name?: Identifier;
            readonly typeExpression?: JSDocTypeExpression | JSDocTypeLiteral;
        }
        interface JSDocCallbackTag extends JSDocTag, NamedDeclaration, LocalsContainer {
            readonly kind: SyntaxKind.JSDocCallbackTag;
            readonly parent: JSDoc;
            readonly fullName?: JSDocNamespaceDeclaration | Identifier;
            readonly name?: Identifier;
            readonly typeExpression: JSDocSignature;
        }
        interface JSDocOverloadTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocOverloadTag;
            readonly parent: JSDoc;
            readonly typeExpression: JSDocSignature;
        }
        interface JSDocThrowsTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocThrowsTag;
            readonly typeExpression?: JSDocTypeExpression;
        }
        interface JSDocSignature extends JSDocType, Declaration, JSDocContainer, LocalsContainer {
            readonly kind: SyntaxKind.JSDocSignature;
            readonly typeParameters?: readonly JSDocTemplateTag[];
            readonly parameters: readonly JSDocParameterTag[];
            readonly type: JSDocReturnTag | undefined;
        }
        interface JSDocPropertyLikeTag extends JSDocTag, Declaration {
            readonly parent: JSDoc;
            readonly name: EntityName;
            readonly typeExpression?: JSDocTypeExpression;
            readonly isNameFirst: boolean;
            readonly isBracketed: boolean;
        }
        interface JSDocPropertyTag extends JSDocPropertyLikeTag {
            readonly kind: SyntaxKind.JSDocPropertyTag;
        }
        interface JSDocParameterTag extends JSDocPropertyLikeTag {
            readonly kind: SyntaxKind.JSDocParameterTag;
        }
        interface JSDocTypeLiteral extends JSDocType, Declaration {
            readonly kind: SyntaxKind.JSDocTypeLiteral;
            readonly jsDocPropertyTags?: readonly JSDocPropertyLikeTag[];
            readonly isArrayType: boolean;
        }
        interface JSDocSatisfiesTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocSatisfiesTag;
            readonly typeExpression: JSDocTypeExpression;
        }
        interface JSDocSatisfiesExpression extends ParenthesizedExpression {
            readonly _jsDocSatisfiesExpressionBrand: never;
        }
        interface JSDocImportTag extends JSDocTag {
            readonly kind: SyntaxKind.JSDocImportTag;
            readonly parent: JSDoc;
            readonly importClause?: ImportClause;
            readonly moduleSpecifier: Expression;
            readonly attributes?: ImportAttributes;
        }
        enum FlowFlags {
            Unreachable = 1,
            Start = 2,
            BranchLabel = 4,
            LoopLabel = 8,
            Assignment = 16,
            TrueCondition = 32,
            FalseCondition = 64,
            SwitchClause = 128,
            ArrayMutation = 256,
            Call = 512,
            ReduceLabel = 1024,
            Referenced = 2048,
            Shared = 4096,
            Label = 12,
            Condition = 96
        }
        type FlowNode = FlowUnreachable | FlowStart | FlowLabel | FlowAssignment | FlowCondition | FlowSwitchClause | FlowArrayMutation | FlowCall | FlowReduceLabel;
        interface FlowNodeBase {
            flags: FlowFlags;
            id: number;
            node: unknown;
            antecedent: FlowNode | FlowNode[] | undefined;
        }
        interface FlowUnreachable extends FlowNodeBase {
            node: undefined;
            antecedent: undefined;
        }
        interface FlowStart extends FlowNodeBase {
            node: FunctionExpression | ArrowFunction | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | undefined;
            antecedent: undefined;
        }
        interface FlowLabel extends FlowNodeBase {
            node: undefined;
            antecedent: FlowNode[] | undefined;
        }
        interface FlowAssignment extends FlowNodeBase {
            node: Expression | VariableDeclaration | BindingElement;
            antecedent: FlowNode;
        }
        interface FlowCall extends FlowNodeBase {
            node: CallExpression;
            antecedent: FlowNode;
        }
        interface FlowCondition extends FlowNodeBase {
            node: Expression;
            antecedent: FlowNode;
        }
        interface FlowSwitchClause extends FlowNodeBase {
            node: FlowSwitchClauseData;
            antecedent: FlowNode;
        }
        interface FlowSwitchClauseData {
            switchStatement: SwitchStatement;
            clauseStart: number;
            clauseEnd: number;
        }
        interface FlowArrayMutation extends FlowNodeBase {
            node: CallExpression | BinaryExpression;
            antecedent: FlowNode;
        }
        interface FlowReduceLabel extends FlowNodeBase {
            node: FlowReduceLabelData;
            antecedent: FlowNode;
        }
        interface FlowReduceLabelData {
            target: FlowLabel;
            antecedents: FlowNode[];
        }
        type FlowType = Type | IncompleteType;
        interface IncompleteType {
            flags: TypeFlags | 0;
            type: Type;
        }
        interface AmdDependency {
            path: string;
            name?: string;
        }
        interface SourceFileLike {
            readonly text: string;
            lineMap?: readonly number[];
            getPositionOfLineAndCharacter?(line: number, character: number, allowEdits?: true): number;
        }
        interface SourceFileLike {
            getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
        }
        interface FutureSourceFile {
            readonly path: Path;
            readonly fileName: string;
            readonly impliedNodeFormat?: ResolutionMode;
            readonly packageJsonScope?: PackageJsonInfo;
            readonly externalModuleIndicator?: true | undefined;
            readonly commonJsModuleIndicator?: true | undefined;
            readonly statements: readonly never[];
            readonly imports: readonly never[];
        }
        interface RedirectInfo {
            readonly redirectTarget: SourceFile;
            readonly unredirected: SourceFile;
        }
        type ResolutionMode = ModuleKind.ESNext | ModuleKind.CommonJS | undefined;
        interface SourceFile extends Declaration, LocalsContainer {
            readonly kind: SyntaxKind.SourceFile;
            readonly statements: NodeArray<Statement>;
            readonly endOfFileToken: Token<SyntaxKind.EndOfFileToken>;
            fileName: string;
            path: Path;
            text: string;
            resolvedPath: Path;
            originalFileName: string;
            redirectInfo?: RedirectInfo;
            amdDependencies: readonly AmdDependency[];
            moduleName?: string;
            referencedFiles: readonly FileReference[];
            typeReferenceDirectives: readonly FileReference[];
            libReferenceDirectives: readonly FileReference[];
            languageVariant: LanguageVariant;
            isDeclarationFile: boolean;
            renamedDependencies?: ReadonlyMap<string, string>;
            hasNoDefaultLib: boolean;
            languageVersion: ScriptTarget;
            impliedNodeFormat?: ResolutionMode;
            packageJsonLocations?: readonly string[];
            packageJsonScope?: PackageJsonInfo;
            scriptKind: ScriptKind;
            externalModuleIndicator?: Node | true;
            setExternalModuleIndicator?: (file: SourceFile) => void;
            commonJsModuleIndicator?: Node;
            jsGlobalAugmentations?: SymbolTable;
            identifiers: ReadonlyMap<string, string>;
            nodeCount: number;
            identifierCount: number;
            symbolCount: number;
            parseDiagnostics: DiagnosticWithLocation[];
            bindDiagnostics: DiagnosticWithLocation[];
            bindSuggestionDiagnostics?: DiagnosticWithLocation[];
            jsDocDiagnostics?: DiagnosticWithLocation[];
            additionalSyntacticDiagnostics?: readonly DiagnosticWithLocation[];
            lineMap: readonly number[];
            classifiableNames?: ReadonlySet<__String>;
            commentDirectives?: CommentDirective[];
            imports: readonly StringLiteralLike[];
            moduleAugmentations: readonly (StringLiteral | Identifier)[];
            patternAmbientModules?: PatternAmbientModule[];
            ambientModuleNames: readonly string[];
            checkJsDirective?: CheckJsDirective;
            version: string;
            pragmas: ReadonlyPragmaMap;
            localJsxNamespace?: __String;
            localJsxFragmentNamespace?: __String;
            localJsxFactory?: EntityName;
            localJsxFragmentFactory?: EntityName;
            endFlowNode?: FlowNode;
            jsDocParsingMode?: JSDocParsingMode;
        }
        interface SourceFile extends ReadonlyPragmaContext {
        }
        interface SourceFile {
            version: string;
            scriptSnapshot: IScriptSnapshot | undefined;
            nameTable: Map<__String, number> | undefined;
            getNamedDeclarations(): Map<string, readonly Declaration[]>;
            getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
            getLineEndOfPosition(pos: number): number;
            getLineStarts(): readonly number[];
            getPositionOfLineAndCharacter(line: number, character: number): number;
            update(newText: string, textChangeRange: TextChangeRange): SourceFile;
            sourceMapper?: DocumentPositionMapper;
        }
        interface ReadonlyPragmaContext {
            languageVersion: ScriptTarget;
            pragmas?: ReadonlyPragmaMap;
            checkJsDirective?: CheckJsDirective;
            referencedFiles: readonly FileReference[];
            typeReferenceDirectives: readonly FileReference[];
            libReferenceDirectives: readonly FileReference[];
            amdDependencies: readonly AmdDependency[];
            hasNoDefaultLib?: boolean;
            moduleName?: string;
        }
        interface PragmaContext extends ReadonlyPragmaContext {
            pragmas?: PragmaMap;
            referencedFiles: FileReference[];
            typeReferenceDirectives: FileReference[];
            libReferenceDirectives: FileReference[];
            amdDependencies: AmdDependency[];
        }
        interface CommentDirective {
            range: TextRange;
            type: CommentDirectiveType;
        }
        enum CommentDirectiveType {
            ExpectError = 0,
            Ignore = 1
        }
        interface Bundle extends Node {
            readonly kind: SyntaxKind.Bundle;
            readonly sourceFiles: readonly SourceFile[];
            syntheticFileReferences?: readonly FileReference[];
            syntheticTypeReferences?: readonly FileReference[];
            syntheticLibReferences?: readonly FileReference[];
            hasNoDefaultLib?: boolean;
        }
        interface JsonSourceFile extends SourceFile {
            readonly statements: NodeArray<JsonObjectExpressionStatement>;
        }
        interface TsConfigSourceFile extends JsonSourceFile {
            extendedSourceFiles?: string[];
            configFileSpecs?: ConfigFileSpecs;
        }
        interface JsonMinusNumericLiteral extends PrefixUnaryExpression {
            readonly kind: SyntaxKind.PrefixUnaryExpression;
            readonly operator: SyntaxKind.MinusToken;
            readonly operand: NumericLiteral;
        }
        type JsonObjectExpression = ObjectLiteralExpression | ArrayLiteralExpression | JsonMinusNumericLiteral | NumericLiteral | StringLiteral | BooleanLiteral | NullLiteral;
        interface JsonObjectExpressionStatement extends ExpressionStatement {
            readonly expression: JsonObjectExpression;
        }
        interface ScriptReferenceHost {
            getCompilerOptions(): CompilerOptions;
            getSourceFile(fileName: string): SourceFile | undefined;
            getSourceFileByPath(path: Path): SourceFile | undefined;
            getCurrentDirectory(): string;
        }
        interface ParseConfigHost extends ModuleResolutionHost {
            useCaseSensitiveFileNames: boolean;
            readDirectory(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): readonly string[];
            fileExists(path: string): boolean;
            readFile(path: string): string | undefined;
            trace?(s: string): void;
        }
        type ResolvedConfigFileName = string & {
            _isResolvedConfigFileName: never;
        };
        interface WriteFileCallbackData {
            sourceMapUrlPos?: number;
            buildInfo?: BuildInfo;
            diagnostics?: readonly DiagnosticWithLocation[];
            differsOnlyInMap?: true;
            skippedDtsWrite?: true;
        }
        type WriteFileCallback = (fileName: string, text: string, writeByteOrderMark: boolean, onError?: (message: string) => void, sourceFiles?: readonly SourceFile[], data?: WriteFileCallbackData) => void;
        class OperationCanceledException {
        }
        interface CancellationToken {
            isCancellationRequested(): boolean;
            throwIfCancellationRequested(): void;
        }
        enum FileIncludeKind {
            RootFile = 0,
            SourceFromProjectReference = 1,
            OutputFromProjectReference = 2,
            Import = 3,
            ReferenceFile = 4,
            TypeReferenceDirective = 5,
            LibFile = 6,
            LibReferenceDirective = 7,
            AutomaticTypeDirectiveFile = 8
        }
        interface RootFile {
            kind: FileIncludeKind.RootFile;
            index: number;
        }
        interface LibFile {
            kind: FileIncludeKind.LibFile;
            index?: number;
        }
        type ProjectReferenceFileKind = FileIncludeKind.SourceFromProjectReference | FileIncludeKind.OutputFromProjectReference;
        interface ProjectReferenceFile {
            kind: ProjectReferenceFileKind;
            index: number;
        }
        type ReferencedFileKind = FileIncludeKind.Import | FileIncludeKind.ReferenceFile | FileIncludeKind.TypeReferenceDirective | FileIncludeKind.LibReferenceDirective;
        interface ReferencedFile {
            kind: ReferencedFileKind;
            file: Path;
            index: number;
        }
        interface AutomaticTypeDirectiveFile {
            kind: FileIncludeKind.AutomaticTypeDirectiveFile;
            typeReference: string;
            packageId: PackageId | undefined;
        }
        type FileIncludeReason = RootFile | LibFile | ProjectReferenceFile | ReferencedFile | AutomaticTypeDirectiveFile;
        enum FilePreprocessingDiagnosticsKind {
            FilePreprocessingLibReferenceDiagnostic = 0,
            FilePreprocessingFileExplainingDiagnostic = 1,
            ResolutionDiagnostics = 2
        }
        interface FilePreprocessingLibReferenceDiagnostic {
            kind: FilePreprocessingDiagnosticsKind.FilePreprocessingLibReferenceDiagnostic;
            reason: ReferencedFile & {
                kind: FileIncludeKind.LibReferenceDirective;
            };
        }
        interface FilePreprocessingFileExplainingDiagnostic {
            kind: FilePreprocessingDiagnosticsKind.FilePreprocessingFileExplainingDiagnostic;
            file: Path | undefined;
            fileProcessingReason: FileIncludeReason;
            diagnostic: DiagnosticMessage;
            args: DiagnosticArguments;
        }
        interface ResolutionDiagnostics {
            kind: FilePreprocessingDiagnosticsKind.ResolutionDiagnostics;
            diagnostics: readonly Diagnostic[];
        }
        type FilePreprocessingDiagnostics = FilePreprocessingLibReferenceDiagnostic | FilePreprocessingFileExplainingDiagnostic | ResolutionDiagnostics;
        enum EmitOnly {
            Js = 0,
            Dts = 1,
            BuilderSignature = 2
        }
        interface LibResolution<T extends ResolvedModuleWithFailedLookupLocations = ResolvedModuleWithFailedLookupLocations> {
            resolution: T;
            actual: string;
        }
        interface Program extends ScriptReferenceHost {
            getCurrentDirectory(): string;
            getRootFileNames(): readonly string[];
            getSourceFiles(): readonly SourceFile[];
            getMissingFilePaths(): Map<Path, string>;
            getModuleResolutionCache(): ModuleResolutionCache | undefined;
            getFilesByNameMap(): Map<Path, SourceFile | false | undefined>;
            resolvedModules: Map<Path, ModeAwareCache<ResolvedModuleWithFailedLookupLocations>> | undefined;
            resolvedTypeReferenceDirectiveNames: Map<Path, ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>> | undefined;
            getResolvedModule(f: SourceFile, moduleName: string, mode: ResolutionMode): ResolvedModuleWithFailedLookupLocations | undefined;
            getResolvedModuleFromModuleSpecifier(moduleSpecifier: StringLiteralLike, sourceFile?: SourceFile): ResolvedModuleWithFailedLookupLocations | undefined;
            getResolvedTypeReferenceDirective(f: SourceFile, typeDirectiveName: string, mode: ResolutionMode): ResolvedTypeReferenceDirectiveWithFailedLookupLocations | undefined;
            getResolvedTypeReferenceDirectiveFromTypeReferenceDirective(typedRef: FileReference, sourceFile: SourceFile): ResolvedTypeReferenceDirectiveWithFailedLookupLocations | undefined;
            forEachResolvedModule(callback: (resolution: ResolvedModuleWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, file?: SourceFile): void;
            forEachResolvedTypeReferenceDirective(callback: (resolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, file?: SourceFile): void;
            emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;
            emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnly?: boolean | EmitOnly, customTransformers?: CustomTransformers, forceDtsEmit?: boolean, skipBuildInfo?: boolean): EmitResult;
            getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
            getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
            getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
            getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
            getSemanticDiagnostics(sourceFile: SourceFile | undefined, cancellationToken: CancellationToken | undefined, nodesToCheck: Node[]): readonly Diagnostic[];
            getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
            getConfigFileParsingDiagnostics(): readonly Diagnostic[];
            getSuggestionDiagnostics(sourceFile: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
            getBindAndCheckDiagnostics(sourceFile: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
            getProgramDiagnostics(sourceFile: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
            getTypeChecker(): TypeChecker;
            getCommonSourceDirectory(): string;
            getCachedSemanticDiagnostics(sourceFile: SourceFile): readonly Diagnostic[] | undefined;
            getClassifiableNames(): Set<__String>;
            getNodeCount(): number;
            getIdentifierCount(): number;
            getSymbolCount(): number;
            getTypeCount(): number;
            getInstantiationCount(): number;
            getRelationCacheSizes(): {
                assignable: number;
                identity: number;
                subtype: number;
                strictSubtype: number;
            };
            getFileProcessingDiagnostics(): FilePreprocessingDiagnostics[] | undefined;
            getAutomaticTypeDirectiveNames(): string[];
            getAutomaticTypeDirectiveResolutions(): ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>;
            isSourceFileFromExternalLibrary(file: SourceFile): boolean;
            isSourceFileDefaultLibrary(file: SourceFile): boolean;
            getModeForUsageLocation(file: SourceFile, usage: StringLiteralLike): ResolutionMode;
            getModeForResolutionAtIndex(file: SourceFile, index: number): ResolutionMode;
            getDefaultResolutionModeForFile(sourceFile: SourceFile): ResolutionMode;
            getImpliedNodeFormatForEmit(sourceFile: SourceFile): ResolutionMode;
            getEmitModuleFormatOfFile(sourceFile: SourceFile): ModuleKind;
            shouldTransformImportCall(sourceFile: SourceFile): boolean;
            readonly structureIsReused: StructureIsReused;
            getSourceFileFromReference(referencingFile: SourceFile, ref: FileReference): SourceFile | undefined;
            getLibFileFromReference(ref: FileReference): SourceFile | undefined;
            sourceFileToPackageName: Map<Path, string>;
            redirectTargetsMap: MultiMap<Path, string>;
            readonly usesUriStyleNodeCoreModules: boolean | undefined;
            resolvedLibReferences: Map<string, LibResolution> | undefined;
            getProgramDiagnosticsContainer: () => ProgramDiagnostics;
            getCurrentPackagesMap(): Map<string, boolean> | undefined;
            isEmittedFile(file: string): boolean;
            getFileIncludeReasons(): MultiMap<Path, FileIncludeReason>;
            useCaseSensitiveFileNames(): boolean;
            getCanonicalFileName: GetCanonicalFileName;
            getProjectReferences(): readonly ProjectReference[] | undefined;
            getResolvedProjectReferences(): readonly (ResolvedProjectReference | undefined)[] | undefined;
            getProjectReferenceRedirect(fileName: string): string | undefined;
            getResolvedProjectReferenceToRedirect(fileName: string): ResolvedProjectReference | undefined;
            forEachResolvedProjectReference<T>(cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined): T | undefined;
            getResolvedProjectReferenceByPath(projectReferencePath: Path): ResolvedProjectReference | undefined;
            getRedirectReferenceForResolutionFromSourceOfProject(filePath: Path): ResolvedProjectReference | undefined;
            isSourceOfProjectReferenceRedirect(fileName: string): boolean;
            getCompilerOptionsForFile(file: SourceFile): CompilerOptions;
            getBuildInfo?(): BuildInfo;
            emitBuildInfo(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken): EmitResult;
            fileExists(fileName: string): boolean;
            writeFile: WriteFileCallback;
        }
        interface Program extends TypeCheckerHost, ModuleSpecifierResolutionHost {
        }
        type RedirectTargetsMap = ReadonlyMap<Path, readonly string[]>;
        interface ResolvedProjectReference {
            commandLine: ParsedCommandLine;
            sourceFile: SourceFile;
            references?: readonly (ResolvedProjectReference | undefined)[];
        }
        enum StructureIsReused {
            Not = 0,
            SafeModules = 1,
            Completely = 2
        }
        type CustomTransformerFactory = (context: TransformationContext) => CustomTransformer;
        interface CustomTransformer {
            transformSourceFile(node: SourceFile): SourceFile;
            transformBundle(node: Bundle): Bundle;
        }
        interface CustomTransformers {
            before?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];
            after?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];
            afterDeclarations?: (TransformerFactory<Bundle | SourceFile> | CustomTransformerFactory)[];
        }
        interface EmitTransformers {
            scriptTransformers: readonly TransformerFactory<SourceFile | Bundle>[];
            declarationTransformers: readonly TransformerFactory<SourceFile | Bundle>[];
        }
        interface SourceMapSpan {
            emittedLine: number;
            emittedColumn: number;
            sourceLine: number;
            sourceColumn: number;
            nameIndex?: number;
            sourceIndex: number;
        }
        interface SourceMapEmitResult {
            inputSourceFileNames: readonly string[];
            sourceMap: RawSourceMap;
        }
        enum ExitStatus {
            Success = 0,
            DiagnosticsPresent_OutputsSkipped = 1,
            DiagnosticsPresent_OutputsGenerated = 2,
            InvalidProject_OutputsSkipped = 3,
            ProjectReferenceCycle_OutputsSkipped = 4
        }
        interface EmitResult {
            emitSkipped: boolean;
            diagnostics: readonly Diagnostic[];
            emittedFiles?: string[];
            sourceMaps?: SourceMapEmitResult[];
        }
        interface TypeCheckerHost extends ModuleSpecifierResolutionHost, SourceFileMayBeEmittedHost {
            getCompilerOptions(): CompilerOptions;
            getSourceFiles(): readonly SourceFile[];
            getSourceFile(fileName: string): SourceFile | undefined;
            getProjectReferenceRedirect(fileName: string): string | undefined;
            isSourceOfProjectReferenceRedirect(fileName: string): boolean;
            getEmitSyntaxForUsageLocation(file: SourceFile, usage: StringLiteralLike): ResolutionMode;
            getRedirectReferenceForResolutionFromSourceOfProject(filePath: Path): ResolvedProjectReference | undefined;
            getModeForUsageLocation(file: SourceFile, usage: StringLiteralLike): ResolutionMode;
            getDefaultResolutionModeForFile(sourceFile: SourceFile): ResolutionMode;
            getImpliedNodeFormatForEmit(sourceFile: SourceFile): ResolutionMode;
            getEmitModuleFormatOfFile(sourceFile: SourceFile): ModuleKind;
            getResolvedModule(f: SourceFile, moduleName: string, mode: ResolutionMode): ResolvedModuleWithFailedLookupLocations | undefined;
            readonly redirectTargetsMap: RedirectTargetsMap;
            typesPackageExists(packageName: string): boolean;
            packageBundlesTypes(packageName: string): boolean;
            isSourceFileDefaultLibrary(file: SourceFile): boolean;
        }
        interface WriterContextOut {
            canIncreaseExpansionDepth: boolean;
            truncated: boolean;
        }
        interface TypeChecker {
            getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;
            getTypeOfSymbol(symbol: Symbol): Type;
            getDeclaredTypeOfSymbol(symbol: Symbol): Type;
            getPropertiesOfType(type: Type): Symbol[];
            getPropertyOfType(type: Type, propertyName: string): Symbol | undefined;
            getPrivateIdentifierPropertyOfType(leftType: Type, name: string, location: Node): Symbol | undefined;
            getTypeOfPropertyOfType(type: Type, propertyName: string): Type | undefined;
            getIndexInfoOfType(type: Type, kind: IndexKind): IndexInfo | undefined;
            getIndexInfosOfType(type: Type): readonly IndexInfo[];
            getIndexInfosOfIndexSymbol: (indexSymbol: Symbol, siblingSymbols?: Symbol[] | undefined) => IndexInfo[];
            getSignaturesOfType(type: Type, kind: SignatureKind): readonly Signature[];
            getIndexTypeOfType(type: Type, kind: IndexKind): Type | undefined;
            getIndexType(type: Type): Type;
            getBaseTypes(type: InterfaceType): BaseType[];
            getBaseTypeOfLiteralType(type: Type): Type;
            getWidenedType(type: Type): Type;
            getWidenedLiteralType(type: Type): Type;
            getPromisedTypeOfPromise(promise: Type, errorNode?: Node): Type | undefined;
            getAwaitedType(type: Type): Type | undefined;
            isEmptyAnonymousObjectType(type: Type): boolean;
            getReturnTypeOfSignature(signature: Signature): Type;
            getParameterType(signature: Signature, parameterIndex: number): Type;
            getParameterIdentifierInfoAtPosition(signature: Signature, parameterIndex: number): {
                parameter: Identifier;
                parameterName: __String;
                isRestParameter: boolean;
            } | undefined;
            getNullableType(type: Type, flags: TypeFlags): Type;
            getNonNullableType(type: Type): Type;
            getNonOptionalType(type: Type): Type;
            isNullableType(type: Type): boolean;
            getTypeArguments(type: TypeReference): readonly Type[];
            typeToTypeNode(type: Type, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeNode | undefined;
            typeToTypeNode(type: Type, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, internalFlags?: InternalNodeBuilderFlags | undefined, tracker?: SymbolTracker): TypeNode | undefined;
            typePredicateToTypePredicateNode(typePredicate: TypePredicate, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, internalFlags?: InternalNodeBuilderFlags | undefined, tracker?: SymbolTracker): TypePredicateNode | undefined;
            signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): SignatureDeclaration & {
                typeArguments?: NodeArray<TypeNode>;
            } | undefined;
            signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, internalFlags?: InternalNodeBuilderFlags | undefined, tracker?: SymbolTracker): SignatureDeclaration & {
                typeArguments?: NodeArray<TypeNode>;
            } | undefined;
            indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): IndexSignatureDeclaration | undefined;
            indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, internalFlags?: InternalNodeBuilderFlags | undefined, tracker?: SymbolTracker): IndexSignatureDeclaration | undefined;
            symbolToEntityName(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): EntityName | undefined;
            symbolToExpression(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): Expression | undefined;
            symbolToNode(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, internalFlags: InternalNodeBuilderFlags | undefined): Node | undefined;
            symbolToTypeParameterDeclarations(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): NodeArray<TypeParameterDeclaration> | undefined;
            symbolToParameterDeclaration(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): ParameterDeclaration | undefined;
            typeParameterToDeclaration(parameter: TypeParameter, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeParameterDeclaration | undefined;
            typeParameterToDeclaration(parameter: TypeParameter, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker, verbosityLevel?: number, out?: WriterContextOut): TypeParameterDeclaration | undefined;
            getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];
            getSymbolAtLocation(node: Node): Symbol | undefined;
            getIndexInfosAtLocation(node: Node): readonly IndexInfo[] | undefined;
            getSymbolsOfParameterPropertyDeclaration(parameter: ParameterDeclaration, parameterName: string): Symbol[];
            getShorthandAssignmentValueSymbol(location: Node | undefined): Symbol | undefined;
            getExportSpecifierLocalTargetSymbol(location: ExportSpecifier | Identifier): Symbol | undefined;
            getExportSymbolOfSymbol(symbol: Symbol): Symbol;
            getPropertySymbolOfDestructuringAssignment(location: Identifier): Symbol | undefined;
            getTypeOfAssignmentPattern(pattern: AssignmentPattern): Type;
            getTypeAtLocation(node: Node): Type;
            getTypeFromTypeNode(node: TypeNode): Type;
            signatureToString(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind): string;
            typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;
            symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): string;
            typePredicateToString(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;
            writeSignature(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind, writer?: EmitTextWriter, verbosityLevel?: number, out?: WriterContextOut): string;
            writeType(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags, writer?: EmitTextWriter, verbosityLevel?: number, out?: WriterContextOut): string;
            writeSymbol(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags, writer?: EmitTextWriter): string;
            writeTypePredicate(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags, writer?: EmitTextWriter): string;
            getFullyQualifiedName(symbol: Symbol): string;
            getAugmentedPropertiesOfType(type: Type): Symbol[];
            getRootSymbols(symbol: Symbol): readonly Symbol[];
            getSymbolOfExpando(node: Node, allowDeclaration: boolean): Symbol | undefined;
            getContextualType(node: Expression): Type | undefined;
            getContextualType(node: Expression, contextFlags?: ContextFlags): Type | undefined;
            getContextualTypeForObjectLiteralElement(element: ObjectLiteralElementLike): Type | undefined;
            getContextualTypeForArgumentAtIndex(call: CallLikeExpression, argIndex: number): Type | undefined;
            getContextualTypeForJsxAttribute(attribute: JsxAttribute | JsxSpreadAttribute): Type | undefined;
            isContextSensitive(node: Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike): boolean;
            getTypeOfPropertyOfContextualType(type: Type, name: __String): Type | undefined;
            getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;
            getResolvedSignatureForSignatureHelp(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;
            getCandidateSignaturesForStringLiteralCompletions(call: CallLikeExpression, editingArgument: Node): Signature[];
            getExpandedParameters(sig: Signature): readonly (readonly Symbol[])[];
            hasEffectiveRestParameter(sig: Signature): boolean;
            containsArgumentsReference(declaration: SignatureDeclaration): boolean;
            getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature | undefined;
            isImplementationOfOverload(node: SignatureDeclaration): boolean | undefined;
            isUndefinedSymbol(symbol: Symbol): boolean;
            isArgumentsSymbol(symbol: Symbol): boolean;
            isUnknownSymbol(symbol: Symbol): boolean;
            getMergedSymbol(symbol: Symbol): Symbol;
            symbolIsValue(symbol: Symbol, includeTypeOnlyMembers?: boolean): boolean;
            getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number | undefined;
            isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName | ImportTypeNode, propertyName: string): boolean;
            isValidPropertyAccessForCompletions(node: PropertyAccessExpression | ImportTypeNode | QualifiedName, type: Type, property: Symbol): boolean;
            getAliasedSymbol(symbol: Symbol): Symbol;
            getImmediateAliasedSymbol(symbol: Symbol): Symbol | undefined;
            getExportsOfModule(moduleSymbol: Symbol): Symbol[];
            getExportsAndPropertiesOfModule(moduleSymbol: Symbol): Symbol[];
            forEachExportAndPropertyOfModule(moduleSymbol: Symbol, cb: (symbol: Symbol, key: __String) => void): void;
            getJsxIntrinsicTagNamesAt(location: Node): Symbol[];
            isOptionalParameter(node: ParameterDeclaration): boolean;
            getAmbientModules(): Symbol[];
            tryGetMemberInModuleExports(memberName: string, moduleSymbol: Symbol): Symbol | undefined;
            tryGetMemberInModuleExportsAndProperties(memberName: string, moduleSymbol: Symbol): Symbol | undefined;
            getApparentType(type: Type): Type;
            getSuggestedSymbolForNonexistentProperty(name: MemberName | string, containingType: Type): Symbol | undefined;
            getSuggestedSymbolForNonexistentJSXAttribute(name: Identifier | string, containingType: Type): Symbol | undefined;
            getSuggestedSymbolForNonexistentSymbol(location: Node, name: string, meaning: SymbolFlags): Symbol | undefined;
            getSuggestedSymbolForNonexistentModule(node: Identifier, target: Symbol): Symbol | undefined;
            getSuggestedSymbolForNonexistentClassMember(name: string, baseType: Type): Symbol | undefined;
            getBaseConstraintOfType(type: Type): Type | undefined;
            getDefaultFromTypeParameter(type: Type): Type | undefined;
            getAnyType(): Type;
            getStringType(): Type;
            getStringLiteralType(value: string): StringLiteralType;
            getNumberType(): Type;
            getNumberLiteralType(value: number): NumberLiteralType;
            getBigIntType(): Type;
            getBigIntLiteralType(value: PseudoBigInt): BigIntLiteralType;
            getBooleanType(): Type;
            getUnknownType(): Type;
            getFalseType(fresh?: boolean): Type;
            getFalseType(): Type;
            getTrueType(fresh?: boolean): Type;
            getTrueType(): Type;
            getVoidType(): Type;
            getUndefinedType(): Type;
            getNullType(): Type;
            getESSymbolType(): Type;
            getNeverType(): Type;
            getNonPrimitiveType(): Type;
            getOptionalType(): Type;
            getUnionType(types: Type[], subtypeReduction?: UnionReduction): Type;
            createArrayType(elementType: Type): Type;
            getElementTypeOfArrayType(arrayType: Type): Type | undefined;
            createPromiseType(type: Type): Type;
            getPromiseType(): Type;
            getPromiseLikeType(): Type;
            getAnyAsyncIterableType(): Type | undefined;
            isTypeAssignableTo(source: Type, target: Type): boolean;
            createAnonymousType(symbol: Symbol | undefined, members: SymbolTable, callSignatures: Signature[], constructSignatures: Signature[], indexInfos: IndexInfo[]): Type;
            createSignature(declaration: SignatureDeclaration | undefined, typeParameters: readonly TypeParameter[] | undefined, thisParameter: Symbol | undefined, parameters: readonly Symbol[], resolvedReturnType: Type, typePredicate: TypePredicate | undefined, minArgumentCount: number, flags: SignatureFlags): Signature;
            createSymbol(flags: SymbolFlags, name: __String): TransientSymbol;
            createIndexInfo(keyType: Type, type: Type, isReadonly: boolean, declaration?: SignatureDeclaration): IndexInfo;
            isSymbolAccessible(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, shouldComputeAliasToMarkVisible: boolean): SymbolAccessibilityResult;
            tryFindAmbientModule(moduleName: string): Symbol | undefined;
            getSymbolWalker(accept?: (symbol: Symbol) => boolean): SymbolWalker;
            getDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken, nodesToCheck?: Node[]): Diagnostic[];
            getGlobalDiagnostics(): Diagnostic[];
            getEmitResolver(sourceFile?: SourceFile, cancellationToken?: CancellationToken, forceDts?: boolean): EmitResolver;
            requiresAddingImplicitUndefined(parameter: ParameterDeclaration | JSDocParameterTag, enclosingDeclaration: Node | undefined): boolean;
            getNodeCount(): number;
            getIdentifierCount(): number;
            getSymbolCount(): number;
            getTypeCount(): number;
            getInstantiationCount(): number;
            getRelationCacheSizes(): {
                assignable: number;
                identity: number;
                subtype: number;
                strictSubtype: number;
            };
            getRecursionIdentity(type: Type): object | undefined;
            getUnmatchedProperties(source: Type, target: Type, requireOptionalProperties: boolean, matchDiscriminantProperties: boolean): IterableIterator<Symbol>;
            isArrayType(type: Type): boolean;
            isTupleType(type: Type): boolean;
            isArrayLikeType(type: Type): boolean;
            isTypeInvalidDueToUnionDiscriminant(contextualType: Type, obj: ObjectLiteralExpression | JsxAttributes): boolean;
            getExactOptionalProperties(type: Type): Symbol[];
            getAllPossiblePropertiesOfTypes(type: readonly Type[]): Symbol[];
            resolveName(name: string, location: Node | undefined, meaning: SymbolFlags, excludeGlobals: boolean): Symbol | undefined;
            getJsxNamespace(location?: Node): string;
            getJsxFragmentFactory(location: Node): string | undefined;
            getAccessibleSymbolChain(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, useOnlyExternalAliasing: boolean): Symbol[] | undefined;
            getTypePredicateOfSignature(signature: Signature): TypePredicate | undefined;
            resolveExternalModuleName(moduleSpecifier: Expression): Symbol | undefined;
            resolveExternalModuleSymbol(symbol: Symbol): Symbol;
            tryGetThisTypeAt(node: Node, includeGlobalThis?: boolean, container?: ThisContainer): Type | undefined;
            getTypeArgumentConstraint(node: TypeNode): Type | undefined;
            getSuggestionDiagnostics(file: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
            runWithCancellationToken<T>(token: CancellationToken, cb: (checker: TypeChecker) => T): T;
            runWithCancellationToken<T>(token: CancellationToken | undefined, cb: (checker: TypeChecker) => T): T;
            getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol: Symbol): readonly TypeParameter[] | undefined;
            isDeclarationVisible(node: Declaration | AnyImportSyntax): boolean;
            isPropertyAccessible(node: Node, isSuper: boolean, isWrite: boolean, containingType: Type, property: Symbol): boolean;
            getTypeOnlyAliasDeclaration(symbol: Symbol): TypeOnlyAliasDeclaration | undefined;
            getMemberOverrideModifierStatus(node: ClassLikeDeclaration, member: ClassElement, memberSymbol: Symbol): MemberOverrideStatus;
            isTypeParameterPossiblyReferenced(tp: TypeParameter, node: Node): boolean;
            typeHasCallOrConstructSignatures(type: Type): boolean;
            getSymbolFlags(symbol: Symbol): SymbolFlags;
            fillMissingTypeArguments(typeArguments: readonly Type[], typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean): Type[];
            getTypeArgumentsForResolvedSignature(signature: Signature): readonly Type[] | undefined;
            isLibType(type: Type): boolean;
        }
        enum MemberOverrideStatus {
            Ok = 0,
            NeedsOverride = 1,
            HasInvalidOverride = 2
        }
        enum UnionReduction {
            None = 0,
            Literal = 1,
            Subtype = 2
        }
        enum IntersectionFlags {
            None = 0,
            NoSupertypeReduction = 1,
            NoConstraintReduction = 2
        }
        enum ContextFlags {
            None = 0,
            Signature = 1,
            NoConstraints = 2,
            Completions = 4,
            SkipBindingPatterns = 8
        }
        enum NodeBuilderFlags {
            None = 0,
            NoTruncation = 1,
            WriteArrayAsGenericType = 2,
            GenerateNamesForShadowedTypeParams = 4,
            UseStructuralFallback = 8,
            ForbidIndexedAccessSymbolReferences = 16,
            WriteTypeArgumentsOfSignature = 32,
            UseFullyQualifiedType = 64,
            UseOnlyExternalAliasing = 128,
            SuppressAnyReturnType = 256,
            WriteTypeParametersInQualifiedName = 512,
            MultilineObjectLiterals = 1024,
            WriteClassExpressionAsTypeLiteral = 2048,
            UseTypeOfFunction = 4096,
            OmitParameterModifiers = 8192,
            UseAliasDefinedOutsideCurrentScope = 16384,
            UseSingleQuotesForStringLiteralType = 268435456,
            NoTypeReduction = 536870912,
            OmitThisParameter = 33554432,
            AllowThisInObjectLiteral = 32768,
            AllowQualifiedNameInPlaceOfIdentifier = 65536,
            AllowAnonymousIdentifier = 131072,
            AllowEmptyUnionOrIntersection = 262144,
            AllowEmptyTuple = 524288,
            AllowUniqueESSymbolType = 1048576,
            AllowEmptyIndexInfoType = 2097152,
            AllowNodeModulesRelativePaths = 67108864,
            IgnoreErrors = 70221824,
            InObjectTypeLiteral = 4194304,
            InTypeAlias = 8388608,
            InInitialEntityName = 16777216
        }
        enum InternalNodeBuilderFlags {
            None = 0,
            WriteComputedProps = 1,
            NoSyntacticPrinter = 2,
            DoNotIncludeSymbolChain = 4,
            AllowUnresolvedNames = 8
        }
        enum TypeFormatFlags {
            None = 0,
            NoTruncation = 1,
            WriteArrayAsGenericType = 2,
            GenerateNamesForShadowedTypeParams = 4,
            UseStructuralFallback = 8,
            WriteTypeArgumentsOfSignature = 32,
            UseFullyQualifiedType = 64,
            SuppressAnyReturnType = 256,
            MultilineObjectLiterals = 1024,
            WriteClassExpressionAsTypeLiteral = 2048,
            UseTypeOfFunction = 4096,
            OmitParameterModifiers = 8192,
            UseAliasDefinedOutsideCurrentScope = 16384,
            UseSingleQuotesForStringLiteralType = 268435456,
            NoTypeReduction = 536870912,
            OmitThisParameter = 33554432,
            AllowUniqueESSymbolType = 1048576,
            AddUndefined = 131072,
            WriteArrowStyleSignature = 262144,
            InArrayType = 524288,
            InElementType = 2097152,
            InFirstTypeArgument = 4194304,
            InTypeAlias = 8388608,
            NodeBuilderFlagsMask = 848330095
        }
        enum SymbolFormatFlags {
            None = 0,
            WriteTypeParametersOrArguments = 1,
            UseOnlyExternalAliasing = 2,
            AllowAnyNodeKind = 4,
            UseAliasDefinedOutsideCurrentScope = 8,
            WriteComputedProps = 16,
            DoNotIncludeSymbolChain = 32
        }
        interface SymbolWalker {
            walkType(root: Type): {
                visitedTypes: readonly Type[];
                visitedSymbols: readonly Symbol[];
            };
            walkSymbol(root: Symbol): {
                visitedTypes: readonly Type[];
                visitedSymbols: readonly Symbol[];
            };
        }
        interface SymbolWriter {
            writeKeyword(text: string): void;
            writeOperator(text: string): void;
            writePunctuation(text: string): void;
            writeSpace(text: string): void;
            writeStringLiteral(text: string): void;
            writeParameter(text: string): void;
            writeProperty(text: string): void;
            writeSymbol(text: string, symbol: Symbol): void;
            writeLine(force?: boolean): void;
            increaseIndent(): void;
            decreaseIndent(): void;
            clear(): void;
        }
        enum SymbolAccessibility {
            Accessible = 0,
            NotAccessible = 1,
            CannotBeNamed = 2,
            NotResolved = 3
        }
        enum TypePredicateKind {
            This = 0,
            Identifier = 1,
            AssertsThis = 2,
            AssertsIdentifier = 3
        }
        interface TypePredicateBase {
            kind: TypePredicateKind;
            type: Type | undefined;
        }
        interface ThisTypePredicate extends TypePredicateBase {
            kind: TypePredicateKind.This;
            parameterName: undefined;
            parameterIndex: undefined;
            type: Type;
        }
        interface IdentifierTypePredicate extends TypePredicateBase {
            kind: TypePredicateKind.Identifier;
            parameterName: string;
            parameterIndex: number;
            type: Type;
        }
        interface AssertsThisTypePredicate extends TypePredicateBase {
            kind: TypePredicateKind.AssertsThis;
            parameterName: undefined;
            parameterIndex: undefined;
            type: Type | undefined;
        }
        interface AssertsIdentifierTypePredicate extends TypePredicateBase {
            kind: TypePredicateKind.AssertsIdentifier;
            parameterName: string;
            parameterIndex: number;
            type: Type | undefined;
        }
        type TypePredicate = ThisTypePredicate | IdentifierTypePredicate | AssertsThisTypePredicate | AssertsIdentifierTypePredicate;
        type AnyImportSyntax = ImportDeclaration | ImportEqualsDeclaration;
        type AnyImportOrJsDocImport = AnyImportSyntax | JSDocImportTag;
        type AnyImportOrRequire = AnyImportOrJsDocImport | VariableDeclarationInitializedTo<RequireOrImportCall>;
        type AnyImportOrBareOrAccessedRequire = AnyImportSyntax | VariableDeclarationInitializedTo<RequireOrImportCall | AccessExpression>;
        type AliasDeclarationNode = ImportEqualsDeclaration | VariableDeclarationInitializedTo<RequireOrImportCall | AccessExpression> | ImportClause | NamespaceImport | ImportSpecifier | ExportSpecifier | NamespaceExport | BindingElementOfBareOrAccessedRequire;
        type BindingElementOfBareOrAccessedRequire = BindingElement & {
            parent: {
                parent: VariableDeclarationInitializedTo<RequireOrImportCall | AccessExpression>;
            };
        };
        type AnyImportOrRequireStatement = AnyImportSyntax | RequireVariableStatement;
        type AnyImportOrReExport = AnyImportSyntax | ExportDeclaration;
        interface ValidImportTypeNode extends ImportTypeNode {
            argument: LiteralTypeNode & {
                literal: StringLiteral;
            };
        }
        type AnyValidImportOrReExport = (ImportDeclaration | ExportDeclaration | JSDocImportTag) & {
            moduleSpecifier: StringLiteral;
        } | ImportEqualsDeclaration & {
            moduleReference: ExternalModuleReference & {
                expression: StringLiteral;
            };
        } | RequireOrImportCall | ValidImportTypeNode;
        type RequireOrImportCall = CallExpression & {
            expression: Identifier;
            arguments: [
                StringLiteralLike
            ];
        };
        interface VariableDeclarationInitializedTo<T extends Expression> extends VariableDeclaration {
            readonly initializer: T;
        }
        interface RequireVariableStatement extends VariableStatement {
            readonly declarationList: RequireVariableDeclarationList;
        }
        interface RequireVariableDeclarationList extends VariableDeclarationList {
            readonly declarations: NodeArray<VariableDeclarationInitializedTo<RequireOrImportCall>>;
        }
        type CanHaveModuleSpecifier = AnyImportOrBareOrAccessedRequire | AliasDeclarationNode | ExportDeclaration | ImportTypeNode;
        type LateVisibilityPaintedStatement = AnyImportOrJsDocImport | VariableStatement | ClassDeclaration | FunctionDeclaration | ModuleDeclaration | TypeAliasDeclaration | InterfaceDeclaration | EnumDeclaration;
        interface SymbolVisibilityResult {
            accessibility: SymbolAccessibility;
            aliasesToMakeVisible?: LateVisibilityPaintedStatement[];
            errorSymbolName?: string;
            errorNode?: Node;
        }
        interface SymbolAccessibilityResult extends SymbolVisibilityResult {
            errorModuleName?: string;
        }
        interface AllAccessorDeclarations {
            firstAccessor: AccessorDeclaration;
            secondAccessor: AccessorDeclaration | undefined;
            getAccessor: GetAccessorDeclaration | undefined;
            setAccessor: SetAccessorDeclaration | undefined;
        }
        interface AllDecorators {
            decorators: readonly Decorator[] | undefined;
            parameters?: readonly (readonly Decorator[] | undefined)[];
            getDecorators?: readonly Decorator[] | undefined;
            setDecorators?: readonly Decorator[] | undefined;
        }
        enum TypeReferenceSerializationKind {
            Unknown = 0,
            TypeWithConstructSignatureAndValue = 1,
            VoidNullableOrNeverType = 2,
            NumberLikeType = 3,
            BigIntLikeType = 4,
            StringLikeType = 5,
            BooleanType = 6,
            ArrayLikeType = 7,
            ESSymbolType = 8,
            Promise = 9,
            TypeWithCallSignature = 10,
            ObjectType = 11
        }
        type LazyNodeCheckFlags = NodeCheckFlags.SuperInstance | NodeCheckFlags.SuperStatic | NodeCheckFlags.MethodWithSuperPropertyAccessInAsync | NodeCheckFlags.MethodWithSuperPropertyAssignmentInAsync | NodeCheckFlags.ContainsSuperPropertyInStaticInitializer | NodeCheckFlags.CaptureArguments | NodeCheckFlags.ContainsCapturedBlockScopeBinding | NodeCheckFlags.NeedsLoopOutParameter | NodeCheckFlags.ContainsConstructorReference | NodeCheckFlags.ConstructorReference | NodeCheckFlags.CapturedBlockScopedBinding | NodeCheckFlags.BlockScopedBindingInLoop | NodeCheckFlags.LoopWithCapturedBlockScopedBinding;
        interface EmitResolver {
            hasGlobalName(name: string): boolean;
            getReferencedExportContainer(node: Identifier, prefixLocals?: boolean): SourceFile | ModuleDeclaration | EnumDeclaration | undefined;
            getReferencedImportDeclaration(node: Identifier): Declaration | undefined;
            getReferencedDeclarationWithCollidingName(node: Identifier): Declaration | undefined;
            isDeclarationWithCollidingName(node: Declaration): boolean;
            isValueAliasDeclaration(node: Node): boolean;
            isReferencedAliasDeclaration(node: Node, checkChildren?: boolean): boolean;
            isTopLevelValueImportEqualsWithEntityName(node: ImportEqualsDeclaration): boolean;
            hasNodeCheckFlag(node: Node, flags: LazyNodeCheckFlags): boolean;
            isDeclarationVisible(node: Declaration | AnyImportSyntax): boolean;
            isLateBound(node: Declaration): node is LateBoundDeclaration;
            collectLinkedAliases(node: ModuleExportName, setVisibility?: boolean): Node[] | undefined;
            markLinkedReferences(node: Node): void;
            isImplementationOfOverload(node: SignatureDeclaration): boolean | undefined;
            requiresAddingImplicitUndefined(node: ParameterDeclaration, enclosingDeclaration: Node | undefined): boolean;
            isExpandoFunctionDeclaration(node: FunctionDeclaration | VariableDeclaration): boolean;
            getPropertiesOfContainerFunction(node: Declaration): Symbol[];
            createTypeOfDeclaration(declaration: HasInferredType, enclosingDeclaration: Node, flags: NodeBuilderFlags, internalFlags: InternalNodeBuilderFlags, tracker: SymbolTracker): TypeNode | undefined;
            createReturnTypeOfSignatureDeclaration(signatureDeclaration: SignatureDeclaration, enclosingDeclaration: Node, flags: NodeBuilderFlags, internalFlags: InternalNodeBuilderFlags, tracker: SymbolTracker): TypeNode | undefined;
            createTypeOfExpression(expr: Expression, enclosingDeclaration: Node, flags: NodeBuilderFlags, internalFlags: InternalNodeBuilderFlags, tracker: SymbolTracker): TypeNode | undefined;
            createLiteralConstValue(node: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration, tracker: SymbolTracker): Expression;
            isSymbolAccessible(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags | undefined, shouldComputeAliasToMarkVisible: boolean): SymbolAccessibilityResult;
            isEntityNameVisible(entityName: EntityNameOrEntityNameExpression, enclosingDeclaration: Node): SymbolVisibilityResult;
            getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number | undefined;
            getEnumMemberValue(node: EnumMember): EvaluatorResult | undefined;
            getReferencedValueDeclaration(reference: Identifier): Declaration | undefined;
            getReferencedValueDeclarations(reference: Identifier): Declaration[] | undefined;
            getTypeReferenceSerializationKind(typeName: EntityName, location?: Node): TypeReferenceSerializationKind;
            isOptionalParameter(node: ParameterDeclaration): boolean;
            isArgumentsLocalBinding(node: Identifier): boolean;
            getExternalModuleFileFromDeclaration(declaration: ImportEqualsDeclaration | ImportDeclaration | ExportDeclaration | ModuleDeclaration | ImportTypeNode | ImportCall): SourceFile | undefined;
            isLiteralConstDeclaration(node: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration): boolean;
            getJsxFactoryEntity(location?: Node): EntityName | undefined;
            getJsxFragmentFactoryEntity(location?: Node): EntityName | undefined;
            isBindingCapturedByNode(node: Node, decl: VariableDeclaration | BindingElement): boolean;
            getDeclarationStatementsForSourceFile(node: SourceFile, flags: NodeBuilderFlags, internalFlags: InternalNodeBuilderFlags, tracker: SymbolTracker): Statement[] | undefined;
            isImportRequiredByAugmentation(decl: ImportDeclaration): boolean;
            isDefinitelyReferenceToGlobalSymbolObject(node: Node): boolean;
            createLateBoundIndexSignatures(cls: ClassLikeDeclaration, enclosingDeclaration: Node, flags: NodeBuilderFlags, internalFlags: InternalNodeBuilderFlags, tracker: SymbolTracker): (IndexSignatureDeclaration | PropertyDeclaration)[] | undefined;
            symbolToDeclarations(symbol: Symbol, meaning: SymbolFlags, flags: NodeBuilderFlags, verbosityLevel?: number, out?: WriterContextOut): Declaration[];
        }
        enum SymbolFlags {
            None = 0,
            FunctionScopedVariable = 1,
            BlockScopedVariable = 2,
            Property = 4,
            EnumMember = 8,
            Function = 16,
            Class = 32,
            Interface = 64,
            ConstEnum = 128,
            RegularEnum = 256,
            ValueModule = 512,
            NamespaceModule = 1024,
            TypeLiteral = 2048,
            ObjectLiteral = 4096,
            Method = 8192,
            Constructor = 16384,
            GetAccessor = 32768,
            SetAccessor = 65536,
            Signature = 131072,
            TypeParameter = 262144,
            TypeAlias = 524288,
            ExportValue = 1048576,
            Alias = 2097152,
            Prototype = 4194304,
            ExportStar = 8388608,
            Optional = 16777216,
            Transient = 33554432,
            Assignment = 67108864,
            ModuleExports = 134217728,
            All = -1,
            Enum = 384,
            Variable = 3,
            Value = 111551,
            Type = 788968,
            Namespace = 1920,
            Module = 1536,
            Accessor = 98304,
            FunctionScopedVariableExcludes = 111550,
            BlockScopedVariableExcludes = 111551,
            ParameterExcludes = 111551,
            PropertyExcludes = 0,
            EnumMemberExcludes = 900095,
            FunctionExcludes = 110991,
            ClassExcludes = 899503,
            InterfaceExcludes = 788872,
            RegularEnumExcludes = 899327,
            ConstEnumExcludes = 899967,
            ValueModuleExcludes = 110735,
            NamespaceModuleExcludes = 0,
            MethodExcludes = 103359,
            GetAccessorExcludes = 46015,
            SetAccessorExcludes = 78783,
            AccessorExcludes = 13247,
            TypeParameterExcludes = 526824,
            TypeAliasExcludes = 788968,
            AliasExcludes = 2097152,
            ModuleMember = 2623475,
            ExportHasLocal = 944,
            BlockScoped = 418,
            PropertyOrAccessor = 98308,
            ClassMember = 106500,
            ExportSupportsDefaultModifier = 112,
            ExportDoesNotSupportDefaultModifier = -113,
            Classifiable = 2885600,
            LateBindingContainer = 6256
        }
        type SymbolId = number;
        interface Symbol {
            flags: SymbolFlags;
            escapedName: __String;
            declarations?: Declaration[];
            valueDeclaration?: Declaration;
            members?: SymbolTable;
            exports?: SymbolTable;
            globalExports?: SymbolTable;
            id: SymbolId;
            mergeId: number;
            parent?: Symbol;
            exportSymbol?: Symbol;
            constEnumOnlyModule: boolean | undefined;
            isReferenced?: SymbolFlags;
            lastAssignmentPos?: number;
            isReplaceableByMethod?: boolean;
            assignmentDeclarationMembers?: Map<number, Declaration>;
        }
        interface Symbol {
            readonly name: string;
            getFlags(): SymbolFlags;
            getEscapedName(): __String;
            getName(): string;
            getDeclarations(): Declaration[] | undefined;
            getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
            getContextualDocumentationComment(context: Node | undefined, checker: TypeChecker | undefined): SymbolDisplayPart[];
            getJsDocTags(checker?: TypeChecker): JSDocTagInfo[];
            getContextualJsDocTags(context: Node | undefined, checker: TypeChecker | undefined): JSDocTagInfo[];
        }
        interface SymbolLinks {
            _symbolLinksBrand: any;
            immediateTarget?: Symbol;
            aliasTarget?: Symbol;
            target?: Symbol;
            type?: Type;
            writeType?: Type;
            nameType?: Type;
            uniqueESSymbolType?: Type;
            declaredType?: Type;
            typeParameters?: TypeParameter[];
            instantiations?: Map<string, Type>;
            inferredClassSymbol?: Map<SymbolId, TransientSymbol>;
            mapper?: TypeMapper;
            referenced?: boolean;
            containingType?: UnionOrIntersectionType;
            leftSpread?: Symbol;
            rightSpread?: Symbol;
            syntheticOrigin?: Symbol;
            isDiscriminantProperty?: boolean;
            resolvedExports?: SymbolTable;
            resolvedMembers?: SymbolTable;
            exportsChecked?: boolean;
            typeParametersChecked?: boolean;
            isDeclarationWithCollidingName?: boolean;
            originatingImport?: ImportDeclaration | ImportCall;
            lateSymbol?: Symbol;
            specifierCache?: Map<ModeAwareCacheKey, string>;
            extendedContainers?: Symbol[];
            extendedContainersByFile?: Map<NodeId, Symbol[]>;
            variances?: VarianceFlags[];
            deferralConstituents?: Type[];
            deferralWriteConstituents?: Type[];
            deferralParent?: Type;
            cjsExportMerged?: Symbol;
            typeOnlyDeclaration?: TypeOnlyAliasDeclaration | false;
            typeOnlyExportStarMap?: Map<__String, ExportDeclaration & {
                readonly isTypeOnly: true;
                readonly moduleSpecifier: Expression;
            }>;
            typeOnlyExportStarName?: __String;
            isConstructorDeclaredProperty?: boolean;
            tupleLabelDeclaration?: NamedTupleMember | ParameterDeclaration;
            accessibleChainCache?: Map<string, Symbol[] | undefined>;
            filteredIndexSymbolCache?: Map<string, Symbol>;
            requestedExternalEmitHelpers?: ExternalEmitHelpers;
        }
        enum CheckFlags {
            None = 0,
            Instantiated = 1,
            SyntheticProperty = 2,
            SyntheticMethod = 4,
            Readonly = 8,
            ReadPartial = 16,
            WritePartial = 32,
            HasNonUniformType = 64,
            HasLiteralType = 128,
            ContainsPublic = 256,
            ContainsProtected = 512,
            ContainsPrivate = 1024,
            ContainsStatic = 2048,
            Late = 4096,
            ReverseMapped = 8192,
            OptionalParameter = 16384,
            RestParameter = 32768,
            DeferredType = 65536,
            HasNeverType = 131072,
            Mapped = 262144,
            StripOptional = 524288,
            Unresolved = 1048576,
            Synthetic = 6,
            Discriminant = 192,
            Partial = 48
        }
        interface TransientSymbolLinks extends SymbolLinks {
            checkFlags: CheckFlags;
        }
        interface TransientSymbol extends Symbol {
            links: TransientSymbolLinks;
        }
        interface MappedSymbolLinks extends TransientSymbolLinks {
            mappedType: MappedType;
            keyType: Type;
        }
        interface MappedSymbol extends TransientSymbol {
            links: MappedSymbolLinks;
        }
        interface ReverseMappedSymbolLinks extends TransientSymbolLinks {
            propertyType: Type;
            mappedType: MappedType;
            constraintType: IndexType;
        }
        interface ReverseMappedSymbol extends TransientSymbol {
            links: ReverseMappedSymbolLinks;
        }
        enum InternalSymbolName {
            Call = "__call",
            Constructor = "__constructor",
            New = "__new",
            Index = "__index",
            ExportStar = "__export",
            Global = "__global",
            Missing = "__missing",
            Type = "__type",
            Object = "__object",
            JSXAttributes = "__jsxAttributes",
            Class = "__class",
            Function = "__function",
            Computed = "__computed",
            Resolving = "__resolving__",
            ExportEquals = "export=",
            Default = "default",
            This = "this",
            InstantiationExpression = "__instantiationExpression",
            ImportAttributes = "__importAttributes"
        }
        type __String = (string & {
            __escapedIdentifier: void;
        }) | (void & {
            __escapedIdentifier: void;
        }) | InternalSymbolName;
        type ReadonlyUnderscoreEscapedMap<T> = ReadonlyMap<__String, T>;
        type UnderscoreEscapedMap<T> = Map<__String, T>;
        type SymbolTable = Map<__String, Symbol>;
        interface PatternAmbientModule {
            pattern: Pattern;
            symbol: Symbol;
        }
        enum NodeCheckFlags {
            None = 0,
            TypeChecked = 1,
            LexicalThis = 2,
            CaptureThis = 4,
            CaptureNewTarget = 8,
            SuperInstance = 16,
            SuperStatic = 32,
            ContextChecked = 64,
            MethodWithSuperPropertyAccessInAsync = 128,
            MethodWithSuperPropertyAssignmentInAsync = 256,
            CaptureArguments = 512,
            EnumValuesComputed = 1024,
            LexicalModuleMergesWithClass = 2048,
            LoopWithCapturedBlockScopedBinding = 4096,
            ContainsCapturedBlockScopeBinding = 8192,
            CapturedBlockScopedBinding = 16384,
            BlockScopedBindingInLoop = 32768,
            NeedsLoopOutParameter = 65536,
            AssignmentsMarked = 131072,
            ContainsConstructorReference = 262144,
            ConstructorReference = 536870912,
            ContainsClassWithPrivateIdentifiers = 1048576,
            ContainsSuperPropertyInStaticInitializer = 2097152,
            InCheckIdentifier = 4194304,
            PartiallyTypeChecked = 8388608,
            LazyFlags = 539358128
        }
        interface EvaluatorResult<T extends string | number | undefined = string | number | undefined> {
            value: T;
            isSyntacticallyString: boolean;
            resolvedOtherFiles: boolean;
            hasExternalReferences: boolean;
        }
        interface NodeLinks {
            flags: NodeCheckFlags;
            calculatedFlags: NodeCheckFlags;
            resolvedType?: Type;
            resolvedSignature?: Signature;
            resolvedSymbol?: Symbol;
            effectsSignature?: Signature;
            enumMemberValue?: EvaluatorResult;
            isVisible?: boolean;
            containsArgumentsReference?: boolean;
            hasReportedStatementInAmbientContext?: boolean;
            jsxFlags: JsxFlags;
            resolvedJsxElementAttributesType?: Type;
            resolvedJSDocType?: Type;
            switchTypes?: Type[];
            jsxNamespace?: Symbol | false;
            jsxImplicitImportContainer?: Symbol | false;
            jsxFragmentType?: Type;
            contextFreeType?: Type;
            deferredNodes?: Set<Node>;
            capturedBlockScopeBindings?: Symbol[];
            outerTypeParameters?: TypeParameter[];
            isExhaustive?: boolean | 0;
            skipDirectInference?: true;
            declarationRequiresScopeChange?: boolean;
            serializedTypes?: Map<string, SerializedTypeEntry>;
            decoratorSignature?: Signature;
            spreadIndices?: {
                first: number | undefined;
                last: number | undefined;
            };
            parameterInitializerContainsUndefined?: boolean;
            fakeScopeForSignatureDeclaration?: "params" | "typeParams";
            assertionExpressionType?: Type;
            potentialThisCollisions?: Node[];
            potentialNewTargetCollisions?: Node[];
            potentialWeakMapSetCollisions?: Node[];
            potentialReflectCollisions?: Node[];
            potentialUnusedRenamedBindingElementsInTypes?: BindingElement[];
            externalHelpersModule?: Symbol;
            instantiationExpressionTypes?: Map<number, Type>;
            nonExistentPropCheckCache?: Set<string>;
        }
        type TrackedSymbol = [
            symbol: Symbol,
            enclosingDeclaration: Node | undefined,
            meaning: SymbolFlags
        ];
        interface SerializedTypeEntry {
            node: TypeNode;
            truncating?: boolean;
            addedLength: number;
            trackedSymbols: readonly TrackedSymbol[] | undefined;
        }
        enum TypeFlags {
            Any = 1,
            Unknown = 2,
            String = 4,
            Number = 8,
            Boolean = 16,
            Enum = 32,
            BigInt = 64,
            StringLiteral = 128,
            NumberLiteral = 256,
            BooleanLiteral = 512,
            EnumLiteral = 1024,
            BigIntLiteral = 2048,
            ESSymbol = 4096,
            UniqueESSymbol = 8192,
            Void = 16384,
            Undefined = 32768,
            Null = 65536,
            Never = 131072,
            TypeParameter = 262144,
            Object = 524288,
            Union = 1048576,
            Intersection = 2097152,
            Index = 4194304,
            IndexedAccess = 8388608,
            Conditional = 16777216,
            Substitution = 33554432,
            NonPrimitive = 67108864,
            TemplateLiteral = 134217728,
            StringMapping = 268435456,
            Reserved1 = 536870912,
            Reserved2 = 1073741824,
            AnyOrUnknown = 3,
            Nullable = 98304,
            Literal = 2944,
            Unit = 109472,
            Freshable = 2976,
            StringOrNumberLiteral = 384,
            StringOrNumberLiteralOrUnique = 8576,
            DefinitelyFalsy = 117632,
            PossiblyFalsy = 117724,
            Intrinsic = 67359327,
            StringLike = 402653316,
            NumberLike = 296,
            BigIntLike = 2112,
            BooleanLike = 528,
            EnumLike = 1056,
            ESSymbolLike = 12288,
            VoidLike = 49152,
            Primitive = 402784252,
            DefinitelyNonNullable = 470302716,
            DisjointDomains = 469892092,
            UnionOrIntersection = 3145728,
            StructuredType = 3670016,
            TypeVariable = 8650752,
            InstantiableNonPrimitive = 58982400,
            InstantiablePrimitive = 406847488,
            Instantiable = 465829888,
            StructuredOrInstantiable = 469499904,
            ObjectFlagsType = 3899393,
            Simplifiable = 25165824,
            Singleton = 67358815,
            Narrowable = 536624127,
            IncludesMask = 473694207,
            IncludesMissingType = 262144,
            IncludesNonWideningType = 4194304,
            IncludesWildcard = 8388608,
            IncludesEmptyObject = 16777216,
            IncludesInstantiable = 33554432,
            IncludesConstrainedTypeVariable = 536870912,
            IncludesError = 1073741824,
            NotPrimitiveUnion = 36323331
        }
        type DestructuringPattern = BindingPattern | ObjectLiteralExpression | ArrayLiteralExpression;
        type TypeId = number;
        interface Type {
            flags: TypeFlags;
            id: TypeId;
            checker: TypeChecker;
            symbol: Symbol;
            pattern?: DestructuringPattern;
            aliasSymbol?: Symbol;
            aliasTypeArguments?: readonly Type[];
            permissiveInstantiation?: Type;
            restrictiveInstantiation?: Type;
            immediateBaseConstraint?: Type;
            widened?: Type;
        }
        interface Type {
            getFlags(): TypeFlags;
            getSymbol(): Symbol | undefined;
            getProperties(): Symbol[];
            getProperty(propertyName: string): Symbol | undefined;
            getApparentProperties(): Symbol[];
            getCallSignatures(): readonly Signature[];
            getConstructSignatures(): readonly Signature[];
            getStringIndexType(): Type | undefined;
            getNumberIndexType(): Type | undefined;
            getBaseTypes(): BaseType[] | undefined;
            getNonNullableType(): Type;
            getNonOptionalType(): Type;
            isNullableType(): boolean;
            getConstraint(): Type | undefined;
            getDefault(): Type | undefined;
            isUnion(): this is UnionType;
            isIntersection(): this is IntersectionType;
            isUnionOrIntersection(): this is UnionOrIntersectionType;
            isLiteral(): this is LiteralType;
            isStringLiteral(): this is StringLiteralType;
            isNumberLiteral(): this is NumberLiteralType;
            isTypeParameter(): this is TypeParameter;
            isClassOrInterface(): this is InterfaceType;
            isClass(): this is InterfaceType;
            isIndexType(): this is IndexType;
        }
        interface IntrinsicType extends Type {
            intrinsicName: string;
            debugIntrinsicName: string | undefined;
            objectFlags: ObjectFlags;
        }
        interface NullableType extends IntrinsicType {
            objectFlags: ObjectFlags;
        }
        interface FreshableType extends Type {
            freshType: FreshableType;
            regularType: FreshableType;
        }
        interface FreshableIntrinsicType extends FreshableType, IntrinsicType {
        }
        interface LiteralType extends FreshableType {
            value: string | number | PseudoBigInt;
        }
        interface UniqueESSymbolType extends Type {
            symbol: Symbol;
            escapedName: __String;
        }
        interface StringLiteralType extends LiteralType {
            value: string;
        }
        interface NumberLiteralType extends LiteralType {
            value: number;
        }
        interface BigIntLiteralType extends LiteralType {
            value: PseudoBigInt;
        }
        interface EnumType extends FreshableType {
        }
        enum ObjectFlags {
            None = 0,
            Class = 1,
            Interface = 2,
            Reference = 4,
            Tuple = 8,
            Anonymous = 16,
            Mapped = 32,
            Instantiated = 64,
            ObjectLiteral = 128,
            EvolvingArray = 256,
            ObjectLiteralPatternWithComputedProperties = 512,
            ReverseMapped = 1024,
            JsxAttributes = 2048,
            JSLiteral = 4096,
            FreshLiteral = 8192,
            ArrayLiteral = 16384,
            PrimitiveUnion = 32768,
            ContainsWideningType = 65536,
            ContainsObjectOrArrayLiteral = 131072,
            NonInferrableType = 262144,
            CouldContainTypeVariablesComputed = 524288,
            CouldContainTypeVariables = 1048576,
            ClassOrInterface = 3,
            RequiresWidening = 196608,
            PropagatingFlags = 458752,
            InstantiatedMapped = 96,
            ObjectTypeKindMask = 1343,
            ContainsSpread = 2097152,
            ObjectRestType = 4194304,
            InstantiationExpressionType = 8388608,
            SingleSignatureType = 134217728,
            IsClassInstanceClone = 16777216,
            IdenticalBaseTypeCalculated = 33554432,
            IdenticalBaseTypeExists = 67108864,
            IsGenericTypeComputed = 2097152,
            IsGenericObjectType = 4194304,
            IsGenericIndexType = 8388608,
            IsGenericType = 12582912,
            ContainsIntersections = 16777216,
            IsUnknownLikeUnionComputed = 33554432,
            IsUnknownLikeUnion = 67108864,
            IsNeverIntersectionComputed = 16777216,
            IsNeverIntersection = 33554432,
            IsConstrainedTypeVariable = 67108864
        }
        type ObjectFlagsType = NullableType | ObjectType | UnionType | IntersectionType;
        interface ObjectType extends Type {
            objectFlags: ObjectFlags;
            members?: SymbolTable;
            properties?: Symbol[];
            callSignatures?: readonly Signature[];
            constructSignatures?: readonly Signature[];
            indexInfos?: readonly IndexInfo[];
            objectTypeWithoutAbstractConstructSignatures?: ObjectType;
        }
        interface InterfaceType extends ObjectType {
            typeParameters: TypeParameter[] | undefined;
            outerTypeParameters: TypeParameter[] | undefined;
            localTypeParameters: TypeParameter[] | undefined;
            thisType: TypeParameter | undefined;
            resolvedBaseConstructorType?: Type;
            resolvedBaseTypes: BaseType[];
            baseTypesResolved?: boolean;
        }
        type BaseType = ObjectType | IntersectionType | TypeVariable;
        interface InterfaceTypeWithDeclaredMembers extends InterfaceType {
            declaredProperties: Symbol[];
            declaredCallSignatures: Signature[];
            declaredConstructSignatures: Signature[];
            declaredIndexInfos: IndexInfo[];
        }
        interface TypeReference extends ObjectType {
            target: GenericType;
            node?: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;
            mapper?: TypeMapper;
            resolvedTypeArguments?: readonly Type[];
            literalType?: TypeReference;
            cachedEquivalentBaseType?: Type;
        }
        interface TypeReference {
            typeArguments?: readonly Type[];
        }
        interface DeferredTypeReference extends TypeReference {
            node: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;
            mapper?: TypeMapper;
            instantiations?: Map<string, Type>;
        }
        enum VarianceFlags {
            Invariant = 0,
            Covariant = 1,
            Contravariant = 2,
            Bivariant = 3,
            Independent = 4,
            VarianceMask = 7,
            Unmeasurable = 8,
            Unreliable = 16,
            AllowsStructuralFallback = 24
        }
        interface GenericType extends InterfaceType, TypeReference {
            instantiations: Map<string, TypeReference>;
            variances?: VarianceFlags[];
        }
        enum ElementFlags {
            Required = 1,
            Optional = 2,
            Rest = 4,
            Variadic = 8,
            Fixed = 3,
            Variable = 12,
            NonRequired = 14,
            NonRest = 11
        }
        interface TupleType extends GenericType {
            elementFlags: readonly ElementFlags[];
            minLength: number;
            fixedLength: number;
            hasRestElement: boolean;
            combinedFlags: ElementFlags;
            readonly: boolean;
            labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration | undefined)[];
        }
        interface TupleTypeReference extends TypeReference {
            target: TupleType;
        }
        interface UnionOrIntersectionType extends Type {
            types: Type[];
            objectFlags: ObjectFlags;
            propertyCache?: SymbolTable;
            propertyCacheWithoutObjectFunctionPropertyAugment?: SymbolTable;
            resolvedProperties: Symbol[];
            resolvedIndexType: IndexType;
            resolvedStringIndexType: IndexType;
            resolvedBaseConstraint: Type;
        }
        interface UnionType extends UnionOrIntersectionType {
            resolvedReducedType?: Type;
            regularType?: UnionType;
            origin?: Type;
            keyPropertyName?: __String;
            constituentMap?: Map<TypeId, Type>;
            arrayFallbackSignatures?: readonly Signature[];
        }
        interface IntersectionType extends UnionOrIntersectionType {
            resolvedApparentType: Type;
            uniqueLiteralFilledInstantiation?: Type;
        }
        type StructuredType = ObjectType | UnionType | IntersectionType;
        interface AnonymousType extends ObjectType {
            target?: AnonymousType;
            mapper?: TypeMapper;
            instantiations?: Map<string, Type>;
        }
        interface SingleSignatureType extends AnonymousType {
            outerTypeParameters?: TypeParameter[];
        }
        interface InstantiationExpressionType extends AnonymousType {
            node: NodeWithTypeArguments;
        }
        interface MappedType extends AnonymousType {
            declaration: MappedTypeNode;
            typeParameter?: TypeParameter;
            constraintType?: Type;
            nameType?: Type;
            templateType?: Type;
            modifiersType?: Type;
            resolvedApparentType?: Type;
            containsError?: boolean;
        }
        interface EvolvingArrayType extends ObjectType {
            elementType: Type;
            finalArrayType?: Type;
        }
        interface ReverseMappedType extends ObjectType {
            source: Type;
            mappedType: MappedType;
            constraintType: IndexType;
        }
        interface ResolvedType extends ObjectType, UnionOrIntersectionType {
            members: SymbolTable;
            properties: Symbol[];
            callSignatures: readonly Signature[];
            constructSignatures: readonly Signature[];
            indexInfos: readonly IndexInfo[];
        }
        interface FreshObjectLiteralType extends ResolvedType {
            regularType: ResolvedType;
        }
        interface IterationTypes {
            readonly yieldType: Type;
            readonly returnType: Type;
            readonly nextType: Type;
        }
        interface IterableOrIteratorType extends ObjectType, UnionType {
            iterationTypesOfGeneratorReturnType?: IterationTypes;
            iterationTypesOfAsyncGeneratorReturnType?: IterationTypes;
            iterationTypesOfIterable?: IterationTypes;
            iterationTypesOfIterator?: IterationTypes;
            iterationTypesOfAsyncIterable?: IterationTypes;
            iterationTypesOfAsyncIterator?: IterationTypes;
            iterationTypesOfIteratorResult?: IterationTypes;
        }
        interface PromiseOrAwaitableType extends ObjectType, UnionType {
            promiseTypeOfPromiseConstructor?: Type;
            promisedTypeOfPromise?: Type;
            awaitedTypeOfType?: Type;
        }
        interface SyntheticDefaultModuleType extends Type {
            syntheticType?: Type;
            defaultOnlyType?: Type;
        }
        interface InstantiableType extends Type {
            resolvedBaseConstraint?: Type;
            resolvedIndexType?: IndexType;
            resolvedStringIndexType?: IndexType;
        }
        interface TypeParameter extends InstantiableType {
            constraint?: Type;
            default?: Type;
            target?: TypeParameter;
            mapper?: TypeMapper;
            isThisType?: boolean;
            resolvedDefaultType?: Type;
        }
        enum AccessFlags {
            None = 0,
            IncludeUndefined = 1,
            NoIndexSignatures = 2,
            Writing = 4,
            CacheSymbol = 8,
            AllowMissing = 16,
            ExpressionPosition = 32,
            ReportDeprecated = 64,
            SuppressNoImplicitAnyError = 128,
            Contextual = 256,
            Persistent = 1
        }
        interface IndexedAccessType extends InstantiableType {
            objectType: Type;
            indexType: Type;
            accessFlags: AccessFlags;
            constraint?: Type;
            simplifiedForReading?: Type;
            simplifiedForWriting?: Type;
        }
        type TypeVariable = TypeParameter | IndexedAccessType;
        enum IndexFlags {
            None = 0,
            StringsOnly = 1,
            NoIndexSignatures = 2,
            NoReducibleCheck = 4
        }
        interface IndexType extends InstantiableType {
            type: InstantiableType | UnionOrIntersectionType;
            indexFlags: IndexFlags;
        }
        interface ConditionalRoot {
            node: ConditionalTypeNode;
            checkType: Type;
            extendsType: Type;
            isDistributive: boolean;
            inferTypeParameters?: TypeParameter[];
            outerTypeParameters?: TypeParameter[];
            instantiations?: Map<string, Type>;
            aliasSymbol?: Symbol;
            aliasTypeArguments?: Type[];
        }
        interface ConditionalType extends InstantiableType {
            root: ConditionalRoot;
            checkType: Type;
            extendsType: Type;
            resolvedTrueType?: Type;
            resolvedFalseType?: Type;
            resolvedInferredTrueType?: Type;
            resolvedDefaultConstraint?: Type;
            resolvedConstraintOfDistributive?: Type | false;
            mapper?: TypeMapper;
            combinedMapper?: TypeMapper;
        }
        interface TemplateLiteralType extends InstantiableType {
            texts: readonly string[];
            types: readonly Type[];
        }
        interface StringMappingType extends InstantiableType {
            symbol: Symbol;
            type: Type;
        }
        interface SubstitutionType extends InstantiableType {
            objectFlags: ObjectFlags;
            baseType: Type;
            constraint: Type;
        }
        enum JsxReferenceKind {
            Component = 0,
            Function = 1,
            Mixed = 2
        }
        enum SignatureKind {
            Call = 0,
            Construct = 1
        }
        enum SignatureFlags {
            None = 0,
            HasRestParameter = 1,
            HasLiteralTypes = 2,
            Abstract = 4,
            IsInnerCallChain = 8,
            IsOuterCallChain = 16,
            IsUntypedSignatureInJSFile = 32,
            IsNonInferrable = 64,
            IsSignatureCandidateForOverloadFailure = 128,
            PropagatingFlags = 167,
            CallChainFlags = 24
        }
        interface Signature {
            flags: SignatureFlags;
            checker?: TypeChecker;
            declaration?: SignatureDeclaration | JSDocSignature;
            typeParameters?: readonly TypeParameter[];
            parameters: readonly Symbol[];
            thisParameter?: Symbol;
            resolvedReturnType?: Type;
            resolvedTypePredicate?: TypePredicate;
            minArgumentCount: number;
            resolvedMinArgumentCount?: number;
            target?: Signature;
            mapper?: TypeMapper;
            compositeSignatures?: Signature[];
            compositeKind?: TypeFlags;
            erasedSignatureCache?: Signature;
            canonicalSignatureCache?: Signature;
            baseSignatureCache?: Signature;
            optionalCallSignatureCache?: {
                inner?: Signature;
                outer?: Signature;
            };
            isolatedSignatureType?: ObjectType;
            instantiations?: Map<string, Signature>;
            implementationSignatureCache?: Signature;
        }
        interface Signature {
            getDeclaration(): SignatureDeclaration;
            getTypeParameters(): TypeParameter[] | undefined;
            getParameters(): Symbol[];
            getTypeParameterAtPosition(pos: number): Type;
            getReturnType(): Type;
            getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
            getJsDocTags(): JSDocTagInfo[];
        }
        enum IndexKind {
            String = 0,
            Number = 1
        }
        type ElementWithComputedPropertyName = (ClassElement | ObjectLiteralElement) & {
            name: ComputedPropertyName;
        };
        interface IndexInfo {
            keyType: Type;
            type: Type;
            isReadonly: boolean;
            declaration?: IndexSignatureDeclaration;
            components?: ElementWithComputedPropertyName[];
        }
        enum TypeMapKind {
            Simple = 0,
            Array = 1,
            Deferred = 2,
            Function = 3,
            Composite = 4,
            Merged = 5
        }
        type TypeMapper = {
            kind: TypeMapKind.Simple;
            source: Type;
            target: Type;
        } | {
            kind: TypeMapKind.Array;
            sources: readonly Type[];
            targets: readonly Type[] | undefined;
        } | {
            kind: TypeMapKind.Deferred;
            sources: readonly Type[];
            targets: (() => Type)[];
        } | {
            kind: TypeMapKind.Function;
            func: (t: Type) => Type;
            debugInfo?: () => string;
        } | {
            kind: TypeMapKind.Composite | TypeMapKind.Merged;
            mapper1: TypeMapper;
            mapper2: TypeMapper;
        };
        enum InferencePriority {
            None = 0,
            NakedTypeVariable = 1,
            SpeculativeTuple = 2,
            SubstituteSource = 4,
            HomomorphicMappedType = 8,
            PartialHomomorphicMappedType = 16,
            MappedTypeConstraint = 32,
            ContravariantConditional = 64,
            ReturnType = 128,
            LiteralKeyof = 256,
            NoConstraints = 512,
            AlwaysStrict = 1024,
            MaxValue = 2048,
            PriorityImpliesCombination = 416,
            Circularity = -1
        }
        interface InferenceInfo {
            typeParameter: TypeParameter;
            candidates: Type[] | undefined;
            contraCandidates: Type[] | undefined;
            inferredType?: Type;
            priority?: InferencePriority;
            topLevel: boolean;
            isFixed: boolean;
            impliedArity?: number;
        }
        enum InferenceFlags {
            None = 0,
            NoDefault = 1,
            AnyDefault = 2,
            SkippedGenericFunction = 4
        }
        enum Ternary {
            False = 0,
            Unknown = 1,
            Maybe = 3,
            True = -1
        }
        type TypeComparer = (s: Type, t: Type, reportErrors?: boolean) => Ternary;
        interface InferenceContext {
            inferences: InferenceInfo[];
            signature?: Signature;
            flags: InferenceFlags;
            compareTypes: TypeComparer;
            mapper: TypeMapper;
            nonFixingMapper: TypeMapper;
            returnMapper?: TypeMapper;
            inferredTypeParameters?: readonly TypeParameter[];
            intraExpressionInferenceSites?: IntraExpressionInferenceSite[];
        }
        interface IntraExpressionInferenceSite {
            node: Expression | MethodDeclaration;
            type: Type;
        }
        interface WideningContext {
            parent?: WideningContext;
            propertyName?: __String;
            siblings?: Type[];
            resolvedProperties?: Symbol[];
        }
        enum AssignmentDeclarationKind {
            None = 0,
            ExportsProperty = 1,
            ModuleExports = 2,
            PrototypeProperty = 3,
            ThisProperty = 4,
            Property = 5,
            Prototype = 6,
            ObjectDefinePropertyValue = 7,
            ObjectDefinePropertyExports = 8,
            ObjectDefinePrototypeProperty = 9
        }
        interface FileExtensionInfo {
            extension: string;
            isMixedContent: boolean;
            scriptKind?: ScriptKind;
        }
        interface DiagnosticMessage {
            key: string;
            category: DiagnosticCategory;
            code: number;
            message: string;
            reportsUnnecessary?: {};
            reportsDeprecated?: {};
            elidedInCompatabilityPyramid?: boolean;
        }
        interface RepopulateModuleNotFoundDiagnosticChain {
            moduleReference: string;
            mode: ResolutionMode;
            packageName: string | undefined;
        }
        type RepopulateModeMismatchDiagnosticChain = true;
        type RepopulateDiagnosticChainInfo = RepopulateModuleNotFoundDiagnosticChain | RepopulateModeMismatchDiagnosticChain;
        interface DiagnosticMessageChain {
            messageText: string;
            category: DiagnosticCategory;
            code: number;
            next?: DiagnosticMessageChain[];
            repopulateInfo?: () => RepopulateDiagnosticChainInfo;
            canonicalHead?: CanonicalDiagnostic;
        }
        interface Diagnostic extends DiagnosticRelatedInformation {
            reportsUnnecessary?: {};
            reportsDeprecated?: {};
            source?: string;
            relatedInformation?: DiagnosticRelatedInformation[];
            skippedOn?: keyof CompilerOptions;
            canonicalHead?: CanonicalDiagnostic;
        }
        interface CanonicalDiagnostic {
            code: number;
            messageText: string;
        }
        type DiagnosticArguments = (string | number)[];
        type DiagnosticAndArguments = [
            message: DiagnosticMessage,
            ...args: DiagnosticArguments
        ];
        interface DiagnosticRelatedInformation {
            category: DiagnosticCategory;
            code: number;
            file: SourceFile | undefined;
            start: number | undefined;
            length: number | undefined;
            messageText: string | DiagnosticMessageChain;
        }
        interface DiagnosticWithLocation extends Diagnostic {
            file: SourceFile;
            start: number;
            length: number;
        }
        interface DiagnosticWithDetachedLocation extends Diagnostic {
            file: undefined;
            fileName: string;
            start: number;
            length: number;
        }
        enum DiagnosticCategory {
            Warning = 0,
            Error = 1,
            Suggestion = 2,
            Message = 3
        }
        enum ModuleResolutionKind {
            Classic = 1,
            NodeJs = 2,
            Node10 = 2,
            Node16 = 3,
            NodeNext = 99,
            Bundler = 100
        }
        enum ModuleDetectionKind {
            Legacy = 1,
            Auto = 2,
            Force = 3
        }
        interface PluginImport {
            name: string;
        }
        interface ProjectReference {
            path: string;
            originalPath?: string;
            prepend?: boolean;
            circular?: boolean;
        }
        enum WatchFileKind {
            FixedPollingInterval = 0,
            PriorityPollingInterval = 1,
            DynamicPriorityPolling = 2,
            FixedChunkSizePolling = 3,
            UseFsEvents = 4,
            UseFsEventsOnParentDirectory = 5
        }
        enum WatchDirectoryKind {
            UseFsEvents = 0,
            FixedPollingInterval = 1,
            DynamicPriorityPolling = 2,
            FixedChunkSizePolling = 3
        }
        enum PollingWatchKind {
            FixedInterval = 0,
            PriorityInterval = 1,
            DynamicPriority = 2,
            FixedChunkSize = 3
        }
        type CompilerOptionsValue = string | number | boolean | (string | number)[] | string[] | MapLike<string[]> | PluginImport[] | ProjectReference[] | null | undefined;
        interface CompilerOptions {
            all?: boolean;
            allowImportingTsExtensions?: boolean;
            allowJs?: boolean;
            allowNonTsExtensions?: boolean;
            allowArbitraryExtensions?: boolean;
            allowSyntheticDefaultImports?: boolean;
            allowUmdGlobalAccess?: boolean;
            allowUnreachableCode?: boolean;
            allowUnusedLabels?: boolean;
            alwaysStrict?: boolean;
            baseUrl?: string;
            build?: boolean;
            charset?: string;
            checkJs?: boolean;
            configFilePath?: string;
            readonly configFile?: TsConfigSourceFile;
            customConditions?: string[];
            declaration?: boolean;
            declarationMap?: boolean;
            emitDeclarationOnly?: boolean;
            declarationDir?: string;
            diagnostics?: boolean;
            extendedDiagnostics?: boolean;
            disableSizeLimit?: boolean;
            disableSourceOfProjectReferenceRedirect?: boolean;
            disableSolutionSearching?: boolean;
            disableReferencedProjectLoad?: boolean;
            downlevelIteration?: boolean;
            emitBOM?: boolean;
            emitDecoratorMetadata?: boolean;
            exactOptionalPropertyTypes?: boolean;
            experimentalDecorators?: boolean;
            forceConsistentCasingInFileNames?: boolean;
            generateCpuProfile?: string;
            generateTrace?: string;
            help?: boolean;
            ignoreDeprecations?: string;
            importHelpers?: boolean;
            importsNotUsedAsValues?: ImportsNotUsedAsValues;
            init?: boolean;
            inlineSourceMap?: boolean;
            inlineSources?: boolean;
            isolatedModules?: boolean;
            isolatedDeclarations?: boolean;
            jsx?: JsxEmit;
            keyofStringsOnly?: boolean;
            lib?: string[];
            libReplacement?: boolean;
            listEmittedFiles?: boolean;
            listFiles?: boolean;
            explainFiles?: boolean;
            listFilesOnly?: boolean;
            locale?: string;
            mapRoot?: string;
            maxNodeModuleJsDepth?: number;
            module?: ModuleKind;
            moduleResolution?: ModuleResolutionKind;
            moduleSuffixes?: string[];
            moduleDetection?: ModuleDetectionKind;
            newLine?: NewLineKind;
            noEmit?: boolean;
            noCheck?: boolean;
            noEmitForJsFiles?: boolean;
            noEmitHelpers?: boolean;
            noEmitOnError?: boolean;
            noErrorTruncation?: boolean;
            noFallthroughCasesInSwitch?: boolean;
            noImplicitAny?: boolean;
            noImplicitReturns?: boolean;
            noImplicitThis?: boolean;
            noStrictGenericChecks?: boolean;
            noUnusedLocals?: boolean;
            noUnusedParameters?: boolean;
            noImplicitUseStrict?: boolean;
            noPropertyAccessFromIndexSignature?: boolean;
            assumeChangesOnlyAffectDirectDependencies?: boolean;
            noLib?: boolean;
            noResolve?: boolean;
            noDtsResolution?: boolean;
            noUncheckedIndexedAccess?: boolean;
            out?: string;
            outDir?: string;
            outFile?: string;
            paths?: MapLike<string[]>;
            pathsBasePath?: string;
            plugins?: PluginImport[];
            preserveConstEnums?: boolean;
            noImplicitOverride?: boolean;
            preserveSymlinks?: boolean;
            preserveValueImports?: boolean;
            preserveWatchOutput?: boolean;
            project?: string;
            pretty?: boolean;
            reactNamespace?: string;
            jsxFactory?: string;
            jsxFragmentFactory?: string;
            jsxImportSource?: string;
            composite?: boolean;
            incremental?: boolean;
            tsBuildInfoFile?: string;
            removeComments?: boolean;
            resolvePackageJsonExports?: boolean;
            resolvePackageJsonImports?: boolean;
            rewriteRelativeImportExtensions?: boolean;
            rootDir?: string;
            rootDirs?: string[];
            skipLibCheck?: boolean;
            skipDefaultLibCheck?: boolean;
            sourceMap?: boolean;
            sourceRoot?: string;
            strict?: boolean;
            strictFunctionTypes?: boolean;
            strictBindCallApply?: boolean;
            strictNullChecks?: boolean;
            strictPropertyInitialization?: boolean;
            strictBuiltinIteratorReturn?: boolean;
            stripInternal?: boolean;
            suppressExcessPropertyErrors?: boolean;
            suppressImplicitAnyIndexErrors?: boolean;
            suppressOutputPathCheck?: boolean;
            target?: ScriptTarget;
            traceResolution?: boolean;
            useUnknownInCatchVariables?: boolean;
            noUncheckedSideEffectImports?: boolean;
            resolveJsonModule?: boolean;
            types?: string[];
            typeRoots?: string[];
            verbatimModuleSyntax?: boolean;
            erasableSyntaxOnly?: boolean;
            version?: boolean;
            watch?: boolean;
            esModuleInterop?: boolean;
            showConfig?: boolean;
            useDefineForClassFields?: boolean;
            tscBuild?: boolean;
            [option: string]: CompilerOptionsValue | TsConfigSourceFile | undefined;
        }
        interface WatchOptions {
            watchFile?: WatchFileKind;
            watchDirectory?: WatchDirectoryKind;
            fallbackPolling?: PollingWatchKind;
            synchronousWatchDirectory?: boolean;
            excludeDirectories?: string[];
            excludeFiles?: string[];
            [option: string]: CompilerOptionsValue | undefined;
        }
        interface TypeAcquisition {
            enable?: boolean;
            include?: string[];
            exclude?: string[];
            disableFilenameBasedTypeAcquisition?: boolean;
            [option: string]: CompilerOptionsValue | undefined;
        }
        enum ModuleKind {
            None = 0,
            CommonJS = 1,
            AMD = 2,
            UMD = 3,
            System = 4,
            ES2015 = 5,
            ES2020 = 6,
            ES2022 = 7,
            ESNext = 99,
            Node16 = 100,
            Node18 = 101,
            NodeNext = 199,
            Preserve = 200
        }
        enum JsxEmit {
            None = 0,
            Preserve = 1,
            React = 2,
            ReactNative = 3,
            ReactJSX = 4,
            ReactJSXDev = 5
        }
        enum ImportsNotUsedAsValues {
            Remove = 0,
            Preserve = 1,
            Error = 2
        }
        enum NewLineKind {
            CarriageReturnLineFeed = 0,
            LineFeed = 1
        }
        interface LineAndCharacter {
            line: number;
            character: number;
        }
        enum ScriptKind {
            Unknown = 0,
            JS = 1,
            JSX = 2,
            TS = 3,
            TSX = 4,
            External = 5,
            JSON = 6,
            Deferred = 7
        }
        enum ScriptTarget {
            ES3 = 0,
            ES5 = 1,
            ES2015 = 2,
            ES2016 = 3,
            ES2017 = 4,
            ES2018 = 5,
            ES2019 = 6,
            ES2020 = 7,
            ES2021 = 8,
            ES2022 = 9,
            ES2023 = 10,
            ES2024 = 11,
            ESNext = 99,
            JSON = 100,
            Latest = 99
        }
        enum LanguageVariant {
            Standard = 0,
            JSX = 1
        }
        interface ParsedCommandLine {
            options: CompilerOptions;
            typeAcquisition?: TypeAcquisition;
            fileNames: string[];
            projectReferences?: readonly ProjectReference[];
            watchOptions?: WatchOptions;
            raw?: any;
            errors: Diagnostic[];
            wildcardDirectories?: MapLike<WatchDirectoryFlags>;
            compileOnSave?: boolean;
        }
        enum WatchDirectoryFlags {
            None = 0,
            Recursive = 1
        }
        interface ConfigFileSpecs {
            filesSpecs: readonly string[] | undefined;
            includeSpecs: readonly string[] | undefined;
            excludeSpecs: readonly string[] | undefined;
            validatedFilesSpec: readonly string[] | undefined;
            validatedIncludeSpecs: readonly string[] | undefined;
            validatedExcludeSpecs: readonly string[] | undefined;
            validatedFilesSpecBeforeSubstitution: readonly string[] | undefined;
            validatedIncludeSpecsBeforeSubstitution: readonly string[] | undefined;
            validatedExcludeSpecsBeforeSubstitution: readonly string[] | undefined;
            isDefaultIncludeSpec: boolean;
        }
        type ModuleImportResult<T = {}> = {
            module: T;
            modulePath?: string;
            error: undefined;
        } | {
            module: undefined;
            modulePath?: undefined;
            error: {
                stack?: string;
                message?: string;
            };
        };
        interface CreateProgramOptions {
            rootNames: readonly string[];
            options: CompilerOptions;
            projectReferences?: readonly ProjectReference[];
            host?: CompilerHost;
            oldProgram?: Program;
            configFileParsingDiagnostics?: readonly Diagnostic[];
            typeScriptVersion?: string;
        }
        interface CommandLineOptionBase {
            name: string;
            type: "string" | "number" | "boolean" | "object" | "list" | "listOrElement" | Map<string, number | string>;
            isFilePath?: boolean;
            shortName?: string;
            description?: DiagnosticMessage;
            defaultValueDescription?: string | number | boolean | DiagnosticMessage | undefined;
            paramType?: DiagnosticMessage;
            isTSConfigOnly?: boolean;
            isCommandLineOnly?: boolean;
            showInSimplifiedHelpView?: boolean;
            category?: DiagnosticMessage;
            strictFlag?: true;
            allowJsFlag?: true;
            affectsSourceFile?: true;
            affectsModuleResolution?: true;
            affectsBindDiagnostics?: true;
            affectsSemanticDiagnostics?: true;
            affectsEmit?: true;
            affectsProgramStructure?: true;
            affectsDeclarationPath?: true;
            affectsBuildInfo?: true;
            transpileOptionValue?: boolean | undefined;
            extraValidation?: (value: CompilerOptionsValue) => [
                DiagnosticMessage,
                ...string[]
            ] | undefined;
            disallowNullOrUndefined?: true;
            allowConfigDirTemplateSubstitution?: true;
        }
        interface CommandLineOptionOfStringType extends CommandLineOptionBase {
            type: "string";
            defaultValueDescription?: string | undefined | DiagnosticMessage;
        }
        interface CommandLineOptionOfNumberType extends CommandLineOptionBase {
            type: "number";
            defaultValueDescription: number | undefined | DiagnosticMessage;
        }
        interface CommandLineOptionOfBooleanType extends CommandLineOptionBase {
            type: "boolean";
            defaultValueDescription: boolean | undefined | DiagnosticMessage;
        }
        interface CommandLineOptionOfCustomType extends CommandLineOptionBase {
            type: Map<string, number | string>;
            defaultValueDescription: number | string | undefined | DiagnosticMessage;
            deprecatedKeys?: Set<string>;
        }
        interface AlternateModeDiagnostics {
            diagnostic: DiagnosticMessage;
            getOptionsNameMap: () => OptionsNameMap;
        }
        interface DidYouMeanOptionsDiagnostics {
            alternateMode?: AlternateModeDiagnostics;
            optionDeclarations: CommandLineOption[];
            unknownOptionDiagnostic: DiagnosticMessage;
            unknownDidYouMeanDiagnostic: DiagnosticMessage;
        }
        interface TsConfigOnlyOption extends CommandLineOptionBase {
            type: "object";
            elementOptions?: Map<string, CommandLineOption>;
            extraKeyDiagnostics?: DidYouMeanOptionsDiagnostics;
        }
        interface CommandLineOptionOfListType extends CommandLineOptionBase {
            type: "list" | "listOrElement";
            element: CommandLineOptionOfCustomType | CommandLineOptionOfStringType | CommandLineOptionOfNumberType | CommandLineOptionOfBooleanType | TsConfigOnlyOption;
            listPreserveFalsyValues?: boolean;
        }
        type CommandLineOption = CommandLineOptionOfCustomType | CommandLineOptionOfStringType | CommandLineOptionOfNumberType | CommandLineOptionOfBooleanType | TsConfigOnlyOption | CommandLineOptionOfListType;
        enum CharacterCodes {
            EOF = -1,
            nullCharacter = 0,
            maxAsciiCharacter = 127,
            lineFeed = 10,
            carriageReturn = 13,
            lineSeparator = 8232,
            paragraphSeparator = 8233,
            nextLine = 133,
            space = 32,
            nonBreakingSpace = 160,
            enQuad = 8192,
            emQuad = 8193,
            enSpace = 8194,
            emSpace = 8195,
            threePerEmSpace = 8196,
            fourPerEmSpace = 8197,
            sixPerEmSpace = 8198,
            figureSpace = 8199,
            punctuationSpace = 8200,
            thinSpace = 8201,
            hairSpace = 8202,
            zeroWidthSpace = 8203,
            narrowNoBreakSpace = 8239,
            ideographicSpace = 12288,
            mathematicalSpace = 8287,
            ogham = 5760,
            replacementCharacter = 65533,
            _ = 95,
            $ = 36,
            _0 = 48,
            _1 = 49,
            _2 = 50,
            _3 = 51,
            _4 = 52,
            _5 = 53,
            _6 = 54,
            _7 = 55,
            _8 = 56,
            _9 = 57,
            a = 97,
            b = 98,
            c = 99,
            d = 100,
            e = 101,
            f = 102,
            g = 103,
            h = 104,
            i = 105,
            j = 106,
            k = 107,
            l = 108,
            m = 109,
            n = 110,
            o = 111,
            p = 112,
            q = 113,
            r = 114,
            s = 115,
            t = 116,
            u = 117,
            v = 118,
            w = 119,
            x = 120,
            y = 121,
            z = 122,
            A = 65,
            B = 66,
            C = 67,
            D = 68,
            E = 69,
            F = 70,
            G = 71,
            H = 72,
            I = 73,
            J = 74,
            K = 75,
            L = 76,
            M = 77,
            N = 78,
            O = 79,
            P = 80,
            Q = 81,
            R = 82,
            S = 83,
            T = 84,
            U = 85,
            V = 86,
            W = 87,
            X = 88,
            Y = 89,
            Z = 90,
            ampersand = 38,
            asterisk = 42,
            at = 64,
            backslash = 92,
            backtick = 96,
            bar = 124,
            caret = 94,
            closeBrace = 125,
            closeBracket = 93,
            closeParen = 41,
            colon = 58,
            comma = 44,
            dot = 46,
            doubleQuote = 34,
            equals = 61,
            exclamation = 33,
            greaterThan = 62,
            hash = 35,
            lessThan = 60,
            minus = 45,
            openBrace = 123,
            openBracket = 91,
            openParen = 40,
            percent = 37,
            plus = 43,
            question = 63,
            semicolon = 59,
            singleQuote = 39,
            slash = 47,
            tilde = 126,
            backspace = 8,
            formFeed = 12,
            byteOrderMark = 65279,
            tab = 9,
            verticalTab = 11
        }
        interface ModuleResolutionHost {
            fileExists(fileName: string): boolean;
            readFile(fileName: string): string | undefined;
            trace?(s: string): void;
            directoryExists?(directoryName: string): boolean;
            realpath?(path: string): string;
            getCurrentDirectory?(): string;
            getDirectories?(path: string): string[];
            useCaseSensitiveFileNames?: boolean | (() => boolean) | undefined;
            getGlobalTypingsCacheLocation?(): string | undefined;
        }
        interface MinimalResolutionCacheHost extends ModuleResolutionHost {
            getCompilationSettings(): CompilerOptions;
            getCompilerHost?(): CompilerHost | undefined;
        }
        interface ResolvedModule {
            resolvedFileName: string;
            isExternalLibraryImport?: boolean;
            resolvedUsingTsExtension?: boolean;
        }
        interface ResolvedModuleFull extends ResolvedModule {
            readonly originalPath?: string;
            extension: string;
            packageId?: PackageId;
        }
        interface PackageId {
            name: string;
            subModuleName: string;
            version: string;
            peerDependencies?: string;
        }
        enum Extension {
            Ts = ".ts",
            Tsx = ".tsx",
            Dts = ".d.ts",
            Js = ".js",
            Jsx = ".jsx",
            Json = ".json",
            TsBuildInfo = ".tsbuildinfo",
            Mjs = ".mjs",
            Mts = ".mts",
            Dmts = ".d.mts",
            Cjs = ".cjs",
            Cts = ".cts",
            Dcts = ".d.cts"
        }
        interface ResolvedModuleWithFailedLookupLocations {
            readonly resolvedModule: ResolvedModuleFull | undefined;
            failedLookupLocations?: string[];
            affectingLocations?: string[];
            resolutionDiagnostics?: Diagnostic[];
            alternateResult?: string;
        }
        interface ResolvedTypeReferenceDirective {
            primary: boolean;
            resolvedFileName: string | undefined;
            originalPath?: string;
            packageId?: PackageId;
            isExternalLibraryImport?: boolean;
        }
        interface ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
            readonly resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | undefined;
            failedLookupLocations?: string[];
            affectingLocations?: string[];
            resolutionDiagnostics?: Diagnostic[];
        }
        type HasInvalidatedResolutions = (sourceFile: Path) => boolean;
        type HasInvalidatedLibResolutions = (libFileName: string) => boolean;
        type HasChangedAutomaticTypeDirectiveNames = () => boolean;
        interface CompilerHost extends ModuleResolutionHost {
            getSourceFile(fileName: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;
            getSourceFileByPath?(fileName: string, path: Path, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;
            getCancellationToken?(): CancellationToken;
            getDefaultLibFileName(options: CompilerOptions): string;
            getDefaultLibLocation?(): string;
            writeFile: WriteFileCallback;
            getCurrentDirectory(): string;
            getCanonicalFileName(fileName: string): string;
            useCaseSensitiveFileNames(): boolean;
            getNewLine(): string;
            readDirectory?(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): string[];
            resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];
            getModuleResolutionCache?(): ModuleResolutionCache | undefined;
            resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];
            resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];
            resolveTypeReferenceDirectiveReferences?<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];
            resolveLibrary?(libraryName: string, resolveFrom: string, options: CompilerOptions, libFileName: string): ResolvedModuleWithFailedLookupLocations;
            hasInvalidatedLibResolutions?(libFileName: string): boolean;
            getEnvironmentVariable?(name: string): string | undefined;
            onReleaseOldSourceFile?(oldSourceFile: SourceFile, oldOptions: CompilerOptions, hasSourceFileByPath: boolean, newSourceFileByResolvedPath: SourceFile | undefined): void;
            onReleaseParsedCommandLine?(configFileName: string, oldResolvedRef: ResolvedProjectReference | undefined, optionOptions: CompilerOptions): void;
            hasInvalidatedResolutions?(filePath: Path): boolean;
            hasChangedAutomaticTypeDirectiveNames?: HasChangedAutomaticTypeDirectiveNames;
            createHash?(data: string): string;
            getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
            useSourceOfProjectReferenceRedirect?(): boolean;
            createDirectory?(directory: string): void;
            getSymlinkCache?(): SymlinkCache;
            storeSignatureInfo?: boolean;
            getBuildInfo?(fileName: string, configFilePath: string | undefined): BuildInfo | undefined;
            jsDocParsingMode?: JSDocParsingMode;
        }
        type SourceOfProjectReferenceRedirect = string | true;
        enum TransformFlags {
            None = 0,
            ContainsTypeScript = 1,
            ContainsJsx = 2,
            ContainsESNext = 4,
            ContainsES2022 = 8,
            ContainsES2021 = 16,
            ContainsES2020 = 32,
            ContainsES2019 = 64,
            ContainsES2018 = 128,
            ContainsES2017 = 256,
            ContainsES2016 = 512,
            ContainsES2015 = 1024,
            ContainsGenerator = 2048,
            ContainsDestructuringAssignment = 4096,
            ContainsTypeScriptClassSyntax = 8192,
            ContainsLexicalThis = 16384,
            ContainsRestOrSpread = 32768,
            ContainsObjectRestOrSpread = 65536,
            ContainsComputedPropertyName = 131072,
            ContainsBlockScopedBinding = 262144,
            ContainsBindingPattern = 524288,
            ContainsYield = 1048576,
            ContainsAwait = 2097152,
            ContainsHoistedDeclarationOrCompletion = 4194304,
            ContainsDynamicImport = 8388608,
            ContainsClassFields = 16777216,
            ContainsDecorators = 33554432,
            ContainsPossibleTopLevelAwait = 67108864,
            ContainsLexicalSuper = 134217728,
            ContainsUpdateExpressionForIdentifier = 268435456,
            ContainsPrivateIdentifierInExpression = 536870912,
            HasComputedFlags = -2147483648,
            AssertTypeScript = 1,
            AssertJsx = 2,
            AssertESNext = 4,
            AssertES2022 = 8,
            AssertES2021 = 16,
            AssertES2020 = 32,
            AssertES2019 = 64,
            AssertES2018 = 128,
            AssertES2017 = 256,
            AssertES2016 = 512,
            AssertES2015 = 1024,
            AssertGenerator = 2048,
            AssertDestructuringAssignment = 4096,
            OuterExpressionExcludes = -2147483648,
            PropertyAccessExcludes = -2147483648,
            NodeExcludes = -2147483648,
            ArrowFunctionExcludes = -2072174592,
            FunctionExcludes = -1937940480,
            ConstructorExcludes = -1937948672,
            MethodOrAccessorExcludes = -2005057536,
            PropertyExcludes = -2013249536,
            ClassExcludes = -2147344384,
            ModuleExcludes = -1941676032,
            TypeExcludes = -2,
            ObjectLiteralExcludes = -2147278848,
            ArrayLiteralOrCallOrNewExcludes = -2147450880,
            VariableDeclarationListExcludes = -2146893824,
            ParameterExcludes = -2147483648,
            CatchClauseExcludes = -2147418112,
            BindingPatternExcludes = -2147450880,
            ContainsLexicalThisOrSuper = 134234112,
            PropertyNamePropagatingFlags = 134234112
        }
        interface SourceMapRange extends TextRange {
            source?: SourceMapSource;
        }
        interface SourceMapSource {
            fileName: string;
            text: string;
            lineMap: readonly number[];
            skipTrivia?: (pos: number) => number;
        }
        interface SourceMapSource {
            getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
        }
        interface EmitNode {
            flags: EmitFlags;
            internalFlags: InternalEmitFlags;
            annotatedNodes?: Node[];
            leadingComments?: SynthesizedComment[];
            trailingComments?: SynthesizedComment[];
            commentRange?: TextRange;
            sourceMapRange?: SourceMapRange;
            tokenSourceMapRanges?: (SourceMapRange | undefined)[];
            constantValue?: string | number;
            externalHelpersModuleName?: Identifier;
            externalHelpers?: boolean;
            helpers?: EmitHelper[];
            startsOnNewLine?: boolean;
            snippetElement?: SnippetElement;
            typeNode?: TypeNode;
            classThis?: Identifier;
            assignedName?: Expression;
            identifierTypeArguments?: NodeArray<TypeNode | TypeParameterDeclaration>;
            autoGenerate: AutoGenerateInfo | undefined;
            generatedImportReference?: ImportSpecifier;
        }
        type SnippetElement = TabStop | Placeholder;
        interface TabStop {
            kind: SnippetKind.TabStop;
            order: number;
        }
        interface Placeholder {
            kind: SnippetKind.Placeholder;
            order: number;
        }
        enum SnippetKind {
            TabStop = 0,
            Placeholder = 1,
            Choice = 2,
            Variable = 3
        }
        enum EmitFlags {
            None = 0,
            SingleLine = 1,
            MultiLine = 2,
            AdviseOnEmitNode = 4,
            NoSubstitution = 8,
            CapturesThis = 16,
            NoLeadingSourceMap = 32,
            NoTrailingSourceMap = 64,
            NoSourceMap = 96,
            NoNestedSourceMaps = 128,
            NoTokenLeadingSourceMaps = 256,
            NoTokenTrailingSourceMaps = 512,
            NoTokenSourceMaps = 768,
            NoLeadingComments = 1024,
            NoTrailingComments = 2048,
            NoComments = 3072,
            NoNestedComments = 4096,
            HelperName = 8192,
            ExportName = 16384,
            LocalName = 32768,
            InternalName = 65536,
            Indented = 131072,
            NoIndentation = 262144,
            AsyncFunctionBody = 524288,
            ReuseTempVariableScope = 1048576,
            CustomPrologue = 2097152,
            NoHoisting = 4194304,
            Iterator = 8388608,
            NoAsciiEscaping = 16777216
        }
        enum InternalEmitFlags {
            None = 0,
            TypeScriptClassWrapper = 1,
            NeverApplyImportHelper = 2,
            IgnoreSourceNewlines = 4,
            Immutable = 8,
            IndirectCall = 16,
            TransformPrivateStaticElements = 32
        }
        interface EmitHelperBase {
            readonly name: string;
            readonly scoped: boolean;
            readonly text: string | ((node: EmitHelperUniqueNameCallback) => string);
            readonly priority?: number;
            readonly dependencies?: EmitHelper[];
        }
        interface ScopedEmitHelper extends EmitHelperBase {
            readonly scoped: true;
        }
        interface UnscopedEmitHelper extends EmitHelperBase {
            readonly scoped: false;
            readonly importName?: string;
            readonly text: string;
        }
        type EmitHelper = ScopedEmitHelper | UnscopedEmitHelper;
        type EmitHelperUniqueNameCallback = (name: string) => string;
        type LanugageFeatures = "Classes" | "ForOf" | "Generators" | "Iteration" | "SpreadElements" | "RestElements" | "TaggedTemplates" | "DestructuringAssignment" | "BindingPatterns" | "ArrowFunctions" | "BlockScopedVariables" | "ObjectAssign" | "RegularExpressionFlagsUnicode" | "RegularExpressionFlagsSticky" | "Exponentiation" | "AsyncFunctions" | "ForAwaitOf" | "AsyncGenerators" | "AsyncIteration" | "ObjectSpreadRest" | "RegularExpressionFlagsDotAll" | "BindinglessCatch" | "BigInt" | "NullishCoalesce" | "OptionalChaining" | "LogicalAssignment" | "TopLevelAwait" | "ClassFields" | "PrivateNamesAndClassStaticBlocks" | "RegularExpressionFlagsHasIndices" | "ShebangComments" | "RegularExpressionFlagsUnicodeSets" | "UsingAndAwaitUsing" | "ClassAndClassElementDecorators";
        const LanguageFeatureMinimumTarget: Record<LanugageFeatures, ScriptTarget>;
        enum ExternalEmitHelpers {
            Extends = 1,
            Assign = 2,
            Rest = 4,
            Decorate = 8,
            ESDecorateAndRunInitializers = 8,
            Metadata = 16,
            Param = 32,
            Awaiter = 64,
            Generator = 128,
            Values = 256,
            Read = 512,
            SpreadArray = 1024,
            Await = 2048,
            AsyncGenerator = 4096,
            AsyncDelegator = 8192,
            AsyncValues = 16384,
            ExportStar = 32768,
            ImportStar = 65536,
            ImportDefault = 131072,
            MakeTemplateObject = 262144,
            ClassPrivateFieldGet = 524288,
            ClassPrivateFieldSet = 1048576,
            ClassPrivateFieldIn = 2097152,
            SetFunctionName = 4194304,
            PropKey = 8388608,
            AddDisposableResourceAndDisposeResources = 16777216,
            RewriteRelativeImportExtension = 33554432,
            FirstEmitHelper = 1,
            LastEmitHelper = 16777216,
            ForOfIncludes = 256,
            ForAwaitOfIncludes = 16384,
            AsyncGeneratorIncludes = 6144,
            AsyncDelegatorIncludes = 26624,
            SpreadIncludes = 1536
        }
        enum EmitHint {
            SourceFile = 0,
            Expression = 1,
            IdentifierName = 2,
            MappedTypeParameter = 3,
            Unspecified = 4,
            EmbeddedStatement = 5,
            JsxAttributeValue = 6,
            ImportTypeNodeAttributes = 7
        }
        interface SourceFileMayBeEmittedHost {
            getCompilerOptions(): CompilerOptions;
            isSourceFileFromExternalLibrary(file: SourceFile): boolean;
            getResolvedProjectReferenceToRedirect(fileName: string): ResolvedProjectReference | undefined;
            isSourceOfProjectReferenceRedirect(fileName: string): boolean;
            getCurrentDirectory(): string;
            getCanonicalFileName: GetCanonicalFileName;
            useCaseSensitiveFileNames(): boolean;
        }
        interface EmitHost extends ScriptReferenceHost, ModuleSpecifierResolutionHost, SourceFileMayBeEmittedHost {
            getSourceFiles(): readonly SourceFile[];
            useCaseSensitiveFileNames(): boolean;
            getCurrentDirectory(): string;
            getCommonSourceDirectory(): string;
            getCanonicalFileName(fileName: string): string;
            isEmitBlocked(emitFileName: string): boolean;
            shouldTransformImportCall(sourceFile: SourceFile): boolean;
            getEmitModuleFormatOfFile(sourceFile: SourceFile): ModuleKind;
            writeFile: WriteFileCallback;
            getBuildInfo(): BuildInfo | undefined;
            getSourceFileFromReference: Program["getSourceFileFromReference"];
            readonly redirectTargetsMap: RedirectTargetsMap;
            createHash?(data: string): string;
        }
        interface PropertyDescriptorAttributes {
            enumerable?: boolean | Expression;
            configurable?: boolean | Expression;
            writable?: boolean | Expression;
            value?: Expression;
            get?: Expression;
            set?: Expression;
        }
        enum OuterExpressionKinds {
            Parentheses = 1,
            TypeAssertions = 2,
            NonNullAssertions = 4,
            PartiallyEmittedExpressions = 8,
            ExpressionsWithTypeArguments = 16,
            Satisfies = 32,
            Assertions = 38,
            All = 63,
            ExcludeJSDocTypeAssertion = -2147483648
        }
        type OuterExpression = ParenthesizedExpression | TypeAssertion | SatisfiesExpression | AsExpression | NonNullExpression | ExpressionWithTypeArguments | PartiallyEmittedExpression;
        type WrappedExpression<T extends Expression> = OuterExpression & {
            readonly expression: WrappedExpression<T>;
        } | T;
        type TypeOfTag = "null" | "undefined" | "number" | "bigint" | "boolean" | "string" | "symbol" | "object" | "function";
        interface CallBinding {
            target: LeftHandSideExpression;
            thisArg: Expression;
        }
        interface ParenthesizerRules {
            getParenthesizeLeftSideOfBinaryForOperator(binaryOperator: SyntaxKind): (leftSide: Expression) => Expression;
            getParenthesizeRightSideOfBinaryForOperator(binaryOperator: SyntaxKind): (rightSide: Expression) => Expression;
            parenthesizeLeftSideOfBinary(binaryOperator: SyntaxKind, leftSide: Expression): Expression;
            parenthesizeRightSideOfBinary(binaryOperator: SyntaxKind, leftSide: Expression | undefined, rightSide: Expression): Expression;
            parenthesizeExpressionOfComputedPropertyName(expression: Expression): Expression;
            parenthesizeConditionOfConditionalExpression(condition: Expression): Expression;
            parenthesizeBranchOfConditionalExpression(branch: Expression): Expression;
            parenthesizeExpressionOfExportDefault(expression: Expression): Expression;
            parenthesizeExpressionOfNew(expression: Expression): LeftHandSideExpression;
            parenthesizeLeftSideOfAccess(expression: Expression, optionalChain?: boolean): LeftHandSideExpression;
            parenthesizeOperandOfPostfixUnary(operand: Expression): LeftHandSideExpression;
            parenthesizeOperandOfPrefixUnary(operand: Expression): UnaryExpression;
            parenthesizeExpressionsOfCommaDelimitedList(elements: readonly Expression[]): NodeArray<Expression>;
            parenthesizeExpressionForDisallowedComma(expression: Expression): Expression;
            parenthesizeExpressionOfExpressionStatement(expression: Expression): Expression;
            parenthesizeConciseBodyOfArrowFunction(body: Expression): Expression;
            parenthesizeConciseBodyOfArrowFunction(body: ConciseBody): ConciseBody;
            parenthesizeCheckTypeOfConditionalType(type: TypeNode): TypeNode;
            parenthesizeExtendsTypeOfConditionalType(type: TypeNode): TypeNode;
            parenthesizeOperandOfTypeOperator(type: TypeNode): TypeNode;
            parenthesizeOperandOfReadonlyTypeOperator(type: TypeNode): TypeNode;
            parenthesizeNonArrayTypeOfPostfixType(type: TypeNode): TypeNode;
            parenthesizeElementTypesOfTupleType(types: readonly (TypeNode | NamedTupleMember)[]): NodeArray<TypeNode>;
            parenthesizeElementTypeOfTupleType(type: TypeNode | NamedTupleMember): TypeNode | NamedTupleMember;
            parenthesizeTypeOfOptionalType(type: TypeNode): TypeNode;
            parenthesizeConstituentTypeOfUnionType(type: TypeNode): TypeNode;
            parenthesizeConstituentTypesOfUnionType(constituents: readonly TypeNode[]): NodeArray<TypeNode>;
            parenthesizeConstituentTypeOfIntersectionType(type: TypeNode): TypeNode;
            parenthesizeConstituentTypesOfIntersectionType(constituents: readonly TypeNode[]): NodeArray<TypeNode>;
            parenthesizeLeadingTypeArgument(typeNode: TypeNode): TypeNode;
            parenthesizeTypeArguments(typeParameters: readonly TypeNode[] | undefined): NodeArray<TypeNode> | undefined;
        }
        interface NodeConverters {
            convertToFunctionBlock(node: ConciseBody, multiLine?: boolean): Block;
            convertToFunctionExpression(node: FunctionDeclaration): FunctionExpression;
            convertToClassExpression(node: ClassDeclaration): ClassExpression;
            convertToArrayAssignmentElement(element: ArrayBindingOrAssignmentElement): Expression;
            convertToObjectAssignmentElement(element: ObjectBindingOrAssignmentElement): ObjectLiteralElementLike;
            convertToAssignmentPattern(node: BindingOrAssignmentPattern): AssignmentPattern;
            convertToObjectAssignmentPattern(node: ObjectBindingOrAssignmentPattern): ObjectLiteralExpression;
            convertToArrayAssignmentPattern(node: ArrayBindingOrAssignmentPattern): ArrayLiteralExpression;
            convertToAssignmentElementTarget(node: BindingOrAssignmentElementTarget): Expression;
        }
        interface GeneratedNamePart {
            prefix?: string;
            node: Identifier | PrivateIdentifier;
            suffix?: string;
        }
        type ImmediatelyInvokedFunctionExpression = CallExpression & {
            readonly expression: FunctionExpression;
        };
        type ImmediatelyInvokedArrowFunction = CallExpression & {
            readonly expression: ParenthesizedExpression & {
                readonly expression: ArrowFunction;
            };
        };
        interface NodeFactory {
            readonly parenthesizer: ParenthesizerRules;
            readonly converters: NodeConverters;
            readonly baseFactory: BaseNodeFactory;
            readonly flags: NodeFactoryFlags;
            createNodeArray<T extends Node>(elements?: readonly T[], hasTrailingComma?: boolean): NodeArray<T>;
            createNumericLiteral(value: string | number, numericLiteralFlags?: TokenFlags): NumericLiteral;
            createBigIntLiteral(value: string | PseudoBigInt): BigIntLiteral;
            createStringLiteral(text: string, isSingleQuote?: boolean): StringLiteral;
            createStringLiteral(text: string, isSingleQuote?: boolean, hasExtendedUnicodeEscape?: boolean): StringLiteral;
            createStringLiteralFromNode(sourceNode: PropertyNameLiteral | PrivateIdentifier, isSingleQuote?: boolean): StringLiteral;
            createRegularExpressionLiteral(text: string): RegularExpressionLiteral;
            createIdentifier(text: string): Identifier;
            createIdentifier(text: string, originalKeywordKind?: SyntaxKind, hasExtendedUnicodeEscape?: boolean): Identifier;
            createTempVariable(recordTempVariable: ((node: Identifier) => void) | undefined, reservedInNestedScopes?: boolean): Identifier;
            createTempVariable(recordTempVariable: ((node: Identifier) => void) | undefined, reservedInNestedScopes?: boolean, prefix?: string | GeneratedNamePart, suffix?: string): Identifier;
            createLoopVariable(reservedInNestedScopes?: boolean): Identifier;
            createUniqueName(text: string, flags?: GeneratedIdentifierFlags): Identifier;
            createUniqueName(text: string, flags?: GeneratedIdentifierFlags, prefix?: string | GeneratedNamePart, suffix?: string): Identifier;
            getGeneratedNameForNode(node: Node | undefined, flags?: GeneratedIdentifierFlags): Identifier;
            getGeneratedNameForNode(node: Node | undefined, flags?: GeneratedIdentifierFlags, prefix?: string | GeneratedNamePart, suffix?: string): Identifier;
            createPrivateIdentifier(text: string): PrivateIdentifier;
            createUniquePrivateName(text?: string): PrivateIdentifier;
            createUniquePrivateName(text?: string, prefix?: string | GeneratedNamePart, suffix?: string): PrivateIdentifier;
            getGeneratedPrivateNameForNode(node: Node): PrivateIdentifier;
            getGeneratedPrivateNameForNode(node: Node, prefix?: string | GeneratedNamePart, suffix?: string): PrivateIdentifier;
            createToken(token: SyntaxKind.SuperKeyword): SuperExpression;
            createToken(token: SyntaxKind.ThisKeyword): ThisExpression;
            createToken(token: SyntaxKind.NullKeyword): NullLiteral;
            createToken(token: SyntaxKind.TrueKeyword): TrueLiteral;
            createToken(token: SyntaxKind.FalseKeyword): FalseLiteral;
            createToken(token: SyntaxKind.EndOfFileToken): EndOfFileToken;
            createToken(token: SyntaxKind.Unknown): Token<SyntaxKind.Unknown>;
            createToken<TKind extends PunctuationSyntaxKind>(token: TKind): PunctuationToken<TKind>;
            createToken<TKind extends KeywordTypeSyntaxKind>(token: TKind): KeywordTypeNode<TKind>;
            createToken<TKind extends ModifierSyntaxKind>(token: TKind): ModifierToken<TKind>;
            createToken<TKind extends KeywordSyntaxKind>(token: TKind): KeywordToken<TKind>;
            createToken<TKind extends SyntaxKind>(token: TKind): Token<TKind>;
            createSuper(): SuperExpression;
            createThis(): ThisExpression;
            createNull(): NullLiteral;
            createTrue(): TrueLiteral;
            createFalse(): FalseLiteral;
            createModifier<T extends ModifierSyntaxKind>(kind: T): ModifierToken<T>;
            createModifiersFromModifierFlags(flags: ModifierFlags): Modifier[] | undefined;
            createQualifiedName(left: EntityName, right: string | Identifier): QualifiedName;
            updateQualifiedName(node: QualifiedName, left: EntityName, right: Identifier): QualifiedName;
            createComputedPropertyName(expression: Expression): ComputedPropertyName;
            updateComputedPropertyName(node: ComputedPropertyName, expression: Expression): ComputedPropertyName;
            createTypeParameterDeclaration(modifiers: readonly Modifier[] | undefined, name: string | Identifier, constraint?: TypeNode, defaultType?: TypeNode): TypeParameterDeclaration;
            updateTypeParameterDeclaration(node: TypeParameterDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
            createParameterDeclaration(modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken, type?: TypeNode, initializer?: Expression): ParameterDeclaration;
            updateParameterDeclaration(node: ParameterDeclaration, modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
            createDecorator(expression: Expression): Decorator;
            updateDecorator(node: Decorator, expression: Expression): Decorator;
            createPropertySignature(modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;
            updatePropertySignature(node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;
            createPropertyDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
            updatePropertyDeclaration(node: PropertyDeclaration, modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
            createMethodSignature(modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): MethodSignature;
            updateMethodSignature(node: MethodSignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): MethodSignature;
            createMethodDeclaration(modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
            updateMethodDeclaration(node: MethodDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
            createConstructorDeclaration(modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
            updateConstructorDeclaration(node: ConstructorDeclaration, modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
            createGetAccessorDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
            updateGetAccessorDeclaration(node: GetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
            createSetAccessorDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
            updateSetAccessorDeclaration(node: SetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
            createCallSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): CallSignatureDeclaration;
            updateCallSignature(node: CallSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): CallSignatureDeclaration;
            createConstructSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): ConstructSignatureDeclaration;
            updateConstructSignature(node: ConstructSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): ConstructSignatureDeclaration;
            createIndexSignature(modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
            createIndexSignature(modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): IndexSignatureDeclaration;
            updateIndexSignature(node: IndexSignatureDeclaration, modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
            createTemplateLiteralTypeSpan(type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;
            updateTemplateLiteralTypeSpan(node: TemplateLiteralTypeSpan, type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;
            createClassStaticBlockDeclaration(body: Block): ClassStaticBlockDeclaration;
            updateClassStaticBlockDeclaration(node: ClassStaticBlockDeclaration, body: Block): ClassStaticBlockDeclaration;
            createKeywordTypeNode<TKind extends KeywordTypeSyntaxKind>(kind: TKind): KeywordTypeNode<TKind>;
            createTypePredicateNode(assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode | string, type: TypeNode | undefined): TypePredicateNode;
            updateTypePredicateNode(node: TypePredicateNode, assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode, type: TypeNode | undefined): TypePredicateNode;
            createTypeReferenceNode(typeName: string | EntityName, typeArguments?: readonly TypeNode[]): TypeReferenceNode;
            updateTypeReferenceNode(node: TypeReferenceNode, typeName: EntityName, typeArguments: NodeArray<TypeNode> | undefined): TypeReferenceNode;
            createFunctionTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): FunctionTypeNode;
            updateFunctionTypeNode(node: FunctionTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): FunctionTypeNode;
            createConstructorTypeNode(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): ConstructorTypeNode;
            updateConstructorTypeNode(node: ConstructorTypeNode, modifiers: readonly Modifier[] | undefined, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode;
            createTypeQueryNode(exprName: EntityName, typeArguments?: readonly TypeNode[]): TypeQueryNode;
            updateTypeQueryNode(node: TypeQueryNode, exprName: EntityName, typeArguments?: readonly TypeNode[]): TypeQueryNode;
            createTypeLiteralNode(members: readonly TypeElement[] | undefined): TypeLiteralNode;
            updateTypeLiteralNode(node: TypeLiteralNode, members: NodeArray<TypeElement>): TypeLiteralNode;
            createArrayTypeNode(elementType: TypeNode): ArrayTypeNode;
            updateArrayTypeNode(node: ArrayTypeNode, elementType: TypeNode): ArrayTypeNode;
            createTupleTypeNode(elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;
            updateTupleTypeNode(node: TupleTypeNode, elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;
            createNamedTupleMember(dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;
            updateNamedTupleMember(node: NamedTupleMember, dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;
            createOptionalTypeNode(type: TypeNode): OptionalTypeNode;
            updateOptionalTypeNode(node: OptionalTypeNode, type: TypeNode): OptionalTypeNode;
            createRestTypeNode(type: TypeNode): RestTypeNode;
            updateRestTypeNode(node: RestTypeNode, type: TypeNode): RestTypeNode;
            createUnionTypeNode(types: readonly TypeNode[]): UnionTypeNode;
            updateUnionTypeNode(node: UnionTypeNode, types: NodeArray<TypeNode>): UnionTypeNode;
            createIntersectionTypeNode(types: readonly TypeNode[]): IntersectionTypeNode;
            updateIntersectionTypeNode(node: IntersectionTypeNode, types: NodeArray<TypeNode>): IntersectionTypeNode;
            createConditionalTypeNode(checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;
            updateConditionalTypeNode(node: ConditionalTypeNode, checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;
            createInferTypeNode(typeParameter: TypeParameterDeclaration): InferTypeNode;
            updateInferTypeNode(node: InferTypeNode, typeParameter: TypeParameterDeclaration): InferTypeNode;
            createImportTypeNode(argument: TypeNode, attributes?: ImportAttributes, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
            updateImportTypeNode(node: ImportTypeNode, argument: TypeNode, attributes: ImportAttributes | undefined, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean): ImportTypeNode;
            createParenthesizedType(type: TypeNode): ParenthesizedTypeNode;
            updateParenthesizedType(node: ParenthesizedTypeNode, type: TypeNode): ParenthesizedTypeNode;
            createThisTypeNode(): ThisTypeNode;
            createTypeOperatorNode(operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword, type: TypeNode): TypeOperatorNode;
            updateTypeOperatorNode(node: TypeOperatorNode, type: TypeNode): TypeOperatorNode;
            createIndexedAccessTypeNode(objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;
            updateIndexedAccessTypeNode(node: IndexedAccessTypeNode, objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;
            createMappedTypeNode(readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined): MappedTypeNode;
            updateMappedTypeNode(node: MappedTypeNode, readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined): MappedTypeNode;
            createLiteralTypeNode(literal: LiteralTypeNode["literal"]): LiteralTypeNode;
            updateLiteralTypeNode(node: LiteralTypeNode, literal: LiteralTypeNode["literal"]): LiteralTypeNode;
            createTemplateLiteralType(head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;
            updateTemplateLiteralType(node: TemplateLiteralTypeNode, head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;
            createObjectBindingPattern(elements: readonly BindingElement[]): ObjectBindingPattern;
            updateObjectBindingPattern(node: ObjectBindingPattern, elements: readonly BindingElement[]): ObjectBindingPattern;
            createArrayBindingPattern(elements: readonly ArrayBindingElement[]): ArrayBindingPattern;
            updateArrayBindingPattern(node: ArrayBindingPattern, elements: readonly ArrayBindingElement[]): ArrayBindingPattern;
            createBindingElement(dotDotDotToken: DotDotDotToken | undefined, propertyName: string | PropertyName | undefined, name: string | BindingName, initializer?: Expression): BindingElement;
            updateBindingElement(node: BindingElement, dotDotDotToken: DotDotDotToken | undefined, propertyName: PropertyName | undefined, name: BindingName, initializer: Expression | undefined): BindingElement;
            createArrayLiteralExpression(elements?: readonly Expression[], multiLine?: boolean): ArrayLiteralExpression;
            updateArrayLiteralExpression(node: ArrayLiteralExpression, elements: readonly Expression[]): ArrayLiteralExpression;
            createObjectLiteralExpression(properties?: readonly ObjectLiteralElementLike[], multiLine?: boolean): ObjectLiteralExpression;
            updateObjectLiteralExpression(node: ObjectLiteralExpression, properties: readonly ObjectLiteralElementLike[]): ObjectLiteralExpression;
            createPropertyAccessExpression(expression: Expression, name: string | MemberName): PropertyAccessExpression;
            updatePropertyAccessExpression(node: PropertyAccessExpression, expression: Expression, name: MemberName): PropertyAccessExpression;
            createPropertyAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, name: string | MemberName): PropertyAccessChain;
            updatePropertyAccessChain(node: PropertyAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, name: MemberName): PropertyAccessChain;
            createElementAccessExpression(expression: Expression, index: number | Expression): ElementAccessExpression;
            updateElementAccessExpression(node: ElementAccessExpression, expression: Expression, argumentExpression: Expression): ElementAccessExpression;
            createElementAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, index: number | Expression): ElementAccessChain;
            updateElementAccessChain(node: ElementAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, argumentExpression: Expression): ElementAccessChain;
            createCallExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallExpression;
            updateCallExpression(node: CallExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallExpression;
            createCallChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallChain;
            updateCallChain(node: CallChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallChain;
            createNewExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;
            updateNewExpression(node: NewExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;
            createTaggedTemplateExpression(tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
            updateTaggedTemplateExpression(node: TaggedTemplateExpression, tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
            createTypeAssertion(type: TypeNode, expression: Expression): TypeAssertion;
            updateTypeAssertion(node: TypeAssertion, type: TypeNode, expression: Expression): TypeAssertion;
            createParenthesizedExpression(expression: Expression): ParenthesizedExpression;
            updateParenthesizedExpression(node: ParenthesizedExpression, expression: Expression): ParenthesizedExpression;
            createFunctionExpression(modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[] | undefined, type: TypeNode | undefined, body: Block): FunctionExpression;
            updateFunctionExpression(node: FunctionExpression, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block): FunctionExpression;
            createArrowFunction(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken | undefined, body: ConciseBody): ArrowFunction;
            updateArrowFunction(node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken, body: ConciseBody): ArrowFunction;
            createDeleteExpression(expression: Expression): DeleteExpression;
            updateDeleteExpression(node: DeleteExpression, expression: Expression): DeleteExpression;
            createTypeOfExpression(expression: Expression): TypeOfExpression;
            updateTypeOfExpression(node: TypeOfExpression, expression: Expression): TypeOfExpression;
            createVoidExpression(expression: Expression): VoidExpression;
            updateVoidExpression(node: VoidExpression, expression: Expression): VoidExpression;
            createAwaitExpression(expression: Expression): AwaitExpression;
            updateAwaitExpression(node: AwaitExpression, expression: Expression): AwaitExpression;
            createPrefixUnaryExpression(operator: PrefixUnaryOperator, operand: Expression): PrefixUnaryExpression;
            updatePrefixUnaryExpression(node: PrefixUnaryExpression, operand: Expression): PrefixUnaryExpression;
            createPostfixUnaryExpression(operand: Expression, operator: PostfixUnaryOperator): PostfixUnaryExpression;
            updatePostfixUnaryExpression(node: PostfixUnaryExpression, operand: Expression): PostfixUnaryExpression;
            createBinaryExpression(left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;
            updateBinaryExpression(node: BinaryExpression, left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;
            createConditionalExpression(condition: Expression, questionToken: QuestionToken | undefined, whenTrue: Expression, colonToken: ColonToken | undefined, whenFalse: Expression): ConditionalExpression;
            updateConditionalExpression(node: ConditionalExpression, condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression): ConditionalExpression;
            createTemplateExpression(head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;
            updateTemplateExpression(node: TemplateExpression, head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;
            createTemplateHead(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateHead;
            createTemplateHead(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateHead;
            createTemplateMiddle(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateMiddle;
            createTemplateMiddle(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateMiddle;
            createTemplateTail(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateTail;
            createTemplateTail(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateTail;
            createNoSubstitutionTemplateLiteral(text: string, rawText?: string): NoSubstitutionTemplateLiteral;
            createNoSubstitutionTemplateLiteral(text: string | undefined, rawText: string): NoSubstitutionTemplateLiteral;
            createLiteralLikeNode(kind: LiteralToken["kind"] | SyntaxKind.JsxTextAllWhiteSpaces, text: string): LiteralToken;
            createTemplateLiteralLikeNode(kind: TemplateLiteralToken["kind"], text: string, rawText: string, templateFlags: TokenFlags | undefined): TemplateLiteralLikeNode;
            createYieldExpression(asteriskToken: AsteriskToken, expression: Expression): YieldExpression;
            createYieldExpression(asteriskToken: undefined, expression: Expression | undefined): YieldExpression;
            createYieldExpression(asteriskToken: AsteriskToken | undefined, expression: Expression | undefined): YieldExpression;
            updateYieldExpression(node: YieldExpression, asteriskToken: AsteriskToken | undefined, expression: Expression | undefined): YieldExpression;
            createSpreadElement(expression: Expression): SpreadElement;
            updateSpreadElement(node: SpreadElement, expression: Expression): SpreadElement;
            createClassExpression(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
            updateClassExpression(node: ClassExpression, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
            createOmittedExpression(): OmittedExpression;
            createExpressionWithTypeArguments(expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;
            updateExpressionWithTypeArguments(node: ExpressionWithTypeArguments, expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;
            createAsExpression(expression: Expression, type: TypeNode): AsExpression;
            updateAsExpression(node: AsExpression, expression: Expression, type: TypeNode): AsExpression;
            createNonNullExpression(expression: Expression): NonNullExpression;
            updateNonNullExpression(node: NonNullExpression, expression: Expression): NonNullExpression;
            createNonNullChain(expression: Expression): NonNullChain;
            updateNonNullChain(node: NonNullChain, expression: Expression): NonNullChain;
            createMetaProperty(keywordToken: MetaProperty["keywordToken"], name: Identifier): MetaProperty;
            updateMetaProperty(node: MetaProperty, name: Identifier): MetaProperty;
            createSatisfiesExpression(expression: Expression, type: TypeNode): SatisfiesExpression;
            updateSatisfiesExpression(node: SatisfiesExpression, expression: Expression, type: TypeNode): SatisfiesExpression;
            createTemplateSpan(expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;
            updateTemplateSpan(node: TemplateSpan, expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;
            createSemicolonClassElement(): SemicolonClassElement;
            createBlock(statements: readonly Statement[], multiLine?: boolean): Block;
            updateBlock(node: Block, statements: readonly Statement[]): Block;
            createVariableStatement(modifiers: readonly ModifierLike[] | undefined, declarationList: VariableDeclarationList | readonly VariableDeclaration[]): VariableStatement;
            updateVariableStatement(node: VariableStatement, modifiers: readonly ModifierLike[] | undefined, declarationList: VariableDeclarationList): VariableStatement;
            createEmptyStatement(): EmptyStatement;
            createExpressionStatement(expression: Expression): ExpressionStatement;
            updateExpressionStatement(node: ExpressionStatement, expression: Expression): ExpressionStatement;
            createIfStatement(expression: Expression, thenStatement: Statement, elseStatement?: Statement): IfStatement;
            updateIfStatement(node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement | undefined): IfStatement;
            createDoStatement(statement: Statement, expression: Expression): DoStatement;
            updateDoStatement(node: DoStatement, statement: Statement, expression: Expression): DoStatement;
            createWhileStatement(expression: Expression, statement: Statement): WhileStatement;
            updateWhileStatement(node: WhileStatement, expression: Expression, statement: Statement): WhileStatement;
            createForStatement(initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;
            updateForStatement(node: ForStatement, initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;
            createForInStatement(initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;
            updateForInStatement(node: ForInStatement, initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;
            createForOfStatement(awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;
            updateForOfStatement(node: ForOfStatement, awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;
            createContinueStatement(label?: string | Identifier): ContinueStatement;
            updateContinueStatement(node: ContinueStatement, label: Identifier | undefined): ContinueStatement;
            createBreakStatement(label?: string | Identifier): BreakStatement;
            updateBreakStatement(node: BreakStatement, label: Identifier | undefined): BreakStatement;
            createReturnStatement(expression?: Expression): ReturnStatement;
            updateReturnStatement(node: ReturnStatement, expression: Expression | undefined): ReturnStatement;
            createWithStatement(expression: Expression, statement: Statement): WithStatement;
            updateWithStatement(node: WithStatement, expression: Expression, statement: Statement): WithStatement;
            createSwitchStatement(expression: Expression, caseBlock: CaseBlock): SwitchStatement;
            updateSwitchStatement(node: SwitchStatement, expression: Expression, caseBlock: CaseBlock): SwitchStatement;
            createLabeledStatement(label: string | Identifier, statement: Statement): LabeledStatement;
            updateLabeledStatement(node: LabeledStatement, label: Identifier, statement: Statement): LabeledStatement;
            createThrowStatement(expression: Expression): ThrowStatement;
            updateThrowStatement(node: ThrowStatement, expression: Expression): ThrowStatement;
            createTryStatement(tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;
            updateTryStatement(node: TryStatement, tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;
            createDebuggerStatement(): DebuggerStatement;
            createVariableDeclaration(name: string | BindingName, exclamationToken?: ExclamationToken, type?: TypeNode, initializer?: Expression): VariableDeclaration;
            updateVariableDeclaration(node: VariableDeclaration, name: BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;
            createVariableDeclarationList(declarations: readonly VariableDeclaration[], flags?: NodeFlags): VariableDeclarationList;
            updateVariableDeclarationList(node: VariableDeclarationList, declarations: readonly VariableDeclaration[]): VariableDeclarationList;
            createFunctionDeclaration(modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
            updateFunctionDeclaration(node: FunctionDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
            createClassDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
            updateClassDeclaration(node: ClassDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
            createInterfaceDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
            updateInterfaceDeclaration(node: InterfaceDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
            createTypeAliasDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
            updateTypeAliasDeclaration(node: TypeAliasDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
            createEnumDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
            updateEnumDeclaration(node: EnumDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
            createModuleDeclaration(modifiers: readonly ModifierLike[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags): ModuleDeclaration;
            updateModuleDeclaration(node: ModuleDeclaration, modifiers: readonly ModifierLike[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
            createModuleBlock(statements: readonly Statement[]): ModuleBlock;
            updateModuleBlock(node: ModuleBlock, statements: readonly Statement[]): ModuleBlock;
            createCaseBlock(clauses: readonly CaseOrDefaultClause[]): CaseBlock;
            updateCaseBlock(node: CaseBlock, clauses: readonly CaseOrDefaultClause[]): CaseBlock;
            createNamespaceExportDeclaration(name: string | Identifier): NamespaceExportDeclaration;
            updateNamespaceExportDeclaration(node: NamespaceExportDeclaration, name: Identifier): NamespaceExportDeclaration;
            createImportEqualsDeclaration(modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
            updateImportEqualsDeclaration(node: ImportEqualsDeclaration, modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
            createImportDeclaration(modifiers: readonly ModifierLike[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, attributes?: ImportAttributes): ImportDeclaration;
            updateImportDeclaration(node: ImportDeclaration, modifiers: readonly ModifierLike[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, attributes: ImportAttributes | undefined): ImportDeclaration;
            createImportClause(isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;
            updateImportClause(node: ImportClause, isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;
            createAssertClause(elements: NodeArray<AssertEntry>, multiLine?: boolean): AssertClause;
            updateAssertClause(node: AssertClause, elements: NodeArray<AssertEntry>, multiLine?: boolean): AssertClause;
            createAssertEntry(name: AssertionKey, value: Expression): AssertEntry;
            updateAssertEntry(node: AssertEntry, name: AssertionKey, value: Expression): AssertEntry;
            createImportTypeAssertionContainer(clause: AssertClause, multiLine?: boolean): ImportTypeAssertionContainer;
            updateImportTypeAssertionContainer(node: ImportTypeAssertionContainer, clause: AssertClause, multiLine?: boolean): ImportTypeAssertionContainer;
            createImportAttributes(elements: NodeArray<ImportAttribute>, multiLine?: boolean): ImportAttributes;
            createImportAttributes(elements: NodeArray<ImportAttribute>, multiLine?: boolean, token?: ImportAttributes["token"]): ImportAttributes;
            updateImportAttributes(node: ImportAttributes, elements: NodeArray<ImportAttribute>, multiLine?: boolean): ImportAttributes;
            createImportAttribute(name: ImportAttributeName, value: Expression): ImportAttribute;
            updateImportAttribute(node: ImportAttribute, name: ImportAttributeName, value: Expression): ImportAttribute;
            createNamespaceImport(name: Identifier): NamespaceImport;
            updateNamespaceImport(node: NamespaceImport, name: Identifier): NamespaceImport;
            createNamespaceExport(name: ModuleExportName): NamespaceExport;
            updateNamespaceExport(node: NamespaceExport, name: ModuleExportName): NamespaceExport;
            createNamedImports(elements: readonly ImportSpecifier[]): NamedImports;
            updateNamedImports(node: NamedImports, elements: readonly ImportSpecifier[]): NamedImports;
            createImportSpecifier(isTypeOnly: boolean, propertyName: ModuleExportName | undefined, name: Identifier): ImportSpecifier;
            updateImportSpecifier(node: ImportSpecifier, isTypeOnly: boolean, propertyName: ModuleExportName | undefined, name: Identifier): ImportSpecifier;
            createExportAssignment(modifiers: readonly ModifierLike[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
            updateExportAssignment(node: ExportAssignment, modifiers: readonly ModifierLike[] | undefined, expression: Expression): ExportAssignment;
            createExportDeclaration(modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression, attributes?: ImportAttributes): ExportDeclaration;
            updateExportDeclaration(node: ExportDeclaration, modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, attributes: ImportAttributes | undefined): ExportDeclaration;
            createNamedExports(elements: readonly ExportSpecifier[]): NamedExports;
            updateNamedExports(node: NamedExports, elements: readonly ExportSpecifier[]): NamedExports;
            createExportSpecifier(isTypeOnly: boolean, propertyName: string | ModuleExportName | undefined, name: string | ModuleExportName): ExportSpecifier;
            updateExportSpecifier(node: ExportSpecifier, isTypeOnly: boolean, propertyName: ModuleExportName | undefined, name: ModuleExportName): ExportSpecifier;
            createMissingDeclaration(): MissingDeclaration;
            createExternalModuleReference(expression: Expression): ExternalModuleReference;
            updateExternalModuleReference(node: ExternalModuleReference, expression: Expression): ExternalModuleReference;
            createJSDocAllType(): JSDocAllType;
            createJSDocUnknownType(): JSDocUnknownType;
            createJSDocNonNullableType(type: TypeNode, postfix?: boolean): JSDocNonNullableType;
            updateJSDocNonNullableType(node: JSDocNonNullableType, type: TypeNode): JSDocNonNullableType;
            createJSDocNullableType(type: TypeNode, postfix?: boolean): JSDocNullableType;
            updateJSDocNullableType(node: JSDocNullableType, type: TypeNode): JSDocNullableType;
            createJSDocOptionalType(type: TypeNode): JSDocOptionalType;
            updateJSDocOptionalType(node: JSDocOptionalType, type: TypeNode): JSDocOptionalType;
            createJSDocFunctionType(parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;
            updateJSDocFunctionType(node: JSDocFunctionType, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;
            createJSDocVariadicType(type: TypeNode): JSDocVariadicType;
            updateJSDocVariadicType(node: JSDocVariadicType, type: TypeNode): JSDocVariadicType;
            createJSDocNamepathType(type: TypeNode): JSDocNamepathType;
            updateJSDocNamepathType(node: JSDocNamepathType, type: TypeNode): JSDocNamepathType;
            createJSDocTypeExpression(type: TypeNode): JSDocTypeExpression;
            updateJSDocTypeExpression(node: JSDocTypeExpression, type: TypeNode): JSDocTypeExpression;
            createJSDocNameReference(name: EntityName | JSDocMemberName): JSDocNameReference;
            updateJSDocNameReference(node: JSDocNameReference, name: EntityName | JSDocMemberName): JSDocNameReference;
            createJSDocMemberName(left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;
            updateJSDocMemberName(node: JSDocMemberName, left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;
            createJSDocLink(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;
            updateJSDocLink(node: JSDocLink, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;
            createJSDocLinkCode(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;
            updateJSDocLinkCode(node: JSDocLinkCode, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;
            createJSDocLinkPlain(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;
            updateJSDocLinkPlain(node: JSDocLinkPlain, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;
            createJSDocTypeLiteral(jsDocPropertyTags?: readonly JSDocPropertyLikeTag[], isArrayType?: boolean): JSDocTypeLiteral;
            updateJSDocTypeLiteral(node: JSDocTypeLiteral, jsDocPropertyTags: readonly JSDocPropertyLikeTag[] | undefined, isArrayType: boolean | undefined): JSDocTypeLiteral;
            createJSDocSignature(typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type?: JSDocReturnTag): JSDocSignature;
            updateJSDocSignature(node: JSDocSignature, typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type: JSDocReturnTag | undefined): JSDocSignature;
            createJSDocTemplateTag(tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment?: string | NodeArray<JSDocComment>): JSDocTemplateTag;
            updateJSDocTemplateTag(node: JSDocTemplateTag, tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment: string | NodeArray<JSDocComment> | undefined): JSDocTemplateTag;
            createJSDocTypedefTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression | JSDocTypeLiteral, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray<JSDocComment>): JSDocTypedefTag;
            updateJSDocTypedefTag(node: JSDocTypedefTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | JSDocTypeLiteral | undefined, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocTypedefTag;
            createJSDocParameterTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray<JSDocComment>): JSDocParameterTag;
            updateJSDocParameterTag(node: JSDocParameterTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray<JSDocComment> | undefined): JSDocParameterTag;
            createJSDocPropertyTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray<JSDocComment>): JSDocPropertyTag;
            updateJSDocPropertyTag(node: JSDocPropertyTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray<JSDocComment> | undefined): JSDocPropertyTag;
            createJSDocTypeTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocTypeTag;
            updateJSDocTypeTag(node: JSDocTypeTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocTypeTag;
            createJSDocSeeTag(tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray<JSDocComment>): JSDocSeeTag;
            updateJSDocSeeTag(node: JSDocSeeTag, tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray<JSDocComment>): JSDocSeeTag;
            createJSDocReturnTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocReturnTag;
            updateJSDocReturnTag(node: JSDocReturnTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocReturnTag;
            createJSDocThisTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocThisTag;
            updateJSDocThisTag(node: JSDocThisTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocThisTag;
            createJSDocEnumTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocEnumTag;
            updateJSDocEnumTag(node: JSDocEnumTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocEnumTag;
            createJSDocCallbackTag(tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray<JSDocComment>): JSDocCallbackTag;
            updateJSDocCallbackTag(node: JSDocCallbackTag, tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocCallbackTag;
            createJSDocOverloadTag(tagName: Identifier | undefined, typeExpression: JSDocSignature, comment?: string | NodeArray<JSDocComment>): JSDocOverloadTag;
            updateJSDocOverloadTag(node: JSDocOverloadTag, tagName: Identifier | undefined, typeExpression: JSDocSignature, comment: string | NodeArray<JSDocComment> | undefined): JSDocOverloadTag;
            createJSDocAugmentsTag(tagName: Identifier | undefined, className: JSDocAugmentsTag["class"], comment?: string | NodeArray<JSDocComment>): JSDocAugmentsTag;
            updateJSDocAugmentsTag(node: JSDocAugmentsTag, tagName: Identifier | undefined, className: JSDocAugmentsTag["class"], comment: string | NodeArray<JSDocComment> | undefined): JSDocAugmentsTag;
            createJSDocImplementsTag(tagName: Identifier | undefined, className: JSDocImplementsTag["class"], comment?: string | NodeArray<JSDocComment>): JSDocImplementsTag;
            updateJSDocImplementsTag(node: JSDocImplementsTag, tagName: Identifier | undefined, className: JSDocImplementsTag["class"], comment: string | NodeArray<JSDocComment> | undefined): JSDocImplementsTag;
            createJSDocAuthorTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocAuthorTag;
            updateJSDocAuthorTag(node: JSDocAuthorTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocAuthorTag;
            createJSDocClassTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocClassTag;
            updateJSDocClassTag(node: JSDocClassTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocClassTag;
            createJSDocPublicTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocPublicTag;
            updateJSDocPublicTag(node: JSDocPublicTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocPublicTag;
            createJSDocPrivateTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocPrivateTag;
            updateJSDocPrivateTag(node: JSDocPrivateTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocPrivateTag;
            createJSDocProtectedTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocProtectedTag;
            updateJSDocProtectedTag(node: JSDocProtectedTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocProtectedTag;
            createJSDocReadonlyTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocReadonlyTag;
            updateJSDocReadonlyTag(node: JSDocReadonlyTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocReadonlyTag;
            createJSDocUnknownTag(tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocUnknownTag;
            updateJSDocUnknownTag(node: JSDocUnknownTag, tagName: Identifier, comment: string | NodeArray<JSDocComment> | undefined): JSDocUnknownTag;
            createJSDocDeprecatedTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocDeprecatedTag;
            updateJSDocDeprecatedTag(node: JSDocDeprecatedTag, tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocDeprecatedTag;
            createJSDocOverrideTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocOverrideTag;
            updateJSDocOverrideTag(node: JSDocOverrideTag, tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocOverrideTag;
            createJSDocThrowsTag(tagName: Identifier, typeExpression: JSDocTypeExpression | undefined, comment?: string | NodeArray<JSDocComment>): JSDocThrowsTag;
            updateJSDocThrowsTag(node: JSDocThrowsTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment?: string | NodeArray<JSDocComment> | undefined): JSDocThrowsTag;
            createJSDocSatisfiesTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocSatisfiesTag;
            updateJSDocSatisfiesTag(node: JSDocSatisfiesTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocSatisfiesTag;
            createJSDocImportTag(tagName: Identifier | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, attributes?: ImportAttributes, comment?: string | NodeArray<JSDocComment>): JSDocImportTag;
            updateJSDocImportTag(node: JSDocImportTag, tagName: Identifier | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, attributes: ImportAttributes | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocImportTag;
            createJSDocText(text: string): JSDocText;
            updateJSDocText(node: JSDocText, text: string): JSDocText;
            createJSDocComment(comment?: string | NodeArray<JSDocComment> | undefined, tags?: readonly JSDocTag[] | undefined): JSDoc;
            updateJSDocComment(node: JSDoc, comment: string | NodeArray<JSDocComment> | undefined, tags: readonly JSDocTag[] | undefined): JSDoc;
            createJsxElement(openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;
            updateJsxElement(node: JsxElement, openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;
            createJsxSelfClosingElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;
            updateJsxSelfClosingElement(node: JsxSelfClosingElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;
            createJsxOpeningElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;
            updateJsxOpeningElement(node: JsxOpeningElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;
            createJsxClosingElement(tagName: JsxTagNameExpression): JsxClosingElement;
            updateJsxClosingElement(node: JsxClosingElement, tagName: JsxTagNameExpression): JsxClosingElement;
            createJsxFragment(openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;
            createJsxText(text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;
            updateJsxText(node: JsxText, text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;
            createJsxOpeningFragment(): JsxOpeningFragment;
            createJsxJsxClosingFragment(): JsxClosingFragment;
            updateJsxFragment(node: JsxFragment, openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;
            createJsxAttribute(name: JsxAttributeName, initializer: JsxAttributeValue | undefined): JsxAttribute;
            updateJsxAttribute(node: JsxAttribute, name: JsxAttributeName, initializer: JsxAttributeValue | undefined): JsxAttribute;
            createJsxAttributes(properties: readonly JsxAttributeLike[]): JsxAttributes;
            updateJsxAttributes(node: JsxAttributes, properties: readonly JsxAttributeLike[]): JsxAttributes;
            createJsxSpreadAttribute(expression: Expression): JsxSpreadAttribute;
            updateJsxSpreadAttribute(node: JsxSpreadAttribute, expression: Expression): JsxSpreadAttribute;
            createJsxExpression(dotDotDotToken: DotDotDotToken | undefined, expression: Expression | undefined): JsxExpression;
            updateJsxExpression(node: JsxExpression, expression: Expression | undefined): JsxExpression;
            createJsxNamespacedName(namespace: Identifier, name: Identifier): JsxNamespacedName;
            updateJsxNamespacedName(node: JsxNamespacedName, namespace: Identifier, name: Identifier): JsxNamespacedName;
            createCaseClause(expression: Expression, statements: readonly Statement[]): CaseClause;
            updateCaseClause(node: CaseClause, expression: Expression, statements: readonly Statement[]): CaseClause;
            createDefaultClause(statements: readonly Statement[]): DefaultClause;
            updateDefaultClause(node: DefaultClause, statements: readonly Statement[]): DefaultClause;
            createHeritageClause(token: HeritageClause["token"], types: readonly ExpressionWithTypeArguments[]): HeritageClause;
            updateHeritageClause(node: HeritageClause, types: readonly ExpressionWithTypeArguments[]): HeritageClause;
            createCatchClause(variableDeclaration: string | BindingName | VariableDeclaration | undefined, block: Block): CatchClause;
            updateCatchClause(node: CatchClause, variableDeclaration: VariableDeclaration | undefined, block: Block): CatchClause;
            createPropertyAssignment(name: string | PropertyName, initializer: Expression): PropertyAssignment;
            updatePropertyAssignment(node: PropertyAssignment, name: PropertyName, initializer: Expression): PropertyAssignment;
            createShorthandPropertyAssignment(name: string | Identifier, objectAssignmentInitializer?: Expression): ShorthandPropertyAssignment;
            updateShorthandPropertyAssignment(node: ShorthandPropertyAssignment, name: Identifier, objectAssignmentInitializer: Expression | undefined): ShorthandPropertyAssignment;
            createSpreadAssignment(expression: Expression): SpreadAssignment;
            updateSpreadAssignment(node: SpreadAssignment, expression: Expression): SpreadAssignment;
            createEnumMember(name: string | PropertyName, initializer?: Expression): EnumMember;
            updateEnumMember(node: EnumMember, name: PropertyName, initializer: Expression | undefined): EnumMember;
            createSourceFile(statements: readonly Statement[], endOfFileToken: EndOfFileToken, flags: NodeFlags): SourceFile;
            updateSourceFile(node: SourceFile, statements: readonly Statement[], isDeclarationFile?: boolean, referencedFiles?: readonly FileReference[], typeReferences?: readonly FileReference[], hasNoDefaultLib?: boolean, libReferences?: readonly FileReference[]): SourceFile;
            createRedirectedSourceFile(redirectInfo: RedirectInfo): SourceFile;
            createSyntheticExpression(type: Type, isSpread?: boolean, tupleNameSource?: ParameterDeclaration | NamedTupleMember): SyntheticExpression;
            createSyntaxList(children: readonly Node[]): SyntaxList;
            createNotEmittedStatement(original: Node): NotEmittedStatement;
            createNotEmittedTypeElement(): NotEmittedTypeElement;
            createPartiallyEmittedExpression(expression: Expression, original?: Node): PartiallyEmittedExpression;
            updatePartiallyEmittedExpression(node: PartiallyEmittedExpression, expression: Expression): PartiallyEmittedExpression;
            createSyntheticReferenceExpression(expression: Expression, thisArg: Expression): SyntheticReferenceExpression;
            updateSyntheticReferenceExpression(node: SyntheticReferenceExpression, expression: Expression, thisArg: Expression): SyntheticReferenceExpression;
            createCommaListExpression(elements: readonly Expression[]): CommaListExpression;
            updateCommaListExpression(node: CommaListExpression, elements: readonly Expression[]): CommaListExpression;
            createBundle(sourceFiles: readonly SourceFile[]): Bundle;
            updateBundle(node: Bundle, sourceFiles: readonly SourceFile[]): Bundle;
            createComma(left: Expression, right: Expression): BinaryExpression;
            createAssignment(left: ObjectLiteralExpression | ArrayLiteralExpression, right: Expression): DestructuringAssignment;
            createAssignment(left: Expression, right: Expression): AssignmentExpression<EqualsToken>;
            createLogicalOr(left: Expression, right: Expression): BinaryExpression;
            createLogicalAnd(left: Expression, right: Expression): BinaryExpression;
            createBitwiseOr(left: Expression, right: Expression): BinaryExpression;
            createBitwiseXor(left: Expression, right: Expression): BinaryExpression;
            createBitwiseAnd(left: Expression, right: Expression): BinaryExpression;
            createStrictEquality(left: Expression, right: Expression): BinaryExpression;
            createStrictInequality(left: Expression, right: Expression): BinaryExpression;
            createEquality(left: Expression, right: Expression): BinaryExpression;
            createInequality(left: Expression, right: Expression): BinaryExpression;
            createLessThan(left: Expression, right: Expression): BinaryExpression;
            createLessThanEquals(left: Expression, right: Expression): BinaryExpression;
            createGreaterThan(left: Expression, right: Expression): BinaryExpression;
            createGreaterThanEquals(left: Expression, right: Expression): BinaryExpression;
            createLeftShift(left: Expression, right: Expression): BinaryExpression;
            createRightShift(left: Expression, right: Expression): BinaryExpression;
            createUnsignedRightShift(left: Expression, right: Expression): BinaryExpression;
            createAdd(left: Expression, right: Expression): BinaryExpression;
            createSubtract(left: Expression, right: Expression): BinaryExpression;
            createMultiply(left: Expression, right: Expression): BinaryExpression;
            createDivide(left: Expression, right: Expression): BinaryExpression;
            createModulo(left: Expression, right: Expression): BinaryExpression;
            createExponent(left: Expression, right: Expression): BinaryExpression;
            createPrefixPlus(operand: Expression): PrefixUnaryExpression;
            createPrefixMinus(operand: Expression): PrefixUnaryExpression;
            createPrefixIncrement(operand: Expression): PrefixUnaryExpression;
            createPrefixDecrement(operand: Expression): PrefixUnaryExpression;
            createBitwiseNot(operand: Expression): PrefixUnaryExpression;
            createLogicalNot(operand: Expression): PrefixUnaryExpression;
            createPostfixIncrement(operand: Expression): PostfixUnaryExpression;
            createPostfixDecrement(operand: Expression): PostfixUnaryExpression;
            createImmediatelyInvokedFunctionExpression(statements: readonly Statement[]): CallExpression;
            createImmediatelyInvokedFunctionExpression(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;
            createImmediatelyInvokedArrowFunction(statements: readonly Statement[]): ImmediatelyInvokedArrowFunction;
            createImmediatelyInvokedArrowFunction(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): ImmediatelyInvokedArrowFunction;
            createVoidZero(): VoidExpression;
            createExportDefault(expression: Expression): ExportAssignment;
            createExternalModuleExport(exportName: Identifier): ExportDeclaration;
            createTypeCheck(value: Expression, tag: TypeOfTag): Expression;
            createIsNotTypeCheck(value: Expression, tag: TypeOfTag): Expression;
            createMethodCall(object: Expression, methodName: string | Identifier, argumentsList: readonly Expression[]): CallExpression;
            createGlobalMethodCall(globalObjectName: string, globalMethodName: string, argumentsList: readonly Expression[]): CallExpression;
            createFunctionBindCall(target: Expression, thisArg: Expression, argumentsList: readonly Expression[]): CallExpression;
            createFunctionCallCall(target: Expression, thisArg: Expression, argumentsList: readonly Expression[]): CallExpression;
            createFunctionApplyCall(target: Expression, thisArg: Expression, argumentsExpression: Expression): CallExpression;
            createObjectDefinePropertyCall(target: Expression, propertyName: string | Expression, attributes: Expression): CallExpression;
            createObjectGetOwnPropertyDescriptorCall(target: Expression, propertyName: string | Expression): CallExpression;
            createReflectGetCall(target: Expression, propertyKey: Expression, receiver?: Expression): CallExpression;
            createReflectSetCall(target: Expression, propertyKey: Expression, value: Expression, receiver?: Expression): CallExpression;
            createPropertyDescriptor(attributes: PropertyDescriptorAttributes, singleLine?: boolean): ObjectLiteralExpression;
            createArraySliceCall(array: Expression, start?: number | Expression): CallExpression;
            createArrayConcatCall(array: Expression, values: readonly Expression[]): CallExpression;
            createCallBinding(expression: Expression, recordTempVariable: (temp: Identifier) => void, languageVersion?: ScriptTarget, cacheIdentifiers?: boolean): CallBinding;
            createAssignmentTargetWrapper(paramName: Identifier, expression: Expression): PropertyAccessExpression;
            inlineExpressions(expressions: readonly Expression[]): Expression;
            getInternalName(node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
            getLocalName(node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean, ignoreAssignedName?: boolean): Identifier;
            getExportName(node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
            getDeclarationName(node: Declaration | undefined, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
            getNamespaceMemberName(ns: Identifier, name: Identifier, allowComments?: boolean, allowSourceMaps?: boolean): PropertyAccessExpression;
            getExternalModuleOrNamespaceExportName(ns: Identifier | undefined, node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier | PropertyAccessExpression;
            restoreOuterExpressions(outerExpression: Expression | undefined, innerExpression: Expression, kinds?: OuterExpressionKinds): Expression;
            restoreEnclosingLabel(node: Statement, outermostLabeledStatement: LabeledStatement | undefined, afterRestoreLabelCallback?: (node: LabeledStatement) => void): Statement;
            createUseStrictPrologue(): PrologueDirective;
            copyPrologue(source: readonly Statement[], target: Statement[], ensureUseStrict?: boolean, visitor?: (node: Node) => VisitResult<Node | undefined>): number;
            copyStandardPrologue(source: readonly Statement[], target: Statement[], statementOffset: number | undefined, ensureUseStrict?: boolean): number;
            copyCustomPrologue(source: readonly Statement[], target: Statement[], statementOffset: number, visitor?: (node: Node) => VisitResult<Node | undefined>, filter?: (node: Statement) => boolean): number;
            copyCustomPrologue(source: readonly Statement[], target: Statement[], statementOffset: number | undefined, visitor?: (node: Node) => VisitResult<Node | undefined>, filter?: (node: Statement) => boolean): number | undefined;
            ensureUseStrict(statements: NodeArray<Statement>): NodeArray<Statement>;
            liftToBlock(nodes: readonly Node[]): Statement;
            mergeLexicalEnvironment(statements: NodeArray<Statement>, declarations: readonly Statement[] | undefined): NodeArray<Statement>;
            mergeLexicalEnvironment(statements: Statement[], declarations: readonly Statement[] | undefined): Statement[];
            cloneNode<T extends Node | undefined>(node: T): T;
            replaceModifiers<T extends HasModifiers>(node: T, modifiers: readonly Modifier[] | ModifierFlags | undefined): T;
            replaceDecoratorsAndModifiers<T extends HasModifiers & HasDecorators>(node: T, modifiers: readonly ModifierLike[] | undefined): T;
            replacePropertyName<T extends AccessorDeclaration | MethodDeclaration | MethodSignature | PropertyDeclaration | PropertySignature | PropertyAssignment>(node: T, name: T["name"]): T;
        }
        enum LexicalEnvironmentFlags {
            None = 0,
            InParameters = 1,
            VariablesHoistedInParameters = 2
        }
        interface CoreTransformationContext {
            readonly factory: NodeFactory;
            getCompilerOptions(): CompilerOptions;
            startLexicalEnvironment(): void;
            setLexicalEnvironmentFlags(flags: LexicalEnvironmentFlags, value: boolean): void;
            getLexicalEnvironmentFlags(): LexicalEnvironmentFlags;
            suspendLexicalEnvironment(): void;
            resumeLexicalEnvironment(): void;
            endLexicalEnvironment(): Statement[] | undefined;
            hoistFunctionDeclaration(node: FunctionDeclaration): void;
            hoistVariableDeclaration(node: Identifier): void;
            startBlockScope(): void;
            endBlockScope(): Statement[] | undefined;
            addBlockScopedVariable(node: Identifier): void;
            addInitializationStatement(node: Statement): void;
        }
        interface TransformationContext extends CoreTransformationContext {
            getEmitResolver(): EmitResolver;
            getEmitHost(): EmitHost;
            getEmitHelperFactory(): EmitHelperFactory;
            requestEmitHelper(helper: EmitHelper): void;
            readEmitHelpers(): EmitHelper[] | undefined;
            enableSubstitution(kind: SyntaxKind): void;
            isSubstitutionEnabled(node: Node): boolean;
            onSubstituteNode: (hint: EmitHint, node: Node) => Node;
            enableEmitNotification(kind: SyntaxKind): void;
            isEmitNotificationEnabled(node: Node): boolean;
            onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;
            addDiagnostic(diag: DiagnosticWithLocation): void;
        }
        interface TransformationResult<T extends Node> {
            transformed: T[];
            diagnostics?: DiagnosticWithLocation[];
            substituteNode(hint: EmitHint, node: Node): Node;
            emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;
            isEmitNotificationEnabled?(node: Node): boolean;
            dispose(): void;
        }
        type TransformerFactory<T extends Node> = (context: TransformationContext) => Transformer<T>;
        type Transformer<T extends Node> = (node: T) => T;
        type Visitor<TIn extends Node = Node, TOut extends Node | undefined = TIn | undefined> = (node: TIn) => VisitResult<TOut>;
        interface NodeVisitor {
            <TIn extends Node | undefined, TVisited extends Node | undefined, TOut extends Node>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test: (node: Node) => node is TOut, lift?: (node: readonly Node[]) => Node): TOut | (TIn & undefined) | (TVisited & undefined);
            <TIn extends Node | undefined, TVisited extends Node | undefined>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => Node): Node | (TIn & undefined) | (TVisited & undefined);
        }
        interface NodesVisitor {
            <TIn extends Node, TInArray extends NodeArray<TIn> | undefined, TOut extends Node>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test: (node: Node) => node is TOut, start?: number, count?: number): NodeArray<TOut> | (TInArray & undefined);
            <TIn extends Node, TInArray extends NodeArray<TIn> | undefined>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<Node> | (TInArray & undefined);
        }
        type VisitResult<T extends Node | undefined> = T | readonly Node[];
        interface Printer {
            printNode(hint: EmitHint, node: Node, sourceFile: SourceFile): string;
            printList<T extends Node>(format: ListFormat, list: NodeArray<T>, sourceFile: SourceFile): string;
            printFile(sourceFile: SourceFile): string;
            printBundle(bundle: Bundle): string;
            writeNode(hint: EmitHint, node: Node, sourceFile: SourceFile | undefined, writer: EmitTextWriter): void;
            writeList<T extends Node>(format: ListFormat, list: NodeArray<T> | undefined, sourceFile: SourceFile | undefined, writer: EmitTextWriter): void;
            writeFile(sourceFile: SourceFile, writer: EmitTextWriter, sourceMapGenerator: SourceMapGenerator | undefined): void;
            writeBundle(bundle: Bundle, writer: EmitTextWriter, sourceMapGenerator: SourceMapGenerator | undefined): void;
        }
        interface BuildInfo {
            version: string;
        }
        interface BuildInfoFileVersionMap {
            fileInfos: Map<Path, string>;
            roots: Map<Path, Path | undefined>;
        }
        interface PrintHandlers {
            hasGlobalName?(name: string): boolean;
            onEmitNode?(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;
            isEmitNotificationEnabled?(node: Node): boolean;
            substituteNode?(hint: EmitHint, node: Node): Node;
            onEmitSourceMapOfNode?: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;
            onEmitSourceMapOfToken?: (node: Node | undefined, token: SyntaxKind, writer: (s: string) => void, pos: number, emitCallback: (token: SyntaxKind, writer: (s: string) => void, pos: number) => number) => number;
            onEmitSourceMapOfPosition?: (pos: number) => void;
            onSetSourceFile?: (node: SourceFile) => void;
            onBeforeEmitNode?: (node: Node | undefined) => void;
            onAfterEmitNode?: (node: Node | undefined) => void;
            onBeforeEmitNodeArray?: (nodes: NodeArray<any> | undefined) => void;
            onAfterEmitNodeArray?: (nodes: NodeArray<any> | undefined) => void;
            onBeforeEmitToken?: (node: Node) => void;
            onAfterEmitToken?: (node: Node) => void;
        }
        interface PrinterOptions {
            removeComments?: boolean;
            newLine?: NewLineKind;
            omitTrailingSemicolon?: boolean;
            noEmitHelpers?: boolean;
            module?: CompilerOptions["module"];
            moduleResolution?: CompilerOptions["moduleResolution"];
            target?: CompilerOptions["target"];
            sourceMap?: boolean;
            inlineSourceMap?: boolean;
            inlineSources?: boolean;
            omitBraceSourceMapPositions?: boolean;
            extendedDiagnostics?: boolean;
            onlyPrintJsDocStyle?: boolean;
            neverAsciiEscape?: boolean;
            stripInternal?: boolean;
            preserveSourceNewlines?: boolean;
            terminateUnterminatedLiterals?: boolean;
        }
        interface RawSourceMap {
            version: 3;
            file: string;
            sourceRoot?: string | null;
            sources: string[];
            sourcesContent?: (string | null)[] | null;
            mappings: string;
            names?: string[] | null;
        }
        interface SourceMapGenerator {
            getSources(): readonly string[];
            addSource(fileName: string): number;
            setSourceContent(sourceIndex: number, content: string | null): void;
            addName(name: string): number;
            addMapping(generatedLine: number, generatedCharacter: number): void;
            addMapping(generatedLine: number, generatedCharacter: number, sourceIndex: number, sourceLine: number, sourceCharacter: number, nameIndex?: number): void;
            appendSourceMap(generatedLine: number, generatedCharacter: number, sourceMap: RawSourceMap, sourceMapPath: string, start?: LineAndCharacter, end?: LineAndCharacter): void;
            toJSON(): RawSourceMap;
            toString(): string;
        }
        interface DocumentPositionMapperHost {
            getSourceFileLike(fileName: string): SourceFileLike | undefined;
            getCanonicalFileName(path: string): string;
            log(text: string): void;
        }
        interface DocumentPositionMapper {
            getSourcePosition(input: DocumentPosition): DocumentPosition;
            getGeneratedPosition(input: DocumentPosition): DocumentPosition;
        }
        interface DocumentPosition {
            fileName: string;
            pos: number;
        }
        interface EmitTextWriter extends SymbolWriter {
            write(s: string): void;
            writeTrailingSemicolon(text: string): void;
            writeComment(text: string): void;
            getText(): string;
            rawWrite(s: string): void;
            writeLiteral(s: string): void;
            getTextPos(): number;
            getLine(): number;
            getColumn(): number;
            getIndent(): number;
            isAtStartOfLine(): boolean;
            hasTrailingComment(): boolean;
            hasTrailingWhitespace(): boolean;
            nonEscapingWrite?(text: string): void;
        }
        interface GetEffectiveTypeRootsHost {
            getCurrentDirectory?(): string;
        }
        interface HasCurrentDirectory {
            getCurrentDirectory(): string;
        }
        interface ModuleSpecifierResolutionHost {
            useCaseSensitiveFileNames(): boolean;
            fileExists(path: string): boolean;
            getCurrentDirectory(): string;
            directoryExists?(path: string): boolean;
            readFile?(path: string): string | undefined;
            realpath?(path: string): string;
            getSymlinkCache?(): SymlinkCache;
            getModuleSpecifierCache?(): ModuleSpecifierCache;
            getPackageJsonInfoCache?(): PackageJsonInfoCache | undefined;
            getGlobalTypingsCacheLocation?(): string | undefined;
            getNearestAncestorDirectoryWithPackageJson?(fileName: string, rootDir?: string): string | undefined;
            readonly redirectTargetsMap: RedirectTargetsMap;
            getProjectReferenceRedirect(fileName: string): string | undefined;
            isSourceOfProjectReferenceRedirect(fileName: string): boolean;
            getFileIncludeReasons(): MultiMap<Path, FileIncludeReason>;
            getCommonSourceDirectory(): string;
            getDefaultResolutionModeForFile(sourceFile: SourceFile): ResolutionMode;
            getModeForResolutionAtIndex(file: SourceFile, index: number): ResolutionMode;
            getModuleResolutionCache?(): ModuleResolutionCache | undefined;
            trace?(s: string): void;
        }
        interface ModulePath {
            path: string;
            isInNodeModules: boolean;
            isRedirect: boolean;
        }
        interface ResolvedModuleSpecifierInfo {
            kind: "node_modules" | "paths" | "redirect" | "relative" | "ambient" | undefined;
            modulePaths: readonly ModulePath[] | undefined;
            packageName: string | undefined;
            moduleSpecifiers: readonly string[] | undefined;
            isBlockedByPackageJsonDependencies: boolean | undefined;
        }
        interface ModuleSpecifierOptions {
            overrideImportMode?: ResolutionMode;
        }
        interface ModuleSpecifierCache {
            get(fromFileName: Path, toFileName: Path, preferences: UserPreferences, options: ModuleSpecifierOptions): Readonly<ResolvedModuleSpecifierInfo> | undefined;
            set(fromFileName: Path, toFileName: Path, preferences: UserPreferences, options: ModuleSpecifierOptions, kind: ResolvedModuleSpecifierInfo["kind"], modulePaths: readonly ModulePath[], moduleSpecifiers: readonly string[]): void;
            setBlockedByPackageJsonDependencies(fromFileName: Path, toFileName: Path, preferences: UserPreferences, options: ModuleSpecifierOptions, packageName: string | undefined, isBlockedByPackageJsonDependencies: boolean): void;
            setModulePaths(fromFileName: Path, toFileName: Path, preferences: UserPreferences, options: ModuleSpecifierOptions, modulePaths: readonly ModulePath[]): void;
            clear(): void;
            count(): number;
        }
        interface SymbolTracker {
            trackSymbol?(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): boolean;
            reportInaccessibleThisError?(): void;
            reportPrivateInBaseOfClassExpression?(propertyName: string): void;
            reportInaccessibleUniqueSymbolError?(): void;
            reportCyclicStructureError?(): void;
            reportLikelyUnsafeImportRequiredError?(specifier: string): void;
            reportTruncationError?(): void;
            moduleResolverHost?: ModuleSpecifierResolutionHost & {
                getCommonSourceDirectory(): string;
            };
            reportNonlocalAugmentation?(containingFile: SourceFile, parentSymbol: Symbol, augmentingSymbol: Symbol): void;
            reportNonSerializableProperty?(propertyName: string): void;
            reportInferenceFallback?(node: Node): void;
            pushErrorFallbackNode?(node: Declaration | undefined): void;
            popErrorFallbackNode?(): void;
        }
        interface TextSpan {
            start: number;
            length: number;
        }
        interface TextChangeRange {
            span: TextSpan;
            newLength: number;
        }
        interface ErrorOutputContainer {
            errors?: Diagnostic[];
            skipLogging?: boolean;
        }
        interface DiagnosticCollection {
            add(diagnostic: Diagnostic): void;
            lookup(diagnostic: Diagnostic): Diagnostic | undefined;
            getGlobalDiagnostics(): Diagnostic[];
            getDiagnostics(): Diagnostic[];
            getDiagnostics(fileName: string): DiagnosticWithLocation[];
        }
        interface SyntaxList extends Node {
            kind: SyntaxKind.SyntaxList;
            _children: readonly Node[];
        }
        enum ListFormat {
            None = 0,
            SingleLine = 0,
            MultiLine = 1,
            PreserveLines = 2,
            LinesMask = 3,
            NotDelimited = 0,
            BarDelimited = 4,
            AmpersandDelimited = 8,
            CommaDelimited = 16,
            AsteriskDelimited = 32,
            DelimitersMask = 60,
            AllowTrailingComma = 64,
            Indented = 128,
            SpaceBetweenBraces = 256,
            SpaceBetweenSiblings = 512,
            Braces = 1024,
            Parenthesis = 2048,
            AngleBrackets = 4096,
            SquareBrackets = 8192,
            BracketsMask = 15360,
            OptionalIfUndefined = 16384,
            OptionalIfEmpty = 32768,
            Optional = 49152,
            PreferNewLine = 65536,
            NoTrailingNewLine = 131072,
            NoInterveningComments = 262144,
            NoSpaceIfEmpty = 524288,
            SingleElement = 1048576,
            SpaceAfterList = 2097152,
            Modifiers = 2359808,
            HeritageClauses = 512,
            SingleLineTypeLiteralMembers = 768,
            MultiLineTypeLiteralMembers = 32897,
            SingleLineTupleTypeElements = 528,
            MultiLineTupleTypeElements = 657,
            UnionTypeConstituents = 516,
            IntersectionTypeConstituents = 520,
            ObjectBindingPatternElements = 525136,
            ArrayBindingPatternElements = 524880,
            ObjectLiteralExpressionProperties = 526226,
            ImportAttributes = 526226,
            ImportClauseEntries = 526226,
            ArrayLiteralExpressionElements = 8914,
            CommaListElements = 528,
            CallExpressionArguments = 2576,
            NewExpressionArguments = 18960,
            TemplateExpressionSpans = 262144,
            SingleLineBlockStatements = 768,
            MultiLineBlockStatements = 129,
            VariableDeclarationList = 528,
            SingleLineFunctionBodyStatements = 768,
            MultiLineFunctionBodyStatements = 1,
            ClassHeritageClauses = 0,
            ClassMembers = 129,
            InterfaceMembers = 129,
            EnumMembers = 145,
            CaseBlockClauses = 129,
            NamedImportsOrExportsElements = 525136,
            JsxElementOrFragmentChildren = 262144,
            JsxElementAttributes = 262656,
            CaseOrDefaultClauseStatements = 163969,
            HeritageClauseTypes = 528,
            SourceFileStatements = 131073,
            Decorators = 2146305,
            TypeArguments = 53776,
            TypeParameters = 53776,
            Parameters = 2576,
            IndexSignatureParameters = 8848,
            JSDocComment = 33
        }
        enum PragmaKindFlags {
            None = 0,
            TripleSlashXML = 1,
            SingleLine = 2,
            MultiLine = 4,
            All = 7,
            Default = 7
        }
        interface PragmaArgumentSpecification<TName extends string> {
            name: TName;
            optional?: boolean;
            captureSpan?: boolean;
        }
        interface PragmaDefinition<T1 extends string = string, T2 extends string = string, T3 extends string = string, T4 extends string = string> {
            args?: readonly [
                PragmaArgumentSpecification<T1>
            ] | readonly [
                PragmaArgumentSpecification<T1>,
                PragmaArgumentSpecification<T2>
            ] | readonly [
                PragmaArgumentSpecification<T1>,
                PragmaArgumentSpecification<T2>,
                PragmaArgumentSpecification<T3>
            ] | readonly [
                PragmaArgumentSpecification<T1>,
                PragmaArgumentSpecification<T2>,
                PragmaArgumentSpecification<T3>,
                PragmaArgumentSpecification<T4>
            ];
            kind?: PragmaKindFlags;
        }
        const commentPragmas: ConcretePragmaSpecs;
        enum JSDocParsingMode {
            ParseAll = 0,
            ParseNone = 1,
            ParseForTypeErrors = 2,
            ParseForTypeInfo = 3
        }
        type PragmaArgTypeMaybeCapture<TDesc> = TDesc extends {
            captureSpan: true;
        } ? {
            value: string;
            pos: number;
            end: number;
        } : string;
        type PragmaArgTypeOptional<TDesc, TName extends string> = TDesc extends {
            optional: true;
        } ? {
            [K in TName]?: PragmaArgTypeMaybeCapture<TDesc>;
        } : {
            [K in TName]: PragmaArgTypeMaybeCapture<TDesc>;
        };
        type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
        type ArgumentDefinitionToFieldUnion<T extends readonly PragmaArgumentSpecification<any>[]> = {
            [K in keyof T]: PragmaArgTypeOptional<T[K], T[K] extends {
                name: infer TName;
            } ? TName extends string ? TName : never : never>;
        }[Extract<keyof T, number>];
        type PragmaArgumentType<KPrag extends keyof ConcretePragmaSpecs> = ConcretePragmaSpecs[KPrag] extends {
            args: readonly PragmaArgumentSpecification<any>[];
        } ? UnionToIntersection<ArgumentDefinitionToFieldUnion<ConcretePragmaSpecs[KPrag]["args"]>> : never;
        interface ConcretePragmaSpecs {
            readonly "reference": {
                readonly args: readonly [
                    {
                        readonly name: "types";
                        readonly optional: true;
                        readonly captureSpan: true;
                    },
                    {
                        readonly name: "lib";
                        readonly optional: true;
                        readonly captureSpan: true;
                    },
                    {
                        readonly name: "path";
                        readonly optional: true;
                        readonly captureSpan: true;
                    },
                    {
                        readonly name: "no-default-lib";
                        readonly optional: true;
                    },
                    {
                        readonly name: "resolution-mode";
                        readonly optional: true;
                    },
                    {
                        readonly name: "preserve";
                        readonly optional: true;
                    }
                ];
                readonly kind: PragmaKindFlags.TripleSlashXML;
            };
            readonly "amd-dependency": {
                readonly args: readonly [
                    {
                        readonly name: "path";
                    },
                    {
                        readonly name: "name";
                        readonly optional: true;
                    }
                ];
                readonly kind: PragmaKindFlags.TripleSlashXML;
            };
            readonly "amd-module": {
                readonly args: readonly [
                    {
                        readonly name: "name";
                    }
                ];
                readonly kind: PragmaKindFlags.TripleSlashXML;
            };
            readonly "ts-check": {
                readonly kind: PragmaKindFlags.SingleLine;
            };
            readonly "ts-nocheck": {
                readonly kind: PragmaKindFlags.SingleLine;
            };
            readonly "jsx": {
                readonly args: readonly [
                    {
                        readonly name: "factory";
                    }
                ];
                readonly kind: PragmaKindFlags.MultiLine;
            };
            readonly "jsxfrag": {
                readonly args: readonly [
                    {
                        readonly name: "factory";
                    }
                ];
                readonly kind: PragmaKindFlags.MultiLine;
            };
            readonly "jsximportsource": {
                readonly args: readonly [
                    {
                        readonly name: "factory";
                    }
                ];
                readonly kind: PragmaKindFlags.MultiLine;
            };
            readonly "jsxruntime": {
                readonly args: readonly [
                    {
                        readonly name: "factory";
                    }
                ];
                readonly kind: PragmaKindFlags.MultiLine;
            };
        }
        type PragmaPseudoMap = {
            [K in keyof ConcretePragmaSpecs]: {
                arguments: PragmaArgumentType<K>;
                range: CommentRange;
            };
        };
        type PragmaPseudoMapEntry = {
            [K in keyof PragmaPseudoMap]: {
                name: K;
                args: PragmaPseudoMap[K];
            };
        }[keyof PragmaPseudoMap];
        interface ReadonlyPragmaMap extends ReadonlyMap<string, PragmaPseudoMap[keyof PragmaPseudoMap] | PragmaPseudoMap[keyof PragmaPseudoMap][]> {
            get<TKey extends keyof PragmaPseudoMap>(key: TKey): PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][];
            forEach(action: <TKey extends keyof PragmaPseudoMap>(value: PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][], key: TKey, map: ReadonlyPragmaMap) => void): void;
        }
        interface PragmaMap extends Map<string, PragmaPseudoMap[keyof PragmaPseudoMap] | PragmaPseudoMap[keyof PragmaPseudoMap][]>, ReadonlyPragmaMap {
            set<TKey extends keyof PragmaPseudoMap>(key: TKey, value: PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][]): this;
            get<TKey extends keyof PragmaPseudoMap>(key: TKey): PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][];
            forEach(action: <TKey extends keyof PragmaPseudoMap>(value: PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][], key: TKey, map: PragmaMap) => void): void;
        }
        interface CommentDirectivesMap {
            getUnusedExpectations(): CommentDirective[];
            markUsed(matchedLine: number): boolean;
        }
        interface UserPreferences {
            readonly disableSuggestions?: boolean;
            readonly quotePreference?: "auto" | "double" | "single";
            readonly includeCompletionsForModuleExports?: boolean;
            readonly includeCompletionsForImportStatements?: boolean;
            readonly includeCompletionsWithSnippetText?: boolean;
            readonly includeAutomaticOptionalChainCompletions?: boolean;
            readonly includeCompletionsWithInsertText?: boolean;
            readonly includeCompletionsWithClassMemberSnippets?: boolean;
            readonly includeCompletionsWithObjectLiteralMethodSnippets?: boolean;
            readonly useLabelDetailsInCompletionEntries?: boolean;
            readonly allowIncompleteCompletions?: boolean;
            readonly importModuleSpecifierPreference?: "shortest" | "project-relative" | "relative" | "non-relative";
            readonly importModuleSpecifierEnding?: "auto" | "minimal" | "index" | "js";
            readonly allowTextChangesInNewFiles?: boolean;
            readonly providePrefixAndSuffixTextForRename?: boolean;
            readonly includePackageJsonAutoImports?: "auto" | "on" | "off";
            readonly provideRefactorNotApplicableReason?: boolean;
            readonly jsxAttributeCompletionStyle?: "auto" | "braces" | "none";
            readonly includeInlayParameterNameHints?: "none" | "literals" | "all";
            readonly includeInlayParameterNameHintsWhenArgumentMatchesName?: boolean;
            readonly includeInlayFunctionParameterTypeHints?: boolean;
            readonly includeInlayVariableTypeHints?: boolean;
            readonly includeInlayVariableTypeHintsWhenTypeMatchesName?: boolean;
            readonly includeInlayPropertyDeclarationTypeHints?: boolean;
            readonly includeInlayFunctionLikeReturnTypeHints?: boolean;
            readonly includeInlayEnumMemberValueHints?: boolean;
            readonly interactiveInlayHints?: boolean;
            readonly allowRenameOfImportPath?: boolean;
            readonly autoImportFileExcludePatterns?: string[];
            readonly autoImportSpecifierExcludeRegexes?: string[];
            readonly preferTypeOnlyAutoImports?: boolean;
            readonly organizeImportsIgnoreCase?: "auto" | boolean;
            readonly organizeImportsCollation?: "ordinal" | "unicode";
            readonly organizeImportsLocale?: string;
            readonly organizeImportsNumericCollation?: boolean;
            readonly organizeImportsAccentCollation?: boolean;
            readonly organizeImportsCaseFirst?: "upper" | "lower" | false;
            readonly organizeImportsTypeOrder?: OrganizeImportsTypeOrder;
            readonly excludeLibrarySymbolsInNavTo?: boolean;
            readonly lazyConfiguredProjectsFromExternalProject?: boolean;
            readonly displayPartsForJSDoc?: boolean;
            readonly generateReturnInDocTemplate?: boolean;
            readonly disableLineTextInReferences?: boolean;
        }
        type OrganizeImportsTypeOrder = "last" | "inline" | "first";
        interface PseudoBigInt {
            negative: boolean;
            base10Value: string;
        }
        interface Queue<T> {
            enqueue(...items: T[]): void;
            dequeue(): T;
            isEmpty(): boolean;
        }
        interface EvaluationResolver {
            evaluateEntityNameExpression(expr: EntityNameExpression, location: Declaration | undefined): EvaluatorResult;
            evaluateElementAccessExpression(expr: ElementAccessExpression, location: Declaration | undefined): EvaluatorResult;
        }
        type HasInferredType = Exclude<VariableLikeDeclaration, JsxAttribute | EnumMember> | PropertyAccessExpression | ElementAccessExpression | BinaryExpression | ExportAssignment;
        interface SyntacticTypeNodeBuilderContext {
            flags: NodeBuilderFlags;
            tracker: Required<Pick<SymbolTracker, "reportInferenceFallback">>;
            enclosingFile: SourceFile | undefined;
            enclosingDeclaration: Node | undefined;
            approximateLength: number;
            noInferenceFallback?: boolean;
            suppressReportInferenceFallback: boolean;
        }
        interface SyntacticTypeNodeBuilderResolver {
            isOptionalParameter(p: ParameterDeclaration): boolean;
            isUndefinedIdentifierExpression(name: Identifier): boolean;
            isExpandoFunctionDeclaration(name: FunctionDeclaration | VariableDeclaration): boolean;
            getAllAccessorDeclarations(declaration: AccessorDeclaration): AllAccessorDeclarations;
            requiresAddingImplicitUndefined(declaration: ParameterDeclaration | PropertySignature | JSDocParameterTag | JSDocPropertyTag | PropertyDeclaration, symbol: Symbol | undefined, enclosingDeclaration: Node | undefined): boolean;
            isDefinitelyReferenceToGlobalSymbolObject(node: Node): boolean;
            isEntityNameVisible(context: SyntacticTypeNodeBuilderContext, entityName: EntityNameOrEntityNameExpression, shouldComputeAliasToMakeVisible?: boolean): SymbolVisibilityResult;
            serializeExistingTypeNode(context: SyntacticTypeNodeBuilderContext, node: TypeNode, addUndefined?: boolean): TypeNode | undefined;
            serializeReturnTypeForSignature(context: SyntacticTypeNodeBuilderContext, signatureDeclaration: SignatureDeclaration | JSDocSignature, symbol: Symbol | undefined): TypeNode | undefined;
            serializeTypeOfExpression(context: SyntacticTypeNodeBuilderContext, expr: Expression): TypeNode;
            serializeTypeOfDeclaration(context: SyntacticTypeNodeBuilderContext, node: HasInferredType | GetAccessorDeclaration | SetAccessorDeclaration, symbol: Symbol | undefined): TypeNode | undefined;
            serializeNameOfParameter(context: SyntacticTypeNodeBuilderContext, parameter: ParameterDeclaration): BindingName | string;
            serializeTypeName(context: SyntacticTypeNodeBuilderContext, node: EntityName, isTypeOf?: boolean, typeArguments?: readonly TypeNode[]): TypeNode | undefined;
            serializeEntityName(context: SyntacticTypeNodeBuilderContext, node: EntityNameExpression): Expression | undefined;
            getJsDocPropertyOverride(context: SyntacticTypeNodeBuilderContext, jsDocTypeLiteral: JSDocTypeLiteral, jsDocProperty: JSDocPropertyLikeTag): TypeNode | undefined;
            enterNewScope(context: SyntacticTypeNodeBuilderContext, node: IntroducesNewScopeNode | ConditionalTypeNode): () => void;
            markNodeReuse<T extends Node>(context: SyntacticTypeNodeBuilderContext, range: T, location: Node | undefined): T;
            trackExistingEntityName<T extends EntityNameOrEntityNameExpression>(context: SyntacticTypeNodeBuilderContext, node: T): {
                introducesError: boolean;
                node: T;
            };
            trackComputedName(context: SyntacticTypeNodeBuilderContext, accessExpression: EntityNameOrEntityNameExpression): void;
            evaluateEntityNameExpression(expression: EntityNameExpression): EvaluatorResult;
            getModuleSpecifierOverride(context: SyntacticTypeNodeBuilderContext, parent: ImportTypeNode, lit: StringLiteral): string | undefined;
            canReuseTypeNode(context: SyntacticTypeNodeBuilderContext, existing: TypeNode): boolean;
            canReuseTypeNodeAnnotation(context: SyntacticTypeNodeBuilderContext, node: Declaration, existing: TypeNode, symbol: Symbol | undefined, requiresAddingUndefined?: boolean): boolean;
            shouldRemoveDeclaration(context: SyntacticTypeNodeBuilderContext, node: DynamicNamedDeclaration): boolean;
            hasLateBindableName(node: Declaration): node is LateBoundDeclaration | LateBoundBinaryExpressionDeclaration;
            createRecoveryBoundary(context: SyntacticTypeNodeBuilderContext): {
                startRecoveryScope(): () => void;
                finalizeBoundary(): boolean;
                markError(): void;
                hadError(): boolean;
            };
        }
        interface SyntacticNodeBuilder {
            serializeTypeOfDeclaration: (node: HasInferredType, symbol: Symbol, context: SyntacticTypeNodeBuilderContext) => TypeNode | undefined;
            serializeReturnTypeForSignature: (signature: SignatureDeclaration | JSDocSignature, symbol: Symbol, context: SyntacticTypeNodeBuilderContext) => TypeNode | undefined;
            serializeTypeOfExpression: (expr: Expression | JsxAttributeValue, context: SyntacticTypeNodeBuilderContext, addUndefined?: boolean, preserveLiterals?: boolean) => TypeNode;
            tryReuseExistingTypeNode: (context: SyntacticTypeNodeBuilderContext, existing: TypeNode) => TypeNode | undefined;
            serializeTypeOfAccessor: (accessor: AccessorDeclaration, symbol: Symbol, context: SyntacticTypeNodeBuilderContext) => TypeNode | undefined;
        }
        type IntroducesNewScopeNode = SignatureDeclaration | JSDocSignature | MappedTypeNode;
        function generateDjb2Hash(data: string): string;
        function setStackTraceLimit(): void;
        function getModifiedTime(host: {
            getModifiedTime: NonNullable<System["getModifiedTime"]>;
        }, fileName: string): Date;
        function getFileWatcherEventKind(oldTime: number, newTime: number): FileWatcherEventKind;
        function sysLog(s: string): void;
        function setSysLog(logger: typeof sysLog): void;
        function createSystemWatchFunctions({ pollingWatchFileWorker, getModifiedTime, setTimeout, clearTimeout, fsWatchWorker, fileSystemEntryExists, useCaseSensitiveFileNames, getCurrentDirectory, fsSupportsRecursiveFsWatch, getAccessibleSortedChildDirectories, realpath, tscWatchFile, useNonPollingWatchers, tscWatchDirectory, inodeWatching, fsWatchWithTimestamp, sysLog }: CreateSystemWatchFunctions): {
            watchFile: HostWatchFile;
            watchDirectory: HostWatchDirectory;
        };
        function patchWriteFileEnsuringDirectory(sys: System): void;
        function setSys(s: System): void;
        enum FileWatcherEventKind {
            Created = 0,
            Changed = 1,
            Deleted = 2
        }
        type FileWatcherCallback = (fileName: string, eventKind: FileWatcherEventKind, modifiedTime?: Date) => void;
        type DirectoryWatcherCallback = (fileName: string) => void;
        enum PollingInterval {
            High = 2000,
            Medium = 500,
            Low = 250
        }
        type HostWatchFile = (fileName: string, callback: FileWatcherCallback, pollingInterval: PollingInterval, options: WatchOptions | undefined) => FileWatcher;
        type HostWatchDirectory = (fileName: string, callback: DirectoryWatcherCallback, recursive: boolean, options: WatchOptions | undefined) => FileWatcher;
        const missingFileModifiedTime: Date;
        let unchangedPollThresholds: {
            [K in PollingInterval]: number;
        };
        const ignoredPaths: readonly string[];
        type FsWatchCallback = (eventName: "rename" | "change", relativeFileName: string | undefined | null, modifiedTime?: Date) => void;
        type FsWatch = (fileOrDirectory: string, entryKind: FileSystemEntryKind, callback: FsWatchCallback, recursive: boolean, fallbackPollingInterval: PollingInterval, fallbackOptions: WatchOptions | undefined) => FileWatcher;
        interface FsWatchWorkerWatcher extends FileWatcher {
            on(eventName: string, listener: () => void): void;
        }
        type FsWatchWorker = (fileOrDirectory: string, recursive: boolean, callback: FsWatchCallback) => FsWatchWorkerWatcher;
        enum FileSystemEntryKind {
            File = 0,
            Directory = 1
        }
        type FileSystemEntryExists = (fileorDirectrory: string, entryKind: FileSystemEntryKind) => boolean;
        interface CreateSystemWatchFunctions {
            pollingWatchFileWorker: HostWatchFile;
            getModifiedTime: NonNullable<System["getModifiedTime"]>;
            setTimeout: NonNullable<System["setTimeout"]>;
            clearTimeout: NonNullable<System["clearTimeout"]>;
            fsWatchWorker: FsWatchWorker;
            fileSystemEntryExists: FileSystemEntryExists;
            useCaseSensitiveFileNames: boolean;
            getCurrentDirectory: System["getCurrentDirectory"];
            fsSupportsRecursiveFsWatch: boolean;
            getAccessibleSortedChildDirectories(path: string): readonly string[];
            realpath(s: string): string;
            tscWatchFile: string | undefined;
            useNonPollingWatchers?: boolean;
            tscWatchDirectory: string | undefined;
            inodeWatching: boolean;
            fsWatchWithTimestamp: boolean | undefined;
            sysLog: (s: string) => void;
        }
        type BufferEncoding = "ascii" | "utf8" | "utf-8" | "utf16le" | "ucs2" | "ucs-2" | "base64" | "latin1" | "binary" | "hex";
        interface System {
            args: string[];
            newLine: string;
            useCaseSensitiveFileNames: boolean;
            write(s: string): void;
            writeOutputIsTTY?(): boolean;
            getWidthOfTerminal?(): number;
            readFile(path: string, encoding?: string): string | undefined;
            getFileSize?(path: string): number;
            writeFile(path: string, data: string, writeByteOrderMark?: boolean): void;
            watchFile?(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
            watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
            preferNonRecursiveWatch?: boolean;
            resolvePath(path: string): string;
            fileExists(path: string): boolean;
            directoryExists(path: string): boolean;
            createDirectory(path: string): void;
            getExecutingFilePath(): string;
            getCurrentDirectory(): string;
            getDirectories(path: string): string[];
            readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
            getModifiedTime?(path: string): Date | undefined;
            setModifiedTime?(path: string, time: Date): void;
            deleteFile?(path: string): void;
            createHash?(data: string): string;
            createSHA256Hash?(data: string): string;
            getMemoryUsage?(): number;
            exit(exitCode?: number): void;
            enableCPUProfiler?(path: string, continuation: () => void): boolean;
            disableCPUProfiler?(continuation: () => void): boolean;
            cpuProfilingEnabled?(): boolean;
            realpath?(path: string): string;
            getEnvironmentVariable(name: string): string;
            tryEnableSourceMapsForHost?(): void;
            getAccessibleFileSystemEntries?(path: string): FileSystemEntries;
            debugMode?: boolean;
            setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;
            clearTimeout?(timeoutId: any): void;
            clearScreen?(): void;
            setBlocking?(): void;
            base64decode?(input: string): string;
            base64encode?(input: string): string;
            require?(baseDir: string, moduleName: string): ModuleImportResult;
            now?(): Date;
            storeSignatureInfo?: boolean;
        }
        interface FileWatcher {
            close(): void;
        }
        let sys: System;
        function isAnyDirectorySeparator(charCode: number): boolean;
        function isUrl(path: string): boolean;
        function isRootedDiskPath(path: string): boolean;
        function isDiskPathRoot(path: string): boolean;
        function pathIsAbsolute(path: string): boolean;
        function pathIsRelative(path: string): boolean;
        function pathIsBareSpecifier(path: string): boolean;
        function hasExtension(fileName: string): boolean;
        function fileExtensionIs(path: string, extension: string): boolean;
        function fileExtensionIsOneOf(path: string, extensions: readonly string[]): boolean;
        function hasTrailingDirectorySeparator(path: string): boolean;
        function getRootLength(path: string): number;
        function getDirectoryPath(path: Path): Path;
        function getDirectoryPath(path: string): string;
        function getBaseFileName(path: string): string;
        function getBaseFileName(path: string, extensions: string | readonly string[], ignoreCase: boolean): string;
        function getAnyExtensionFromPath(path: string): string;
        function getAnyExtensionFromPath(path: string, extensions: string | readonly string[], ignoreCase: boolean): string;
        function getPathComponents(path: Path): PathPathComponents;
        function getPathComponents(path: string, currentDirectory?: string): string[];
        function getPathFromPathComponents<T extends string>(pathComponents: readonly T[], length?: number): T;
        function normalizeSlashes(path: string): string;
        function reducePathComponents(components: readonly string[]): string[];
        function combinePaths(path: string, ...paths: (string | undefined)[]): string;
        function resolvePath(path: string, ...paths: (string | undefined)[]): string;
        function getNormalizedPathComponents(path: string, currentDirectory: string | undefined): string[];
        function getNormalizedAbsolutePath(path: string, currentDirectory: string | undefined): string;
        function normalizePath(path: string): string;
        function getNormalizedAbsolutePathWithoutRoot(fileName: string, currentDirectory: string | undefined): string;
        function toPath(fileName: string, basePath: string | undefined, getCanonicalFileName: (path: string) => string): Path;
        function removeTrailingDirectorySeparator(path: Path): Path;
        function removeTrailingDirectorySeparator(path: string): string;
        function ensureTrailingDirectorySeparator(path: Path): Path;
        function ensureTrailingDirectorySeparator(path: string): string;
        function ensurePathIsNonModuleName(path: string): string;
        function changeAnyExtension(path: string, ext: string): string;
        function changeAnyExtension(path: string, ext: string, extensions: string | readonly string[], ignoreCase: boolean): string;
        function changeFullExtension(path: string, newExtension: string): string;
        function comparePathsCaseSensitive(a: string, b: string): Comparison;
        function comparePathsCaseInsensitive(a: string, b: string): Comparison;
        function comparePaths(a: string, b: string, ignoreCase?: boolean): Comparison;
        function comparePaths(a: string, b: string, currentDirectory: string, ignoreCase?: boolean): Comparison;
        function containsPath(parent: string, child: string, ignoreCase?: boolean): boolean;
        function containsPath(parent: string, child: string, currentDirectory: string, ignoreCase?: boolean): boolean;
        function startsWithDirectory(fileName: string, directoryName: string, getCanonicalFileName: GetCanonicalFileName): boolean;
        function getRelativePathFromDirectory(from: string, to: string, ignoreCase: boolean): string;
        function getRelativePathFromDirectory(fromDirectory: string, to: string, getCanonicalFileName: GetCanonicalFileName): string;
        function convertToRelativePath(absoluteOrRelativePath: string, basePath: string, getCanonicalFileName: (path: string) => string): string;
        function getRelativePathFromFile(from: string, to: string, getCanonicalFileName: GetCanonicalFileName): string;
        function getRelativePathToDirectoryOrUrl(directoryPathOrUrl: string, relativeOrAbsolutePath: string, currentDirectory: string, getCanonicalFileName: GetCanonicalFileName, isAbsolutePathAnUrl: boolean): string;
        function forEachAncestorDirectory<T>(directory: Path, callback: (directory: Path) => T | undefined): T | undefined;
        function forEachAncestorDirectory<T>(directory: string, callback: (directory: string) => T | undefined): T | undefined;
        function isNodeModulesDirectory(dirPath: Path): boolean;
        const directorySeparator = "/";
        const altDirectorySeparator = "\\";
        type PathPathComponents = Path[] & {
            __pathComponensBrand: any;
        };
        const Diagnostics: {
            Unterminated_string_literal: DiagnosticMessage;
            Identifier_expected: DiagnosticMessage;
            _0_expected: DiagnosticMessage;
            A_file_cannot_have_a_reference_to_itself: DiagnosticMessage;
            The_parser_expected_to_find_a_1_to_match_the_0_token_here: DiagnosticMessage;
            Trailing_comma_not_allowed: DiagnosticMessage;
            Asterisk_Slash_expected: DiagnosticMessage;
            An_element_access_expression_should_take_an_argument: DiagnosticMessage;
            Unexpected_token: DiagnosticMessage;
            A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma: DiagnosticMessage;
            A_rest_parameter_must_be_last_in_a_parameter_list: DiagnosticMessage;
            Parameter_cannot_have_question_mark_and_initializer: DiagnosticMessage;
            A_required_parameter_cannot_follow_an_optional_parameter: DiagnosticMessage;
            An_index_signature_cannot_have_a_rest_parameter: DiagnosticMessage;
            An_index_signature_parameter_cannot_have_an_accessibility_modifier: DiagnosticMessage;
            An_index_signature_parameter_cannot_have_a_question_mark: DiagnosticMessage;
            An_index_signature_parameter_cannot_have_an_initializer: DiagnosticMessage;
            An_index_signature_must_have_a_type_annotation: DiagnosticMessage;
            An_index_signature_parameter_must_have_a_type_annotation: DiagnosticMessage;
            readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature: DiagnosticMessage;
            An_index_signature_cannot_have_a_trailing_comma: DiagnosticMessage;
            Accessibility_modifier_already_seen: DiagnosticMessage;
            _0_modifier_must_precede_1_modifier: DiagnosticMessage;
            _0_modifier_already_seen: DiagnosticMessage;
            _0_modifier_cannot_appear_on_class_elements_of_this_kind: DiagnosticMessage;
            super_must_be_followed_by_an_argument_list_or_member_access: DiagnosticMessage;
            Only_ambient_modules_can_use_quoted_names: DiagnosticMessage;
            Statements_are_not_allowed_in_ambient_contexts: DiagnosticMessage;
            A_declare_modifier_cannot_be_used_in_an_already_ambient_context: DiagnosticMessage;
            Initializers_are_not_allowed_in_ambient_contexts: DiagnosticMessage;
            _0_modifier_cannot_be_used_in_an_ambient_context: DiagnosticMessage;
            _0_modifier_cannot_be_used_here: DiagnosticMessage;
            _0_modifier_cannot_appear_on_a_module_or_namespace_element: DiagnosticMessage;
            Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier: DiagnosticMessage;
            A_rest_parameter_cannot_be_optional: DiagnosticMessage;
            A_rest_parameter_cannot_have_an_initializer: DiagnosticMessage;
            A_set_accessor_must_have_exactly_one_parameter: DiagnosticMessage;
            A_set_accessor_cannot_have_an_optional_parameter: DiagnosticMessage;
            A_set_accessor_parameter_cannot_have_an_initializer: DiagnosticMessage;
            A_set_accessor_cannot_have_rest_parameter: DiagnosticMessage;
            A_get_accessor_cannot_have_parameters: DiagnosticMessage;
            Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value: DiagnosticMessage;
            Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: DiagnosticMessage;
            The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: DiagnosticMessage;
            A_promise_must_have_a_then_method: DiagnosticMessage;
            The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback: DiagnosticMessage;
            Enum_member_must_have_initializer: DiagnosticMessage;
            Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method: DiagnosticMessage;
            An_export_assignment_cannot_be_used_in_a_namespace: DiagnosticMessage;
            The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0: DiagnosticMessage;
            The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type: DiagnosticMessage;
            In_ambient_enum_declarations_member_initializer_must_be_constant_expression: DiagnosticMessage;
            Unexpected_token_A_constructor_method_accessor_or_property_was_expected: DiagnosticMessage;
            Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces: DiagnosticMessage;
            _0_modifier_cannot_appear_on_a_type_member: DiagnosticMessage;
            _0_modifier_cannot_appear_on_an_index_signature: DiagnosticMessage;
            A_0_modifier_cannot_be_used_with_an_import_declaration: DiagnosticMessage;
            Invalid_reference_directive_syntax: DiagnosticMessage;
            _0_modifier_cannot_appear_on_a_constructor_declaration: DiagnosticMessage;
            _0_modifier_cannot_appear_on_a_parameter: DiagnosticMessage;
            Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: DiagnosticMessage;
            Type_parameters_cannot_appear_on_a_constructor_declaration: DiagnosticMessage;
            Type_annotation_cannot_appear_on_a_constructor_declaration: DiagnosticMessage;
            An_accessor_cannot_have_type_parameters: DiagnosticMessage;
            A_set_accessor_cannot_have_a_return_type_annotation: DiagnosticMessage;
            An_index_signature_must_have_exactly_one_parameter: DiagnosticMessage;
            _0_list_cannot_be_empty: DiagnosticMessage;
            Type_parameter_list_cannot_be_empty: DiagnosticMessage;
            Type_argument_list_cannot_be_empty: DiagnosticMessage;
            Invalid_use_of_0_in_strict_mode: DiagnosticMessage;
            with_statements_are_not_allowed_in_strict_mode: DiagnosticMessage;
            delete_cannot_be_called_on_an_identifier_in_strict_mode: DiagnosticMessage;
            for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules: DiagnosticMessage;
            A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: DiagnosticMessage;
            A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: DiagnosticMessage;
            The_left_hand_side_of_a_for_of_statement_may_not_be_async: DiagnosticMessage;
            Jump_target_cannot_cross_function_boundary: DiagnosticMessage;
            A_return_statement_can_only_be_used_within_a_function_body: DiagnosticMessage;
            Expression_expected: DiagnosticMessage;
            Type_expected: DiagnosticMessage;
            Private_field_0_must_be_declared_in_an_enclosing_class: DiagnosticMessage;
            A_default_clause_cannot_appear_more_than_once_in_a_switch_statement: DiagnosticMessage;
            Duplicate_label_0: DiagnosticMessage;
            A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement: DiagnosticMessage;
            A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement: DiagnosticMessage;
            An_object_literal_cannot_have_multiple_properties_with_the_same_name: DiagnosticMessage;
            An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name: DiagnosticMessage;
            An_object_literal_cannot_have_property_and_accessor_with_the_same_name: DiagnosticMessage;
            An_export_assignment_cannot_have_modifiers: DiagnosticMessage;
            Octal_literals_are_not_allowed_Use_the_syntax_0: DiagnosticMessage;
            Variable_declaration_list_cannot_be_empty: DiagnosticMessage;
            Digit_expected: DiagnosticMessage;
            Hexadecimal_digit_expected: DiagnosticMessage;
            Unexpected_end_of_text: DiagnosticMessage;
            Invalid_character: DiagnosticMessage;
            Declaration_or_statement_expected: DiagnosticMessage;
            Statement_expected: DiagnosticMessage;
            case_or_default_expected: DiagnosticMessage;
            Property_or_signature_expected: DiagnosticMessage;
            Enum_member_expected: DiagnosticMessage;
            Variable_declaration_expected: DiagnosticMessage;
            Argument_expression_expected: DiagnosticMessage;
            Property_assignment_expected: DiagnosticMessage;
            Expression_or_comma_expected: DiagnosticMessage;
            Parameter_declaration_expected: DiagnosticMessage;
            Type_parameter_declaration_expected: DiagnosticMessage;
            Type_argument_expected: DiagnosticMessage;
            String_literal_expected: DiagnosticMessage;
            Line_break_not_permitted_here: DiagnosticMessage;
            or_expected: DiagnosticMessage;
            or_JSX_element_expected: DiagnosticMessage;
            Declaration_expected: DiagnosticMessage;
            Import_declarations_in_a_namespace_cannot_reference_a_module: DiagnosticMessage;
            Cannot_use_imports_exports_or_module_augmentations_when_module_is_none: DiagnosticMessage;
            File_name_0_differs_from_already_included_file_name_1_only_in_casing: DiagnosticMessage;
            _0_declarations_must_be_initialized: DiagnosticMessage;
            _0_declarations_can_only_be_declared_inside_a_block: DiagnosticMessage;
            Unterminated_template_literal: DiagnosticMessage;
            Unterminated_regular_expression_literal: DiagnosticMessage;
            An_object_member_cannot_be_declared_optional: DiagnosticMessage;
            A_yield_expression_is_only_allowed_in_a_generator_body: DiagnosticMessage;
            Computed_property_names_are_not_allowed_in_enums: DiagnosticMessage;
            A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: DiagnosticMessage;
            A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type: DiagnosticMessage;
            A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: DiagnosticMessage;
            A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: DiagnosticMessage;
            A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: DiagnosticMessage;
            A_comma_expression_is_not_allowed_in_a_computed_property_name: DiagnosticMessage;
            extends_clause_already_seen: DiagnosticMessage;
            extends_clause_must_precede_implements_clause: DiagnosticMessage;
            Classes_can_only_extend_a_single_class: DiagnosticMessage;
            implements_clause_already_seen: DiagnosticMessage;
            Interface_declaration_cannot_have_implements_clause: DiagnosticMessage;
            Binary_digit_expected: DiagnosticMessage;
            Octal_digit_expected: DiagnosticMessage;
            Unexpected_token_expected: DiagnosticMessage;
            Property_destructuring_pattern_expected: DiagnosticMessage;
            Array_element_destructuring_pattern_expected: DiagnosticMessage;
            A_destructuring_declaration_must_have_an_initializer: DiagnosticMessage;
            An_implementation_cannot_be_declared_in_ambient_contexts: DiagnosticMessage;
            Modifiers_cannot_appear_here: DiagnosticMessage;
            Merge_conflict_marker_encountered: DiagnosticMessage;
            A_rest_element_cannot_have_an_initializer: DiagnosticMessage;
            A_parameter_property_may_not_be_declared_using_a_binding_pattern: DiagnosticMessage;
            Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement: DiagnosticMessage;
            The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer: DiagnosticMessage;
            The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer: DiagnosticMessage;
            An_import_declaration_cannot_have_modifiers: DiagnosticMessage;
            Module_0_has_no_default_export: DiagnosticMessage;
            An_export_declaration_cannot_have_modifiers: DiagnosticMessage;
            Export_declarations_are_not_permitted_in_a_namespace: DiagnosticMessage;
            export_Asterisk_does_not_re_export_a_default: DiagnosticMessage;
            Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified: DiagnosticMessage;
            Catch_clause_variable_cannot_have_an_initializer: DiagnosticMessage;
            An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive: DiagnosticMessage;
            Unterminated_Unicode_escape_sequence: DiagnosticMessage;
            Line_terminator_not_permitted_before_arrow: DiagnosticMessage;
            Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead: DiagnosticMessage;
            Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead: DiagnosticMessage;
            Re_exporting_a_type_when_0_is_enabled_requires_using_export_type: DiagnosticMessage;
            Decorators_are_not_valid_here: DiagnosticMessage;
            Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name: DiagnosticMessage;
            Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0: DiagnosticMessage;
            Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of_0_For_more_information_see_https_Colon_Slash_Slashdeveloper_mozilla_org_Slashen_US_Slashdocs_SlashWeb_SlashJavaScript_SlashReference_SlashStrict_mode: DiagnosticMessage;
            A_class_declaration_without_the_default_modifier_must_have_a_name: DiagnosticMessage;
            Identifier_expected_0_is_a_reserved_word_in_strict_mode: DiagnosticMessage;
            Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode: DiagnosticMessage;
            Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode: DiagnosticMessage;
            Invalid_use_of_0_Modules_are_automatically_in_strict_mode: DiagnosticMessage;
            Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules: DiagnosticMessage;
            Export_assignment_is_not_supported_when_module_flag_is_system: DiagnosticMessage;
            Generators_are_not_allowed_in_an_ambient_context: DiagnosticMessage;
            An_overload_signature_cannot_be_declared_as_a_generator: DiagnosticMessage;
            _0_tag_already_specified: DiagnosticMessage;
            Signature_0_must_be_a_type_predicate: DiagnosticMessage;
            Cannot_find_parameter_0: DiagnosticMessage;
            Type_predicate_0_is_not_assignable_to_1: DiagnosticMessage;
            Parameter_0_is_not_in_the_same_position_as_parameter_1: DiagnosticMessage;
            A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods: DiagnosticMessage;
            A_type_predicate_cannot_reference_a_rest_parameter: DiagnosticMessage;
            A_type_predicate_cannot_reference_element_0_in_a_binding_pattern: DiagnosticMessage;
            An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration: DiagnosticMessage;
            An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module: DiagnosticMessage;
            An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module: DiagnosticMessage;
            An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file: DiagnosticMessage;
            A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module: DiagnosticMessage;
            The_return_type_of_a_property_decorator_function_must_be_either_void_or_any: DiagnosticMessage;
            The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any: DiagnosticMessage;
            Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression: DiagnosticMessage;
            Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression: DiagnosticMessage;
            Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression: DiagnosticMessage;
            Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression: DiagnosticMessage;
            abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration: DiagnosticMessage;
            _0_modifier_cannot_be_used_with_1_modifier: DiagnosticMessage;
            Abstract_methods_can_only_appear_within_an_abstract_class: DiagnosticMessage;
            Method_0_cannot_have_an_implementation_because_it_is_marked_abstract: DiagnosticMessage;
            An_interface_property_cannot_have_an_initializer: DiagnosticMessage;
            A_type_literal_property_cannot_have_an_initializer: DiagnosticMessage;
            A_class_member_cannot_have_the_0_keyword: DiagnosticMessage;
            A_decorator_can_only_decorate_a_method_implementation_not_an_overload: DiagnosticMessage;
            Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES5: DiagnosticMessage;
            Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES5_Class_definitions_are_automatically_in_strict_mode: DiagnosticMessage;
            Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES5_Modules_are_automatically_in_strict_mode: DiagnosticMessage;
            Abstract_properties_can_only_appear_within_an_abstract_class: DiagnosticMessage;
            A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference: DiagnosticMessage;
            A_definite_assignment_assertion_is_not_permitted_in_this_context: DiagnosticMessage;
            A_required_element_cannot_follow_an_optional_element: DiagnosticMessage;
            A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration: DiagnosticMessage;
            Module_0_can_only_be_default_imported_using_the_1_flag: DiagnosticMessage;
            Keywords_cannot_contain_escape_characters: DiagnosticMessage;
            Already_included_file_name_0_differs_from_file_name_1_only_in_casing: DiagnosticMessage;
            Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module: DiagnosticMessage;
            Declarations_with_initializers_cannot_also_have_definite_assignment_assertions: DiagnosticMessage;
            Declarations_with_definite_assignment_assertions_must_also_have_type_annotations: DiagnosticMessage;
            A_rest_element_cannot_follow_another_rest_element: DiagnosticMessage;
            An_optional_element_cannot_follow_a_rest_element: DiagnosticMessage;
            Property_0_cannot_have_an_initializer_because_it_is_marked_abstract: DiagnosticMessage;
            An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type: DiagnosticMessage;
            Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled: DiagnosticMessage;
            Decorator_function_return_type_0_is_not_assignable_to_type_1: DiagnosticMessage;
            Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any: DiagnosticMessage;
            A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled: DiagnosticMessage;
            _0_modifier_cannot_appear_on_a_type_parameter: DiagnosticMessage;
            _0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias: DiagnosticMessage;
            accessor_modifier_can_only_appear_on_a_property_declaration: DiagnosticMessage;
            An_accessor_property_cannot_be_declared_optional: DiagnosticMessage;
            _0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class: DiagnosticMessage;
            The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0: DiagnosticMessage;
            The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0: DiagnosticMessage;
            Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement: DiagnosticMessage;
            Cannot_access_0_from_another_file_without_qualification_when_1_is_enabled_Use_2_instead: DiagnosticMessage;
            An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type: DiagnosticMessage;
            An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration: DiagnosticMessage;
            An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type: DiagnosticMessage;
            An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration: DiagnosticMessage;
            ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled: DiagnosticMessage;
            A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled: DiagnosticMessage;
            An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled: DiagnosticMessage;
            _0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported: DiagnosticMessage;
            _0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default: DiagnosticMessage;
            _0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported: DiagnosticMessage;
            _0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default: DiagnosticMessage;
            ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_module_is_set_to_preserve: DiagnosticMessage;
            This_syntax_is_not_allowed_when_erasableSyntaxOnly_is_enabled: DiagnosticMessage;
            with_statements_are_not_allowed_in_an_async_function_block: DiagnosticMessage;
            await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules: DiagnosticMessage;
            The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level: DiagnosticMessage;
            Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern: DiagnosticMessage;
            The_body_of_an_if_statement_cannot_be_the_empty_statement: DiagnosticMessage;
            Global_module_exports_may_only_appear_in_module_files: DiagnosticMessage;
            Global_module_exports_may_only_appear_in_declaration_files: DiagnosticMessage;
            Global_module_exports_may_only_appear_at_top_level: DiagnosticMessage;
            A_parameter_property_cannot_be_declared_using_a_rest_parameter: DiagnosticMessage;
            An_abstract_accessor_cannot_have_an_implementation: DiagnosticMessage;
            A_default_export_can_only_be_used_in_an_ECMAScript_style_module: DiagnosticMessage;
            Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: DiagnosticMessage;
            Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: DiagnosticMessage;
            Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: DiagnosticMessage;
            Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_node18_or_nodenext: DiagnosticMessage;
            Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_node18_nodenext_or_preserve: DiagnosticMessage;
            Argument_of_dynamic_import_cannot_be_spread_element: DiagnosticMessage;
            This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments: DiagnosticMessage;
            String_literal_with_double_quotes_expected: DiagnosticMessage;
            Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal: DiagnosticMessage;
            _0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0: DiagnosticMessage;
            A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly: DiagnosticMessage;
            A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly: DiagnosticMessage;
            A_variable_whose_type_is_a_unique_symbol_type_must_be_const: DiagnosticMessage;
            unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name: DiagnosticMessage;
            unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement: DiagnosticMessage;
            unique_symbol_types_are_not_allowed_here: DiagnosticMessage;
            An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead: DiagnosticMessage;
            infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type: DiagnosticMessage;
            Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here: DiagnosticMessage;
            Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0: DiagnosticMessage;
            Class_constructor_may_not_be_an_accessor: DiagnosticMessage;
            The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_node18_or_nodenext: DiagnosticMessage;
            A_label_is_not_allowed_here: DiagnosticMessage;
            An_expression_of_type_void_cannot_be_tested_for_truthiness: DiagnosticMessage;
            This_parameter_is_not_allowed_with_use_strict_directive: DiagnosticMessage;
            use_strict_directive_cannot_be_used_with_non_simple_parameter_list: DiagnosticMessage;
            Non_simple_parameter_declared_here: DiagnosticMessage;
            use_strict_directive_used_here: DiagnosticMessage;
            Print_the_final_configuration_instead_of_building: DiagnosticMessage;
            An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal: DiagnosticMessage;
            A_bigint_literal_cannot_use_exponential_notation: DiagnosticMessage;
            A_bigint_literal_must_be_an_integer: DiagnosticMessage;
            readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types: DiagnosticMessage;
            A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals: DiagnosticMessage;
            Did_you_mean_to_mark_this_function_as_async: DiagnosticMessage;
            An_enum_member_name_must_be_followed_by_a_or: DiagnosticMessage;
            Tagged_template_expressions_are_not_permitted_in_an_optional_chain: DiagnosticMessage;
            Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here: DiagnosticMessage;
            Type_0_does_not_satisfy_the_expected_type_1: DiagnosticMessage;
            _0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type: DiagnosticMessage;
            _0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type: DiagnosticMessage;
            A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both: DiagnosticMessage;
            Convert_to_type_only_export: DiagnosticMessage;
            Convert_all_re_exported_types_to_type_only_exports: DiagnosticMessage;
            Split_into_two_separate_import_declarations: DiagnosticMessage;
            Split_all_invalid_type_only_imports: DiagnosticMessage;
            Class_constructor_may_not_be_a_generator: DiagnosticMessage;
            Did_you_mean_0: DiagnosticMessage;
            await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module: DiagnosticMessage;
            _0_was_imported_here: DiagnosticMessage;
            _0_was_exported_here: DiagnosticMessage;
            Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_node18_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher: DiagnosticMessage;
            An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type: DiagnosticMessage;
            An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type: DiagnosticMessage;
            Unexpected_token_Did_you_mean_or_rbrace: DiagnosticMessage;
            Unexpected_token_Did_you_mean_or_gt: DiagnosticMessage;
            Function_type_notation_must_be_parenthesized_when_used_in_a_union_type: DiagnosticMessage;
            Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type: DiagnosticMessage;
            Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type: DiagnosticMessage;
            Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type: DiagnosticMessage;
            _0_is_not_allowed_as_a_variable_declaration_name: DiagnosticMessage;
            _0_is_not_allowed_as_a_parameter_name: DiagnosticMessage;
            An_import_alias_cannot_use_import_type: DiagnosticMessage;
            Imported_via_0_from_file_1: DiagnosticMessage;
            Imported_via_0_from_file_1_with_packageId_2: DiagnosticMessage;
            Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions: DiagnosticMessage;
            Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions: DiagnosticMessage;
            Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions: DiagnosticMessage;
            Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions: DiagnosticMessage;
            File_is_included_via_import_here: DiagnosticMessage;
            Referenced_via_0_from_file_1: DiagnosticMessage;
            File_is_included_via_reference_here: DiagnosticMessage;
            Type_library_referenced_via_0_from_file_1: DiagnosticMessage;
            Type_library_referenced_via_0_from_file_1_with_packageId_2: DiagnosticMessage;
            File_is_included_via_type_library_reference_here: DiagnosticMessage;
            Library_referenced_via_0_from_file_1: DiagnosticMessage;
            File_is_included_via_library_reference_here: DiagnosticMessage;
            Matched_by_include_pattern_0_in_1: DiagnosticMessage;
            File_is_matched_by_include_pattern_specified_here: DiagnosticMessage;
            Part_of_files_list_in_tsconfig_json: DiagnosticMessage;
            File_is_matched_by_files_list_specified_here: DiagnosticMessage;
            Output_from_referenced_project_0_included_because_1_specified: DiagnosticMessage;
            Output_from_referenced_project_0_included_because_module_is_specified_as_none: DiagnosticMessage;
            File_is_output_from_referenced_project_specified_here: DiagnosticMessage;
            Source_from_referenced_project_0_included_because_1_specified: DiagnosticMessage;
            Source_from_referenced_project_0_included_because_module_is_specified_as_none: DiagnosticMessage;
            File_is_source_from_referenced_project_specified_here: DiagnosticMessage;
            Entry_point_of_type_library_0_specified_in_compilerOptions: DiagnosticMessage;
            Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1: DiagnosticMessage;
            File_is_entry_point_of_type_library_specified_here: DiagnosticMessage;
            Entry_point_for_implicit_type_library_0: DiagnosticMessage;
            Entry_point_for_implicit_type_library_0_with_packageId_1: DiagnosticMessage;
            Library_0_specified_in_compilerOptions: DiagnosticMessage;
            File_is_library_specified_here: DiagnosticMessage;
            Default_library: DiagnosticMessage;
            Default_library_for_target_0: DiagnosticMessage;
            File_is_default_library_for_target_specified_here: DiagnosticMessage;
            Root_file_specified_for_compilation: DiagnosticMessage;
            File_is_output_of_project_reference_source_0: DiagnosticMessage;
            File_redirects_to_file_0: DiagnosticMessage;
            The_file_is_in_the_program_because_Colon: DiagnosticMessage;
            for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module: DiagnosticMessage;
            Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_node18_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher: DiagnosticMessage;
            Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters: DiagnosticMessage;
            Unexpected_keyword_or_identifier: DiagnosticMessage;
            Unknown_keyword_or_identifier_Did_you_mean_0: DiagnosticMessage;
            Decorators_must_precede_the_name_and_all_keywords_of_property_declarations: DiagnosticMessage;
            Namespace_must_be_given_a_name: DiagnosticMessage;
            Interface_must_be_given_a_name: DiagnosticMessage;
            Type_alias_must_be_given_a_name: DiagnosticMessage;
            Variable_declaration_not_allowed_at_this_location: DiagnosticMessage;
            Cannot_start_a_function_call_in_a_type_annotation: DiagnosticMessage;
            Expected_for_property_initializer: DiagnosticMessage;
            Module_declaration_names_may_only_use_or_quoted_strings: DiagnosticMessage;
            _0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled: DiagnosticMessage;
            Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed: DiagnosticMessage;
            Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments: DiagnosticMessage;
            Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression: DiagnosticMessage;
            resolution_mode_should_be_either_require_or_import: DiagnosticMessage;
            resolution_mode_can_only_be_set_for_type_only_imports: DiagnosticMessage;
            resolution_mode_is_the_only_valid_key_for_type_import_assertions: DiagnosticMessage;
            Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require: DiagnosticMessage;
            Matched_by_default_include_pattern_Asterisk_Asterisk_Slash_Asterisk: DiagnosticMessage;
            File_is_ECMAScript_module_because_0_has_field_type_with_value_module: DiagnosticMessage;
            File_is_CommonJS_module_because_0_has_field_type_whose_value_is_not_module: DiagnosticMessage;
            File_is_CommonJS_module_because_0_does_not_have_field_type: DiagnosticMessage;
            File_is_CommonJS_module_because_package_json_was_not_found: DiagnosticMessage;
            resolution_mode_is_the_only_valid_key_for_type_import_attributes: DiagnosticMessage;
            Type_import_attributes_should_have_exactly_one_key_resolution_mode_with_value_import_or_require: DiagnosticMessage;
            The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output: DiagnosticMessage;
            Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead: DiagnosticMessage;
            catch_or_finally_expected: DiagnosticMessage;
            An_import_declaration_can_only_be_used_at_the_top_level_of_a_module: DiagnosticMessage;
            An_export_declaration_can_only_be_used_at_the_top_level_of_a_module: DiagnosticMessage;
            Control_what_method_is_used_to_detect_module_format_JS_files: DiagnosticMessage;
            auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_with_module_Colon_node16_as_modules: DiagnosticMessage;
            An_instantiation_expression_cannot_be_followed_by_a_property_access: DiagnosticMessage;
            Identifier_or_string_literal_expected: DiagnosticMessage;
            The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead: DiagnosticMessage;
            To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_package_json_file_with_type_Colon_module: DiagnosticMessage;
            To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Colon_module_to_1: DiagnosticMessage;
            To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0: DiagnosticMessage;
            To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_Colon_module: DiagnosticMessage;
            _0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled: DiagnosticMessage;
            _0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled: DiagnosticMessage;
            Decorator_used_before_export_here: DiagnosticMessage;
            Octal_escape_sequences_are_not_allowed_Use_the_syntax_0: DiagnosticMessage;
            Escape_sequence_0_is_not_allowed: DiagnosticMessage;
            Decimals_with_leading_zeros_are_not_allowed: DiagnosticMessage;
            File_appears_to_be_binary: DiagnosticMessage;
            _0_modifier_cannot_appear_on_a_using_declaration: DiagnosticMessage;
            _0_declarations_may_not_have_binding_patterns: DiagnosticMessage;
            The_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration: DiagnosticMessage;
            The_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration: DiagnosticMessage;
            _0_modifier_cannot_appear_on_an_await_using_declaration: DiagnosticMessage;
            Identifier_string_literal_or_number_literal_expected: DiagnosticMessage;
            Expression_must_be_enclosed_in_parentheses_to_be_used_as_a_decorator: DiagnosticMessage;
            Invalid_syntax_in_decorator: DiagnosticMessage;
            Unknown_regular_expression_flag: DiagnosticMessage;
            Duplicate_regular_expression_flag: DiagnosticMessage;
            This_regular_expression_flag_is_only_available_when_targeting_0_or_later: DiagnosticMessage;
            The_Unicode_u_flag_and_the_Unicode_Sets_v_flag_cannot_be_set_simultaneously: DiagnosticMessage;
            Named_capturing_groups_are_only_available_when_targeting_ES2018_or_later: DiagnosticMessage;
            Subpattern_flags_must_be_present_when_there_is_a_minus_sign: DiagnosticMessage;
            Incomplete_quantifier_Digit_expected: DiagnosticMessage;
            Numbers_out_of_order_in_quantifier: DiagnosticMessage;
            There_is_nothing_available_for_repetition: DiagnosticMessage;
            Unexpected_0_Did_you_mean_to_escape_it_with_backslash: DiagnosticMessage;
            This_regular_expression_flag_cannot_be_toggled_within_a_subpattern: DiagnosticMessage;
            k_must_be_followed_by_a_capturing_group_name_enclosed_in_angle_brackets: DiagnosticMessage;
            q_is_only_available_inside_character_class: DiagnosticMessage;
            c_must_be_followed_by_an_ASCII_letter: DiagnosticMessage;
            Undetermined_character_escape: DiagnosticMessage;
            Expected_a_capturing_group_name: DiagnosticMessage;
            Named_capturing_groups_with_the_same_name_must_be_mutually_exclusive_to_each_other: DiagnosticMessage;
            A_character_class_range_must_not_be_bounded_by_another_character_class: DiagnosticMessage;
            Range_out_of_order_in_character_class: DiagnosticMessage;
            Anything_that_would_possibly_match_more_than_a_single_character_is_invalid_inside_a_negated_character_class: DiagnosticMessage;
            Operators_must_not_be_mixed_within_a_character_class_Wrap_it_in_a_nested_class_instead: DiagnosticMessage;
            Expected_a_class_set_operand: DiagnosticMessage;
            q_must_be_followed_by_string_alternatives_enclosed_in_braces: DiagnosticMessage;
            A_character_class_must_not_contain_a_reserved_double_punctuator_Did_you_mean_to_escape_it_with_backslash: DiagnosticMessage;
            Expected_a_Unicode_property_name: DiagnosticMessage;
            Unknown_Unicode_property_name: DiagnosticMessage;
            Expected_a_Unicode_property_value: DiagnosticMessage;
            Unknown_Unicode_property_value: DiagnosticMessage;
            Expected_a_Unicode_property_name_or_value: DiagnosticMessage;
            Any_Unicode_property_that_would_possibly_match_more_than_a_single_character_is_only_available_when_the_Unicode_Sets_v_flag_is_set: DiagnosticMessage;
            Unknown_Unicode_property_name_or_value: DiagnosticMessage;
            Unicode_property_value_expressions_are_only_available_when_the_Unicode_u_flag_or_the_Unicode_Sets_v_flag_is_set: DiagnosticMessage;
            _0_must_be_followed_by_a_Unicode_property_value_expression_enclosed_in_braces: DiagnosticMessage;
            There_is_no_capturing_group_named_0_in_this_regular_expression: DiagnosticMessage;
            This_backreference_refers_to_a_group_that_does_not_exist_There_are_only_0_capturing_groups_in_this_regular_expression: DiagnosticMessage;
            This_backreference_refers_to_a_group_that_does_not_exist_There_are_no_capturing_groups_in_this_regular_expression: DiagnosticMessage;
            This_character_cannot_be_escaped_in_a_regular_expression: DiagnosticMessage;
            Octal_escape_sequences_and_backreferences_are_not_allowed_in_a_character_class_If_this_was_intended_as_an_escape_sequence_use_the_syntax_0_instead: DiagnosticMessage;
            Decimal_escape_sequences_and_backreferences_are_not_allowed_in_a_character_class: DiagnosticMessage;
            Unicode_escape_sequences_are_only_available_when_the_Unicode_u_flag_or_the_Unicode_Sets_v_flag_is_set: DiagnosticMessage;
            A_bigint_literal_cannot_be_used_as_a_property_name: DiagnosticMessage;
            A_namespace_declaration_should_not_be_declared_using_the_module_keyword_Please_use_the_namespace_keyword_instead: DiagnosticMessage;
            Type_only_import_of_an_ECMAScript_module_from_a_CommonJS_module_must_have_a_resolution_mode_attribute: DiagnosticMessage;
            Type_import_of_an_ECMAScript_module_from_a_CommonJS_module_must_have_a_resolution_mode_attribute: DiagnosticMessage;
            Importing_a_JSON_file_into_an_ECMAScript_module_requires_a_type_Colon_json_import_attribute_when_module_is_set_to_0: DiagnosticMessage;
            Named_imports_from_a_JSON_file_into_an_ECMAScript_module_are_not_allowed_when_module_is_set_to_0: DiagnosticMessage;
            The_types_of_0_are_incompatible_between_these_types: DiagnosticMessage;
            The_types_returned_by_0_are_incompatible_between_these_types: DiagnosticMessage;
            Call_signature_return_types_0_and_1_are_incompatible: DiagnosticMessage;
            Construct_signature_return_types_0_and_1_are_incompatible: DiagnosticMessage;
            Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1: DiagnosticMessage;
            Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1: DiagnosticMessage;
            The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement: DiagnosticMessage;
            The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement: DiagnosticMessage;
            This_type_parameter_might_need_an_extends_0_constraint: DiagnosticMessage;
            The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate: DiagnosticMessage;
            The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate: DiagnosticMessage;
            Add_extends_constraint: DiagnosticMessage;
            Add_extends_constraint_to_all_type_parameters: DiagnosticMessage;
            Duplicate_identifier_0: DiagnosticMessage;
            Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: DiagnosticMessage;
            Static_members_cannot_reference_class_type_parameters: DiagnosticMessage;
            Circular_definition_of_import_alias_0: DiagnosticMessage;
            Cannot_find_name_0: DiagnosticMessage;
            Module_0_has_no_exported_member_1: DiagnosticMessage;
            File_0_is_not_a_module: DiagnosticMessage;
            Cannot_find_module_0_or_its_corresponding_type_declarations: DiagnosticMessage;
            Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity: DiagnosticMessage;
            An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements: DiagnosticMessage;
            Type_0_recursively_references_itself_as_a_base_type: DiagnosticMessage;
            Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function: DiagnosticMessage;
            An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members: DiagnosticMessage;
            Type_parameter_0_has_a_circular_constraint: DiagnosticMessage;
            Generic_type_0_requires_1_type_argument_s: DiagnosticMessage;
            Type_0_is_not_generic: DiagnosticMessage;
            Global_type_0_must_be_a_class_or_interface_type: DiagnosticMessage;
            Global_type_0_must_have_1_type_parameter_s: DiagnosticMessage;
            Cannot_find_global_type_0: DiagnosticMessage;
            Named_property_0_of_types_1_and_2_are_not_identical: DiagnosticMessage;
            Interface_0_cannot_simultaneously_extend_types_1_and_2: DiagnosticMessage;
            Excessive_stack_depth_comparing_types_0_and_1: DiagnosticMessage;
            Type_0_is_not_assignable_to_type_1: DiagnosticMessage;
            Cannot_redeclare_exported_variable_0: DiagnosticMessage;
            Property_0_is_missing_in_type_1: DiagnosticMessage;
            Property_0_is_private_in_type_1_but_not_in_type_2: DiagnosticMessage;
            Types_of_property_0_are_incompatible: DiagnosticMessage;
            Property_0_is_optional_in_type_1_but_required_in_type_2: DiagnosticMessage;
            Types_of_parameters_0_and_1_are_incompatible: DiagnosticMessage;
            Index_signature_for_type_0_is_missing_in_type_1: DiagnosticMessage;
            _0_and_1_index_signatures_are_incompatible: DiagnosticMessage;
            this_cannot_be_referenced_in_a_module_or_namespace_body: DiagnosticMessage;
            this_cannot_be_referenced_in_current_location: DiagnosticMessage;
            this_cannot_be_referenced_in_a_static_property_initializer: DiagnosticMessage;
            super_can_only_be_referenced_in_a_derived_class: DiagnosticMessage;
            super_cannot_be_referenced_in_constructor_arguments: DiagnosticMessage;
            Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: DiagnosticMessage;
            super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: DiagnosticMessage;
            Property_0_does_not_exist_on_type_1: DiagnosticMessage;
            Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword: DiagnosticMessage;
            Property_0_is_private_and_only_accessible_within_class_1: DiagnosticMessage;
            This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0: DiagnosticMessage;
            Type_0_does_not_satisfy_the_constraint_1: DiagnosticMessage;
            Argument_of_type_0_is_not_assignable_to_parameter_of_type_1: DiagnosticMessage;
            Untyped_function_calls_may_not_accept_type_arguments: DiagnosticMessage;
            Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: DiagnosticMessage;
            This_expression_is_not_callable: DiagnosticMessage;
            Only_a_void_function_can_be_called_with_the_new_keyword: DiagnosticMessage;
            This_expression_is_not_constructable: DiagnosticMessage;
            Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first: DiagnosticMessage;
            Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1: DiagnosticMessage;
            This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found: DiagnosticMessage;
            A_function_whose_declared_type_is_neither_undefined_void_nor_any_must_return_a_value: DiagnosticMessage;
            An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type: DiagnosticMessage;
            The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access: DiagnosticMessage;
            The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: DiagnosticMessage;
            The_right_hand_side_of_an_instanceof_expression_must_be_either_of_type_any_a_class_function_or_other_type_assignable_to_the_Function_interface_type_or_an_object_type_with_a_Symbol_hasInstance_method: DiagnosticMessage;
            The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type: DiagnosticMessage;
            The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type: DiagnosticMessage;
            The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access: DiagnosticMessage;
            Operator_0_cannot_be_applied_to_types_1_and_2: DiagnosticMessage;
            Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined: DiagnosticMessage;
            This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap: DiagnosticMessage;
            Type_parameter_name_cannot_be_0: DiagnosticMessage;
            A_parameter_property_is_only_allowed_in_a_constructor_implementation: DiagnosticMessage;
            A_rest_parameter_must_be_of_an_array_type: DiagnosticMessage;
            A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: DiagnosticMessage;
            Parameter_0_cannot_reference_itself: DiagnosticMessage;
            Parameter_0_cannot_reference_identifier_1_declared_after_it: DiagnosticMessage;
            Duplicate_index_signature_for_type_0: DiagnosticMessage;
            Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties: DiagnosticMessage;
            A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers: DiagnosticMessage;
            Constructors_for_derived_classes_must_contain_a_super_call: DiagnosticMessage;
            A_get_accessor_must_return_a_value: DiagnosticMessage;
            Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties: DiagnosticMessage;
            Overload_signatures_must_all_be_exported_or_non_exported: DiagnosticMessage;
            Overload_signatures_must_all_be_ambient_or_non_ambient: DiagnosticMessage;
            Overload_signatures_must_all_be_public_private_or_protected: DiagnosticMessage;
            Overload_signatures_must_all_be_optional_or_required: DiagnosticMessage;
            Function_overload_must_be_static: DiagnosticMessage;
            Function_overload_must_not_be_static: DiagnosticMessage;
            Function_implementation_name_must_be_0: DiagnosticMessage;
            Constructor_implementation_is_missing: DiagnosticMessage;
            Function_implementation_is_missing_or_not_immediately_following_the_declaration: DiagnosticMessage;
            Multiple_constructor_implementations_are_not_allowed: DiagnosticMessage;
            Duplicate_function_implementation: DiagnosticMessage;
            This_overload_signature_is_not_compatible_with_its_implementation_signature: DiagnosticMessage;
            Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local: DiagnosticMessage;
            Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: DiagnosticMessage;
            Declaration_name_conflicts_with_built_in_global_identifier_0: DiagnosticMessage;
            constructor_cannot_be_used_as_a_parameter_property_name: DiagnosticMessage;
            Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: DiagnosticMessage;
            Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: DiagnosticMessage;
            A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers: DiagnosticMessage;
            Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: DiagnosticMessage;
            Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: DiagnosticMessage;
            The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation: DiagnosticMessage;
            The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any: DiagnosticMessage;
            The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access: DiagnosticMessage;
            The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0: DiagnosticMessage;
            Setters_cannot_return_a_value: DiagnosticMessage;
            Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: DiagnosticMessage;
            The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any: DiagnosticMessage;
            Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target: DiagnosticMessage;
            Property_0_of_type_1_is_not_assignable_to_2_index_type_3: DiagnosticMessage;
            _0_index_type_1_is_not_assignable_to_2_index_type_3: DiagnosticMessage;
            Class_name_cannot_be_0: DiagnosticMessage;
            Class_0_incorrectly_extends_base_class_1: DiagnosticMessage;
            Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2: DiagnosticMessage;
            Class_static_side_0_incorrectly_extends_base_class_static_side_1: DiagnosticMessage;
            Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1: DiagnosticMessage;
            Types_of_construct_signatures_are_incompatible: DiagnosticMessage;
            Class_0_incorrectly_implements_interface_1: DiagnosticMessage;
            A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members: DiagnosticMessage;
            Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: DiagnosticMessage;
            Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: DiagnosticMessage;
            Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: DiagnosticMessage;
            Interface_name_cannot_be_0: DiagnosticMessage;
            All_declarations_of_0_must_have_identical_type_parameters: DiagnosticMessage;
            Interface_0_incorrectly_extends_interface_1: DiagnosticMessage;
            Enum_name_cannot_be_0: DiagnosticMessage;
            In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element: DiagnosticMessage;
            A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged: DiagnosticMessage;
            A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged: DiagnosticMessage;
            Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces: DiagnosticMessage;
            Ambient_module_declaration_cannot_specify_relative_module_name: DiagnosticMessage;
            Module_0_is_hidden_by_a_local_declaration_with_the_same_name: DiagnosticMessage;
            Import_name_cannot_be_0: DiagnosticMessage;
            Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name: DiagnosticMessage;
            Import_declaration_conflicts_with_local_declaration_of_0: DiagnosticMessage;
            Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module: DiagnosticMessage;
            Types_have_separate_declarations_of_a_private_property_0: DiagnosticMessage;
            Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2: DiagnosticMessage;
            Property_0_is_protected_in_type_1_but_public_in_type_2: DiagnosticMessage;
            Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses: DiagnosticMessage;
            Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2: DiagnosticMessage;
            The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead: DiagnosticMessage;
            Block_scoped_variable_0_used_before_its_declaration: DiagnosticMessage;
            Class_0_used_before_its_declaration: DiagnosticMessage;
            Enum_0_used_before_its_declaration: DiagnosticMessage;
            Cannot_redeclare_block_scoped_variable_0: DiagnosticMessage;
            An_enum_member_cannot_have_a_numeric_name: DiagnosticMessage;
            Variable_0_is_used_before_being_assigned: DiagnosticMessage;
            Type_alias_0_circularly_references_itself: DiagnosticMessage;
            Type_alias_name_cannot_be_0: DiagnosticMessage;
            An_AMD_module_cannot_have_multiple_name_assignments: DiagnosticMessage;
            Module_0_declares_1_locally_but_it_is_not_exported: DiagnosticMessage;
            Module_0_declares_1_locally_but_it_is_exported_as_2: DiagnosticMessage;
            Type_0_is_not_an_array_type: DiagnosticMessage;
            A_rest_element_must_be_last_in_a_destructuring_pattern: DiagnosticMessage;
            A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature: DiagnosticMessage;
            A_computed_property_name_must_be_of_type_string_number_symbol_or_any: DiagnosticMessage;
            this_cannot_be_referenced_in_a_computed_property_name: DiagnosticMessage;
            super_cannot_be_referenced_in_a_computed_property_name: DiagnosticMessage;
            A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type: DiagnosticMessage;
            Cannot_find_global_value_0: DiagnosticMessage;
            The_0_operator_cannot_be_applied_to_type_symbol: DiagnosticMessage;
            Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher: DiagnosticMessage;
            Enum_declarations_must_all_be_const_or_non_const: DiagnosticMessage;
            const_enum_member_initializers_must_be_constant_expressions: DiagnosticMessage;
            const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query: DiagnosticMessage;
            A_const_enum_member_can_only_be_accessed_using_a_string_literal: DiagnosticMessage;
            const_enum_member_initializer_was_evaluated_to_a_non_finite_value: DiagnosticMessage;
            const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN: DiagnosticMessage;
            let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations: DiagnosticMessage;
            Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1: DiagnosticMessage;
            The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation: DiagnosticMessage;
            Export_declaration_conflicts_with_exported_declaration_of_0: DiagnosticMessage;
            The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access: DiagnosticMessage;
            Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator: DiagnosticMessage;
            An_iterator_must_have_a_next_method: DiagnosticMessage;
            The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property: DiagnosticMessage;
            The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern: DiagnosticMessage;
            Cannot_redeclare_identifier_0_in_catch_clause: DiagnosticMessage;
            Tuple_type_0_of_length_1_has_no_element_at_index_2: DiagnosticMessage;
            Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher: DiagnosticMessage;
            Type_0_is_not_an_array_type_or_a_string_type: DiagnosticMessage;
            The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES5_Consider_using_a_standard_function_expression: DiagnosticMessage;
            This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export: DiagnosticMessage;
            Module_0_uses_export_and_cannot_be_used_with_export_Asterisk: DiagnosticMessage;
            An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments: DiagnosticMessage;
            A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments: DiagnosticMessage;
            A_rest_element_cannot_contain_a_binding_pattern: DiagnosticMessage;
            _0_is_referenced_directly_or_indirectly_in_its_own_type_annotation: DiagnosticMessage;
            Cannot_find_namespace_0: DiagnosticMessage;
            Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator: DiagnosticMessage;
            A_generator_cannot_have_a_void_type_annotation: DiagnosticMessage;
            _0_is_referenced_directly_or_indirectly_in_its_own_base_expression: DiagnosticMessage;
            Type_0_is_not_a_constructor_function_type: DiagnosticMessage;
            No_base_constructor_has_the_specified_number_of_type_arguments: DiagnosticMessage;
            Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members: DiagnosticMessage;
            Base_constructors_must_all_have_the_same_return_type: DiagnosticMessage;
            Cannot_create_an_instance_of_an_abstract_class: DiagnosticMessage;
            Overload_signatures_must_all_be_abstract_or_non_abstract: DiagnosticMessage;
            Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression: DiagnosticMessage;
            A_tuple_type_cannot_be_indexed_with_a_negative_value: DiagnosticMessage;
            Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2: DiagnosticMessage;
            All_declarations_of_an_abstract_method_must_be_consecutive: DiagnosticMessage;
            Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type: DiagnosticMessage;
            A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard: DiagnosticMessage;
            An_async_iterator_must_have_a_next_method: DiagnosticMessage;
            Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions: DiagnosticMessage;
            The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES5_Consider_using_a_standard_function_or_method: DiagnosticMessage;
            yield_expressions_cannot_be_used_in_a_parameter_initializer: DiagnosticMessage;
            await_expressions_cannot_be_used_in_a_parameter_initializer: DiagnosticMessage;
            A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface: DiagnosticMessage;
            The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary: DiagnosticMessage;
            A_module_cannot_have_multiple_default_exports: DiagnosticMessage;
            Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions: DiagnosticMessage;
            Property_0_is_incompatible_with_index_signature: DiagnosticMessage;
            Object_is_possibly_null: DiagnosticMessage;
            Object_is_possibly_undefined: DiagnosticMessage;
            Object_is_possibly_null_or_undefined: DiagnosticMessage;
            A_function_returning_never_cannot_have_a_reachable_end_point: DiagnosticMessage;
            Type_0_cannot_be_used_to_index_type_1: DiagnosticMessage;
            Type_0_has_no_matching_index_signature_for_type_1: DiagnosticMessage;
            Type_0_cannot_be_used_as_an_index_type: DiagnosticMessage;
            Cannot_assign_to_0_because_it_is_not_a_variable: DiagnosticMessage;
            Cannot_assign_to_0_because_it_is_a_read_only_property: DiagnosticMessage;
            Index_signature_in_type_0_only_permits_reading: DiagnosticMessage;
            Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference: DiagnosticMessage;
            Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference: DiagnosticMessage;
            A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any: DiagnosticMessage;
            The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property: DiagnosticMessage;
            Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: DiagnosticMessage;
            Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: DiagnosticMessage;
            Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later: DiagnosticMessage;
            Property_0_does_not_exist_on_type_1_Did_you_mean_2: DiagnosticMessage;
            Cannot_find_name_0_Did_you_mean_1: DiagnosticMessage;
            Computed_values_are_not_permitted_in_an_enum_with_string_valued_members: DiagnosticMessage;
            Expected_0_arguments_but_got_1: DiagnosticMessage;
            Expected_at_least_0_arguments_but_got_1: DiagnosticMessage;
            A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter: DiagnosticMessage;
            Expected_0_type_arguments_but_got_1: DiagnosticMessage;
            Type_0_has_no_properties_in_common_with_type_1: DiagnosticMessage;
            Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it: DiagnosticMessage;
            Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2: DiagnosticMessage;
            Base_class_expressions_cannot_reference_class_type_parameters: DiagnosticMessage;
            The_containing_function_or_module_body_is_too_large_for_control_flow_analysis: DiagnosticMessage;
            Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor: DiagnosticMessage;
            Property_0_is_used_before_being_assigned: DiagnosticMessage;
            A_rest_element_cannot_have_a_property_name: DiagnosticMessage;
            Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations: DiagnosticMessage;
            Property_0_may_not_exist_on_type_1_Did_you_mean_2: DiagnosticMessage;
            Could_not_find_name_0_Did_you_mean_1: DiagnosticMessage;
            Object_is_of_type_unknown: DiagnosticMessage;
            A_rest_element_type_must_be_an_array_type: DiagnosticMessage;
            No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments: DiagnosticMessage;
            Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead: DiagnosticMessage;
            Return_type_annotation_circularly_references_itself: DiagnosticMessage;
            Unused_ts_expect_error_directive: DiagnosticMessage;
            Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode: DiagnosticMessage;
            Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery: DiagnosticMessage;
            Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha: DiagnosticMessage;
            Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later: DiagnosticMessage;
            Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom: DiagnosticMessage;
            _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later: DiagnosticMessage;
            Cannot_assign_to_0_because_it_is_a_constant: DiagnosticMessage;
            Type_instantiation_is_excessively_deep_and_possibly_infinite: DiagnosticMessage;
            Expression_produces_a_union_type_that_is_too_complex_to_represent: DiagnosticMessage;
            Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig: DiagnosticMessage;
            Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig: DiagnosticMessage;
            Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig: DiagnosticMessage;
            This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag: DiagnosticMessage;
            _0_can_only_be_imported_by_using_a_default_import: DiagnosticMessage;
            _0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: DiagnosticMessage;
            _0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import: DiagnosticMessage;
            _0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: DiagnosticMessage;
            JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist: DiagnosticMessage;
            Property_0_in_type_1_is_not_assignable_to_type_2: DiagnosticMessage;
            JSX_element_type_0_does_not_have_any_construct_or_call_signatures: DiagnosticMessage;
            Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property: DiagnosticMessage;
            JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property: DiagnosticMessage;
            The_global_type_JSX_0_may_not_have_more_than_one_property: DiagnosticMessage;
            JSX_spread_child_must_be_an_array_type: DiagnosticMessage;
            _0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property: DiagnosticMessage;
            _0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor: DiagnosticMessage;
            Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration: DiagnosticMessage;
            Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead: DiagnosticMessage;
            Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead: DiagnosticMessage;
            Type_of_property_0_circularly_references_itself_in_mapped_type_1: DiagnosticMessage;
            _0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import: DiagnosticMessage;
            _0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: DiagnosticMessage;
            Source_has_0_element_s_but_target_requires_1: DiagnosticMessage;
            Source_has_0_element_s_but_target_allows_only_1: DiagnosticMessage;
            Target_requires_0_element_s_but_source_may_have_fewer: DiagnosticMessage;
            Target_allows_only_0_element_s_but_source_may_have_more: DiagnosticMessage;
            Source_provides_no_match_for_required_element_at_position_0_in_target: DiagnosticMessage;
            Source_provides_no_match_for_variadic_element_at_position_0_in_target: DiagnosticMessage;
            Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target: DiagnosticMessage;
            Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target: DiagnosticMessage;
            Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target: DiagnosticMessage;
            Cannot_assign_to_0_because_it_is_an_enum: DiagnosticMessage;
            Cannot_assign_to_0_because_it_is_a_class: DiagnosticMessage;
            Cannot_assign_to_0_because_it_is_a_function: DiagnosticMessage;
            Cannot_assign_to_0_because_it_is_a_namespace: DiagnosticMessage;
            Cannot_assign_to_0_because_it_is_an_import: DiagnosticMessage;
            JSX_property_access_expressions_cannot_include_JSX_namespace_names: DiagnosticMessage;
            _0_index_signatures_are_incompatible: DiagnosticMessage;
            Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable: DiagnosticMessage;
            Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation: DiagnosticMessage;
            Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types: DiagnosticMessage;
            Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator: DiagnosticMessage;
            React_components_cannot_include_JSX_namespace_names: DiagnosticMessage;
            Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity: DiagnosticMessage;
            Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1_and_2_more: DiagnosticMessage;
            A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums: DiagnosticMessage;
            Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead: DiagnosticMessage;
            Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1: DiagnosticMessage;
            Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2: DiagnosticMessage;
            Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2_and_3_more: DiagnosticMessage;
            Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1: DiagnosticMessage;
            JSX_expressions_must_have_one_parent_element: DiagnosticMessage;
            Type_0_provides_no_match_for_the_signature_1: DiagnosticMessage;
            super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher: DiagnosticMessage;
            super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions: DiagnosticMessage;
            Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module: DiagnosticMessage;
            Cannot_find_name_0_Did_you_mean_the_static_member_1_0: DiagnosticMessage;
            Cannot_find_name_0_Did_you_mean_the_instance_member_this_0: DiagnosticMessage;
            Invalid_module_name_in_augmentation_module_0_cannot_be_found: DiagnosticMessage;
            Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented: DiagnosticMessage;
            Exports_and_export_assignments_are_not_permitted_in_module_augmentations: DiagnosticMessage;
            Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module: DiagnosticMessage;
            export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible: DiagnosticMessage;
            Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations: DiagnosticMessage;
            Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context: DiagnosticMessage;
            Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity: DiagnosticMessage;
            Cannot_assign_a_0_constructor_type_to_a_1_constructor_type: DiagnosticMessage;
            Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration: DiagnosticMessage;
            Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration: DiagnosticMessage;
            Cannot_extend_a_class_0_Class_constructor_is_marked_as_private: DiagnosticMessage;
            Accessors_must_both_be_abstract_or_non_abstract: DiagnosticMessage;
            A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type: DiagnosticMessage;
            Type_0_is_not_comparable_to_type_1: DiagnosticMessage;
            A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void: DiagnosticMessage;
            A_0_parameter_must_be_the_first_parameter: DiagnosticMessage;
            A_constructor_cannot_have_a_this_parameter: DiagnosticMessage;
            this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation: DiagnosticMessage;
            The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1: DiagnosticMessage;
            The_this_types_of_each_signature_are_incompatible: DiagnosticMessage;
            _0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead: DiagnosticMessage;
            All_declarations_of_0_must_have_identical_modifiers: DiagnosticMessage;
            Cannot_find_type_definition_file_for_0: DiagnosticMessage;
            Cannot_extend_an_interface_0_Did_you_mean_implements: DiagnosticMessage;
            _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0: DiagnosticMessage;
            _0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible: DiagnosticMessage;
            _0_only_refers_to_a_type_but_is_being_used_as_a_value_here: DiagnosticMessage;
            Namespace_0_has_no_exported_member_1: DiagnosticMessage;
            Left_side_of_comma_operator_is_unused_and_has_no_side_effects: DiagnosticMessage;
            The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead: DiagnosticMessage;
            An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: DiagnosticMessage;
            Spread_types_may_only_be_created_from_object_types: DiagnosticMessage;
            Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1: DiagnosticMessage;
            Rest_types_may_only_be_created_from_object_types: DiagnosticMessage;
            The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access: DiagnosticMessage;
            _0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here: DiagnosticMessage;
            The_operand_of_a_delete_operator_must_be_a_property_reference: DiagnosticMessage;
            The_operand_of_a_delete_operator_cannot_be_a_read_only_property: DiagnosticMessage;
            An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: DiagnosticMessage;
            Required_type_parameters_may_not_follow_optional_type_parameters: DiagnosticMessage;
            Generic_type_0_requires_between_1_and_2_type_arguments: DiagnosticMessage;
            Cannot_use_namespace_0_as_a_value: DiagnosticMessage;
            Cannot_use_namespace_0_as_a_type: DiagnosticMessage;
            _0_are_specified_twice_The_attribute_named_0_will_be_overwritten: DiagnosticMessage;
            A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: DiagnosticMessage;
            A_dynamic_import_call_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: DiagnosticMessage;
            Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1: DiagnosticMessage;
            The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context: DiagnosticMessage;
            Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor: DiagnosticMessage;
            Type_parameter_0_has_a_circular_default: DiagnosticMessage;
            Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2: DiagnosticMessage;
            Duplicate_property_0: DiagnosticMessage;
            Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated: DiagnosticMessage;
            Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass: DiagnosticMessage;
            Cannot_invoke_an_object_which_is_possibly_null: DiagnosticMessage;
            Cannot_invoke_an_object_which_is_possibly_undefined: DiagnosticMessage;
            Cannot_invoke_an_object_which_is_possibly_null_or_undefined: DiagnosticMessage;
            _0_has_no_exported_member_named_1_Did_you_mean_2: DiagnosticMessage;
            Class_name_cannot_be_Object_when_targeting_ES5_with_module_0: DiagnosticMessage;
            Cannot_find_lib_definition_for_0: DiagnosticMessage;
            Cannot_find_lib_definition_for_0_Did_you_mean_1: DiagnosticMessage;
            _0_is_declared_here: DiagnosticMessage;
            Property_0_is_used_before_its_initialization: DiagnosticMessage;
            An_arrow_function_cannot_have_a_this_parameter: DiagnosticMessage;
            Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String: DiagnosticMessage;
            Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension: DiagnosticMessage;
            Property_0_was_also_declared_here: DiagnosticMessage;
            Are_you_missing_a_semicolon: DiagnosticMessage;
            Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1: DiagnosticMessage;
            Operator_0_cannot_be_applied_to_type_1: DiagnosticMessage;
            BigInt_literals_are_not_available_when_targeting_lower_than_ES2020: DiagnosticMessage;
            An_outer_value_of_this_is_shadowed_by_this_container: DiagnosticMessage;
            Type_0_is_missing_the_following_properties_from_type_1_Colon_2: DiagnosticMessage;
            Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more: DiagnosticMessage;
            Property_0_is_missing_in_type_1_but_required_in_type_2: DiagnosticMessage;
            The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_annotation_is_necessary: DiagnosticMessage;
            No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments: DiagnosticMessage;
            Type_parameter_defaults_can_only_reference_previously_declared_type_parameters: DiagnosticMessage;
            This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided: DiagnosticMessage;
            This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided: DiagnosticMessage;
            _0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2: DiagnosticMessage;
            Cannot_access_ambient_const_enums_when_0_is_enabled: DiagnosticMessage;
            _0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0: DiagnosticMessage;
            The_implementation_signature_is_declared_here: DiagnosticMessage;
            Circularity_originates_in_type_at_this_location: DiagnosticMessage;
            The_first_export_default_is_here: DiagnosticMessage;
            Another_export_default_is_here: DiagnosticMessage;
            super_may_not_use_type_arguments: DiagnosticMessage;
            No_constituent_of_type_0_is_callable: DiagnosticMessage;
            Not_all_constituents_of_type_0_are_callable: DiagnosticMessage;
            Type_0_has_no_call_signatures: DiagnosticMessage;
            Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other: DiagnosticMessage;
            No_constituent_of_type_0_is_constructable: DiagnosticMessage;
            Not_all_constituents_of_type_0_are_constructable: DiagnosticMessage;
            Type_0_has_no_construct_signatures: DiagnosticMessage;
            Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other: DiagnosticMessage;
            Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0: DiagnosticMessage;
            Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0: DiagnosticMessage;
            Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0: DiagnosticMessage;
            Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0: DiagnosticMessage;
            The_0_property_of_an_iterator_must_be_a_method: DiagnosticMessage;
            The_0_property_of_an_async_iterator_must_be_a_method: DiagnosticMessage;
            No_overload_matches_this_call: DiagnosticMessage;
            The_last_overload_gave_the_following_error: DiagnosticMessage;
            The_last_overload_is_declared_here: DiagnosticMessage;
            Overload_0_of_1_2_gave_the_following_error: DiagnosticMessage;
            Did_you_forget_to_use_await: DiagnosticMessage;
            This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead: DiagnosticMessage;
            Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation: DiagnosticMessage;
            Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name: DiagnosticMessage;
            The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access: DiagnosticMessage;
            The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access: DiagnosticMessage;
            The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access: DiagnosticMessage;
            The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access: DiagnosticMessage;
            The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access: DiagnosticMessage;
            _0_needs_an_explicit_type_annotation: DiagnosticMessage;
            _0_is_specified_more_than_once_so_this_usage_will_be_overwritten: DiagnosticMessage;
            get_and_set_accessors_cannot_declare_this_parameters: DiagnosticMessage;
            This_spread_always_overwrites_this_property: DiagnosticMessage;
            _0_cannot_be_used_as_a_JSX_component: DiagnosticMessage;
            Its_return_type_0_is_not_a_valid_JSX_element: DiagnosticMessage;
            Its_instance_type_0_is_not_a_valid_JSX_element: DiagnosticMessage;
            Its_element_type_0_is_not_a_valid_JSX_element: DiagnosticMessage;
            The_operand_of_a_delete_operator_must_be_optional: DiagnosticMessage;
            Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later: DiagnosticMessage;
            Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option: DiagnosticMessage;
            The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible: DiagnosticMessage;
            Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise: DiagnosticMessage;
            The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types: DiagnosticMessage;
            It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked: DiagnosticMessage;
            A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract: DiagnosticMessage;
            The_declaration_was_marked_as_deprecated_here: DiagnosticMessage;
            Type_produces_a_tuple_type_that_is_too_large_to_represent: DiagnosticMessage;
            Expression_produces_a_tuple_type_that_is_too_large_to_represent: DiagnosticMessage;
            This_condition_will_always_return_true_since_this_0_is_always_defined: DiagnosticMessage;
            Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher: DiagnosticMessage;
            Cannot_assign_to_private_method_0_Private_methods_are_not_writable: DiagnosticMessage;
            Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name: DiagnosticMessage;
            Private_accessor_was_defined_without_a_getter: DiagnosticMessage;
            This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0: DiagnosticMessage;
            A_get_accessor_must_be_at_least_as_accessible_as_the_setter: DiagnosticMessage;
            Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_whole_assignment_in_parentheses: DiagnosticMessage;
            Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments: DiagnosticMessage;
            Initializer_for_property_0: DiagnosticMessage;
            Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom: DiagnosticMessage;
            Class_declaration_cannot_implement_overload_list_for_0: DiagnosticMessage;
            Function_with_bodies_can_only_merge_with_classes_that_are_ambient: DiagnosticMessage;
            arguments_cannot_be_referenced_in_property_initializers_or_class_static_initialization_blocks: DiagnosticMessage;
            Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class: DiagnosticMessage;
            Property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block: DiagnosticMessage;
            Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers: DiagnosticMessage;
            Namespace_name_cannot_be_0: DiagnosticMessage;
            Type_0_is_not_assignable_to_type_1_Did_you_mean_2: DiagnosticMessage;
            Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_node18_nodenext_or_preserve: DiagnosticMessage;
            Import_assertions_cannot_be_used_with_type_only_imports_or_exports: DiagnosticMessage;
            Import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_node18_nodenext_or_preserve: DiagnosticMessage;
            Cannot_find_namespace_0_Did_you_mean_1: DiagnosticMessage;
            Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path: DiagnosticMessage;
            Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0: DiagnosticMessage;
            Import_assertions_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls: DiagnosticMessage;
            Import_assertion_values_must_be_string_literal_expressions: DiagnosticMessage;
            All_declarations_of_0_must_have_identical_constraints: DiagnosticMessage;
            This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value: DiagnosticMessage;
            An_interface_cannot_extend_a_primitive_type_like_0_It_can_only_extend_other_named_object_types: DiagnosticMessage;
            _0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation: DiagnosticMessage;
            We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here: DiagnosticMessage;
            Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: DiagnosticMessage;
            This_condition_will_always_return_0: DiagnosticMessage;
            A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_file_0_instead: DiagnosticMessage;
            The_right_hand_side_of_an_instanceof_expression_must_not_be_an_instantiation_expression: DiagnosticMessage;
            Target_signature_provides_too_few_arguments_Expected_0_or_more_but_got_1: DiagnosticMessage;
            The_initializer_of_a_using_declaration_must_be_either_an_object_with_a_Symbol_dispose_method_or_be_null_or_undefined: DiagnosticMessage;
            The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_Symbol_dispose_method_or_be_null_or_undefined: DiagnosticMessage;
            await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules: DiagnosticMessage;
            await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module: DiagnosticMessage;
            Top_level_await_using_statements_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_node18_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher: DiagnosticMessage;
            Class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super: DiagnosticMessage;
            Import_attributes_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls: DiagnosticMessage;
            Import_attributes_cannot_be_used_with_type_only_imports_or_exports: DiagnosticMessage;
            Import_attribute_values_must_be_string_literal_expressions: DiagnosticMessage;
            Excessive_complexity_comparing_types_0_and_1: DiagnosticMessage;
            The_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_hand_side_s_Symbol_hasInstance_method: DiagnosticMessage;
            An_object_s_Symbol_hasInstance_method_must_return_a_boolean_value_for_it_to_be_used_on_the_right_hand_side_of_an_instanceof_expression: DiagnosticMessage;
            Type_0_is_generic_and_can_only_be_indexed_for_reading: DiagnosticMessage;
            A_class_cannot_extend_a_primitive_type_like_0_Classes_can_only_extend_constructable_values: DiagnosticMessage;
            A_class_cannot_implement_a_primitive_type_like_0_It_can_only_implement_other_named_object_types: DiagnosticMessage;
            Import_0_conflicts_with_local_value_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled: DiagnosticMessage;
            Import_0_conflicts_with_global_value_used_in_this_file_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled: DiagnosticMessage;
            Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun: DiagnosticMessage;
            Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun_and_then_add_bun_to_the_types_field_in_your_tsconfig: DiagnosticMessage;
            Right_operand_of_is_unreachable_because_the_left_operand_is_never_nullish: DiagnosticMessage;
            This_binary_expression_is_never_nullish_Are_you_missing_parentheses: DiagnosticMessage;
            This_expression_is_always_nullish: DiagnosticMessage;
            This_kind_of_expression_is_always_truthy: DiagnosticMessage;
            This_kind_of_expression_is_always_falsy: DiagnosticMessage;
            This_JSX_tag_requires_0_to_be_in_scope_but_it_could_not_be_found: DiagnosticMessage;
            This_JSX_tag_requires_the_module_path_0_to_exist_but_none_could_be_found_Make_sure_you_have_types_for_the_appropriate_package_installed: DiagnosticMessage;
            This_relative_import_path_is_unsafe_to_rewrite_because_it_looks_like_a_file_name_but_actually_resolves_to_0: DiagnosticMessage;
            This_import_uses_a_0_extension_to_resolve_to_an_input_TypeScript_file_but_will_not_be_rewritten_during_emit_because_it_is_not_a_relative_path: DiagnosticMessage;
            This_import_path_is_unsafe_to_rewrite_because_it_resolves_to_another_project_and_the_relative_path_between_the_projects_output_files_is_not_the_same_as_the_relative_path_between_its_input_files: DiagnosticMessage;
            Using_JSX_fragments_requires_fragment_factory_0_to_be_in_scope_but_it_could_not_be_found: DiagnosticMessage;
            Import_assertions_have_been_replaced_by_import_attributes_Use_with_instead_of_assert: DiagnosticMessage;
            This_expression_is_never_nullish: DiagnosticMessage;
            Import_declaration_0_is_using_private_name_1: DiagnosticMessage;
            Type_parameter_0_of_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
            Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
            Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
            Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
            Type_parameter_0_of_exported_function_has_or_is_using_private_name_1: DiagnosticMessage;
            Implements_clause_of_exported_class_0_has_or_is_using_private_name_1: DiagnosticMessage;
            extends_clause_of_exported_class_0_has_or_is_using_private_name_1: DiagnosticMessage;
            extends_clause_of_exported_class_has_or_is_using_private_name_0: DiagnosticMessage;
            extends_clause_of_exported_interface_0_has_or_is_using_private_name_1: DiagnosticMessage;
            Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
            Exported_variable_0_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Exported_variable_0_has_or_is_using_private_name_1: DiagnosticMessage;
            Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
            Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Public_static_property_0_of_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
            Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Public_property_0_of_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Property_0_of_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
            Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
            Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
            Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
            Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0: DiagnosticMessage;
            Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
            Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0: DiagnosticMessage;
            Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
            Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0: DiagnosticMessage;
            Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: DiagnosticMessage;
            Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
            Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0: DiagnosticMessage;
            Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: DiagnosticMessage;
            Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
            Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0: DiagnosticMessage;
            Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
            Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0: DiagnosticMessage;
            Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: DiagnosticMessage;
            Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
            Return_type_of_exported_function_has_or_is_using_private_name_0: DiagnosticMessage;
            Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
            Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
            Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
            Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
            Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
            Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
            Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
            Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Parameter_0_of_exported_function_has_or_is_using_private_name_1: DiagnosticMessage;
            Exported_type_alias_0_has_or_is_using_private_name_1: DiagnosticMessage;
            Default_export_of_the_module_has_or_is_using_private_name_0: DiagnosticMessage;
            Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1: DiagnosticMessage;
            Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2: DiagnosticMessage;
            Extends_clause_for_inferred_type_0_has_or_is_using_private_name_1: DiagnosticMessage;
            Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
            Property_0_of_exported_anonymous_class_type_may_not_be_private_or_protected: DiagnosticMessage;
            Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
            Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Public_static_method_0_of_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
            Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Public_method_0_of_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
            Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Method_0_of_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
            Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1: DiagnosticMessage;
            The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1: DiagnosticMessage;
            Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter: DiagnosticMessage;
            Parameter_0_of_accessor_has_or_is_using_private_name_1: DiagnosticMessage;
            Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
            Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
            Type_arguments_for_0_circularly_reference_themselves: DiagnosticMessage;
            Tuple_type_arguments_circularly_reference_themselves: DiagnosticMessage;
            Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0: DiagnosticMessage;
            This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class: DiagnosticMessage;
            This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0: DiagnosticMessage;
            This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0: DiagnosticMessage;
            This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0: DiagnosticMessage;
            This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0: DiagnosticMessage;
            This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1: DiagnosticMessage;
            The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized: DiagnosticMessage;
            This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0: DiagnosticMessage;
            This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0: DiagnosticMessage;
            This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class: DiagnosticMessage;
            This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0: DiagnosticMessage;
            This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1: DiagnosticMessage;
            Compiler_option_0_of_value_1_is_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: DiagnosticMessage;
            Each_declaration_of_0_1_differs_in_its_value_where_2_was_expected_but_3_was_given: DiagnosticMessage;
            One_value_of_0_1_is_the_string_2_and_the_other_is_assumed_to_be_an_unknown_numeric_value: DiagnosticMessage;
            This_member_cannot_have_an_override_modifier_because_its_name_is_dynamic: DiagnosticMessage;
            This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_name_is_dynamic: DiagnosticMessage;
            The_current_host_does_not_support_the_0_option: DiagnosticMessage;
            Cannot_find_the_common_subdirectory_path_for_the_input_files: DiagnosticMessage;
            File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: DiagnosticMessage;
            Cannot_read_file_0_Colon_1: DiagnosticMessage;
            Unknown_compiler_option_0: DiagnosticMessage;
            Compiler_option_0_requires_a_value_of_type_1: DiagnosticMessage;
            Unknown_compiler_option_0_Did_you_mean_1: DiagnosticMessage;
            Could_not_write_file_0_Colon_1: DiagnosticMessage;
            Option_project_cannot_be_mixed_with_source_files_on_a_command_line: DiagnosticMessage;
            Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES2015_or_higher: DiagnosticMessage;
            Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided: DiagnosticMessage;
            Option_0_cannot_be_specified_without_specifying_option_1: DiagnosticMessage;
            Option_0_cannot_be_specified_with_option_1: DiagnosticMessage;
            A_tsconfig_json_file_is_already_defined_at_Colon_0: DiagnosticMessage;
            Cannot_write_file_0_because_it_would_overwrite_input_file: DiagnosticMessage;
            Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files: DiagnosticMessage;
            Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0: DiagnosticMessage;
            The_specified_path_does_not_exist_Colon_0: DiagnosticMessage;
            Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier: DiagnosticMessage;
            Pattern_0_can_have_at_most_one_Asterisk_character: DiagnosticMessage;
            Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character: DiagnosticMessage;
            Substitutions_for_pattern_0_should_be_an_array: DiagnosticMessage;
            Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2: DiagnosticMessage;
            File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: DiagnosticMessage;
            Substitutions_for_pattern_0_shouldn_t_be_an_empty_array: DiagnosticMessage;
            Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name: DiagnosticMessage;
            Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript_files_Learn_more_at_https_Colon_Slash_Slashaka_ms_Slashtsconfig: DiagnosticMessage;
            Option_0_cannot_be_specified_without_specifying_option_1_or_option_2: DiagnosticMessage;
            Option_resolveJsonModule_cannot_be_specified_when_moduleResolution_is_set_to_classic: DiagnosticMessage;
            Option_resolveJsonModule_cannot_be_specified_when_module_is_set_to_none_system_or_umd: DiagnosticMessage;
            Unknown_build_option_0: DiagnosticMessage;
            Build_option_0_requires_a_value_of_type_1: DiagnosticMessage;
            Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBuildInfoFile_is_specified: DiagnosticMessage;
            _0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2: DiagnosticMessage;
            _0_and_1_operations_cannot_be_mixed_without_parentheses: DiagnosticMessage;
            Unknown_build_option_0_Did_you_mean_1: DiagnosticMessage;
            Unknown_watch_option_0: DiagnosticMessage;
            Unknown_watch_option_0_Did_you_mean_1: DiagnosticMessage;
            Watch_option_0_requires_a_value_of_type_1: DiagnosticMessage;
            Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0: DiagnosticMessage;
            _0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1: DiagnosticMessage;
            Cannot_read_file_0: DiagnosticMessage;
            A_tuple_member_cannot_be_both_optional_and_rest: DiagnosticMessage;
            A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type: DiagnosticMessage;
            A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type: DiagnosticMessage;
            The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialized_A_type_annotation_is_necessary: DiagnosticMessage;
            Option_0_cannot_be_specified_when_option_jsx_is_1: DiagnosticMessage;
            Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash: DiagnosticMessage;
            Option_preserveConstEnums_cannot_be_disabled_when_0_is_enabled: DiagnosticMessage;
            The_root_value_of_a_0_file_must_be_an_object: DiagnosticMessage;
            Compiler_option_0_may_only_be_used_with_build: DiagnosticMessage;
            Compiler_option_0_may_not_be_used_with_build: DiagnosticMessage;
            Option_0_can_only_be_used_when_module_is_set_to_preserve_or_to_es2015_or_later: DiagnosticMessage;
            Option_allowImportingTsExtensions_can_only_be_used_when_either_noEmit_or_emitDeclarationOnly_is_set: DiagnosticMessage;
            An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled: DiagnosticMessage;
            Option_0_can_only_be_used_when_moduleResolution_is_set_to_node16_nodenext_or_bundler: DiagnosticMessage;
            Option_0_is_deprecated_and_will_stop_functioning_in_TypeScript_1_Specify_compilerOption_ignoreDeprecations_Colon_2_to_silence_this_error: DiagnosticMessage;
            Option_0_has_been_removed_Please_remove_it_from_your_configuration: DiagnosticMessage;
            Invalid_value_for_ignoreDeprecations: DiagnosticMessage;
            Option_0_is_redundant_and_cannot_be_specified_with_option_1: DiagnosticMessage;
            Option_verbatimModuleSyntax_cannot_be_used_when_module_is_set_to_UMD_AMD_or_System: DiagnosticMessage;
            Use_0_instead: DiagnosticMessage;
            Option_0_1_is_deprecated_and_will_stop_functioning_in_TypeScript_2_Specify_compilerOption_ignoreDeprecations_Colon_3_to_silence_this_error: DiagnosticMessage;
            Option_0_1_has_been_removed_Please_remove_it_from_your_configuration: DiagnosticMessage;
            Option_moduleResolution_must_be_set_to_0_or_left_unspecified_when_option_module_is_set_to_1: DiagnosticMessage;
            Option_module_must_be_set_to_0_when_option_moduleResolution_is_set_to_1: DiagnosticMessage;
            Generates_a_sourcemap_for_each_corresponding_d_ts_file: DiagnosticMessage;
            Concatenate_and_emit_output_to_single_file: DiagnosticMessage;
            Generates_corresponding_d_ts_file: DiagnosticMessage;
            Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: DiagnosticMessage;
            Watch_input_files: DiagnosticMessage;
            Redirect_output_structure_to_the_directory: DiagnosticMessage;
            Do_not_erase_const_enum_declarations_in_generated_code: DiagnosticMessage;
            Do_not_emit_outputs_if_any_errors_were_reported: DiagnosticMessage;
            Do_not_emit_comments_to_output: DiagnosticMessage;
            Do_not_emit_outputs: DiagnosticMessage;
            Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typechecking: DiagnosticMessage;
            Skip_type_checking_of_declaration_files: DiagnosticMessage;
            Do_not_resolve_the_real_path_of_symlinks: DiagnosticMessage;
            Only_emit_d_ts_declaration_files: DiagnosticMessage;
            Specify_ECMAScript_target_version: DiagnosticMessage;
            Specify_module_code_generation: DiagnosticMessage;
            Print_this_message: DiagnosticMessage;
            Print_the_compiler_s_version: DiagnosticMessage;
            Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json: DiagnosticMessage;
            Syntax_Colon_0: DiagnosticMessage;
            options: DiagnosticMessage;
            file: DiagnosticMessage;
            Examples_Colon_0: DiagnosticMessage;
            Options_Colon: DiagnosticMessage;
            Version_0: DiagnosticMessage;
            Insert_command_line_options_and_files_from_a_file: DiagnosticMessage;
            Starting_compilation_in_watch_mode: DiagnosticMessage;
            File_change_detected_Starting_incremental_compilation: DiagnosticMessage;
            KIND: DiagnosticMessage;
            FILE: DiagnosticMessage;
            VERSION: DiagnosticMessage;
            LOCATION: DiagnosticMessage;
            DIRECTORY: DiagnosticMessage;
            STRATEGY: DiagnosticMessage;
            FILE_OR_DIRECTORY: DiagnosticMessage;
            Errors_Files: DiagnosticMessage;
            Generates_corresponding_map_file: DiagnosticMessage;
            Compiler_option_0_expects_an_argument: DiagnosticMessage;
            Unterminated_quoted_string_in_response_file_0: DiagnosticMessage;
            Argument_for_0_option_must_be_Colon_1: DiagnosticMessage;
            Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: DiagnosticMessage;
            Unable_to_open_file_0: DiagnosticMessage;
            Corrupted_locale_file_0: DiagnosticMessage;
            Raise_error_on_expressions_and_declarations_with_an_implied_any_type: DiagnosticMessage;
            File_0_not_found: DiagnosticMessage;
            File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1: DiagnosticMessage;
            Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures: DiagnosticMessage;
            Do_not_emit_declarations_for_code_that_has_an_internal_annotation: DiagnosticMessage;
            Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir: DiagnosticMessage;
            File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files: DiagnosticMessage;
            Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix: DiagnosticMessage;
            NEWLINE: DiagnosticMessage;
            Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line: DiagnosticMessage;
            Enables_experimental_support_for_ES7_decorators: DiagnosticMessage;
            Enables_experimental_support_for_emitting_type_metadata_for_decorators: DiagnosticMessage;
            Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file: DiagnosticMessage;
            Successfully_created_a_tsconfig_json_file: DiagnosticMessage;
            Suppress_excess_property_checks_for_object_literals: DiagnosticMessage;
            Stylize_errors_and_messages_using_color_and_context_experimental: DiagnosticMessage;
            Do_not_report_errors_on_unused_labels: DiagnosticMessage;
            Report_error_when_not_all_code_paths_in_function_return_a_value: DiagnosticMessage;
            Report_errors_for_fallthrough_cases_in_switch_statement: DiagnosticMessage;
            Do_not_report_errors_on_unreachable_code: DiagnosticMessage;
            Disallow_inconsistently_cased_references_to_the_same_file: DiagnosticMessage;
            Specify_library_files_to_be_included_in_the_compilation: DiagnosticMessage;
            Specify_JSX_code_generation: DiagnosticMessage;
            Only_amd_and_system_modules_are_supported_alongside_0: DiagnosticMessage;
            Base_directory_to_resolve_non_absolute_module_names: DiagnosticMessage;
            Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react_JSX_emit: DiagnosticMessage;
            Enable_tracing_of_the_name_resolution_process: DiagnosticMessage;
            Resolving_module_0_from_1: DiagnosticMessage;
            Explicitly_specified_module_resolution_kind_Colon_0: DiagnosticMessage;
            Module_resolution_kind_is_not_specified_using_0: DiagnosticMessage;
            Module_name_0_was_successfully_resolved_to_1: DiagnosticMessage;
            Module_name_0_was_not_resolved: DiagnosticMessage;
            paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0: DiagnosticMessage;
            Module_name_0_matched_pattern_1: DiagnosticMessage;
            Trying_substitution_0_candidate_module_location_Colon_1: DiagnosticMessage;
            Resolving_module_name_0_relative_to_base_url_1_2: DiagnosticMessage;
            Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_types_Colon_1: DiagnosticMessage;
            File_0_does_not_exist: DiagnosticMessage;
            File_0_exists_use_it_as_a_name_resolution_result: DiagnosticMessage;
            Loading_module_0_from_node_modules_folder_target_file_types_Colon_1: DiagnosticMessage;
            Found_package_json_at_0: DiagnosticMessage;
            package_json_does_not_have_a_0_field: DiagnosticMessage;
            package_json_has_0_field_1_that_references_2: DiagnosticMessage;
            Allow_javascript_files_to_be_compiled: DiagnosticMessage;
            Checking_if_0_is_the_longest_matching_prefix_for_1_2: DiagnosticMessage;
            Expected_type_of_0_field_in_package_json_to_be_1_got_2: DiagnosticMessage;
            baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1: DiagnosticMessage;
            rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0: DiagnosticMessage;
            Longest_matching_prefix_for_0_is_1: DiagnosticMessage;
            Loading_0_from_the_root_dir_1_candidate_location_2: DiagnosticMessage;
            Trying_other_entries_in_rootDirs: DiagnosticMessage;
            Module_resolution_using_rootDirs_has_failed: DiagnosticMessage;
            Do_not_emit_use_strict_directives_in_module_output: DiagnosticMessage;
            Enable_strict_null_checks: DiagnosticMessage;
            Unknown_option_excludes_Did_you_mean_exclude: DiagnosticMessage;
            Raise_error_on_this_expressions_with_an_implied_any_type: DiagnosticMessage;
            Resolving_type_reference_directive_0_containing_file_1_root_directory_2: DiagnosticMessage;
            Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2: DiagnosticMessage;
            Type_reference_directive_0_was_not_resolved: DiagnosticMessage;
            Resolving_with_primary_search_path_0: DiagnosticMessage;
            Root_directory_cannot_be_determined_skipping_primary_search_paths: DiagnosticMessage;
            Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set: DiagnosticMessage;
            Type_declaration_files_to_be_included_in_compilation: DiagnosticMessage;
            Looking_up_in_node_modules_folder_initial_location_0: DiagnosticMessage;
            Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder: DiagnosticMessage;
            Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1: DiagnosticMessage;
            Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set: DiagnosticMessage;
            Resolving_real_path_for_0_result_1: DiagnosticMessage;
            Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system: DiagnosticMessage;
            File_name_0_has_a_1_extension_stripping_it: DiagnosticMessage;
            _0_is_declared_but_its_value_is_never_read: DiagnosticMessage;
            Report_errors_on_unused_locals: DiagnosticMessage;
            Report_errors_on_unused_parameters: DiagnosticMessage;
            The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files: DiagnosticMessage;
            Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1: DiagnosticMessage;
            Property_0_is_declared_but_its_value_is_never_read: DiagnosticMessage;
            Import_emit_helpers_from_tslib: DiagnosticMessage;
            Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2: DiagnosticMessage;
            Parse_in_strict_mode_and_emit_use_strict_for_each_source_file: DiagnosticMessage;
            Module_0_was_resolved_to_1_but_jsx_is_not_set: DiagnosticMessage;
            Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1: DiagnosticMessage;
            Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h: DiagnosticMessage;
            Resolution_for_module_0_was_found_in_cache_from_location_1: DiagnosticMessage;
            Directory_0_does_not_exist_skipping_all_lookups_in_it: DiagnosticMessage;
            Show_diagnostic_information: DiagnosticMessage;
            Show_verbose_diagnostic_information: DiagnosticMessage;
            Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file: DiagnosticMessage;
            Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap_to_be_set: DiagnosticMessage;
            Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule: DiagnosticMessage;
            Print_names_of_generated_files_part_of_the_compilation: DiagnosticMessage;
            Print_names_of_files_part_of_the_compilation: DiagnosticMessage;
            The_locale_used_when_displaying_messages_to_the_user_e_g_en_us: DiagnosticMessage;
            Do_not_generate_custom_helper_functions_like_extends_in_compiled_output: DiagnosticMessage;
            Do_not_include_the_default_library_file_lib_d_ts: DiagnosticMessage;
            Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files: DiagnosticMessage;
            Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files: DiagnosticMessage;
            List_of_folders_to_include_type_definitions_from: DiagnosticMessage;
            Disable_size_limitations_on_JavaScript_projects: DiagnosticMessage;
            The_character_set_of_the_input_files: DiagnosticMessage;
            Skipping_module_0_that_looks_like_an_absolute_URI_target_file_types_Colon_1: DiagnosticMessage;
            Do_not_truncate_error_messages: DiagnosticMessage;
            Output_directory_for_generated_declaration_files: DiagnosticMessage;
            A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl: DiagnosticMessage;
            List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime: DiagnosticMessage;
            Show_all_compiler_options: DiagnosticMessage;
            Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file: DiagnosticMessage;
            Command_line_Options: DiagnosticMessage;
            Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5: DiagnosticMessage;
            Enable_all_strict_type_checking_options: DiagnosticMessage;
            Scoped_package_detected_looking_in_0: DiagnosticMessage;
            Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2: DiagnosticMessage;
            Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3: DiagnosticMessage;
            Enable_strict_checking_of_function_types: DiagnosticMessage;
            Enable_strict_checking_of_property_initialization_in_classes: DiagnosticMessage;
            Numeric_separators_are_not_allowed_here: DiagnosticMessage;
            Multiple_consecutive_numeric_separators_are_not_permitted: DiagnosticMessage;
            Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen: DiagnosticMessage;
            All_imports_in_import_declaration_are_unused: DiagnosticMessage;
            Found_1_error_Watching_for_file_changes: DiagnosticMessage;
            Found_0_errors_Watching_for_file_changes: DiagnosticMessage;
            Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols: DiagnosticMessage;
            _0_is_declared_but_never_used: DiagnosticMessage;
            Include_modules_imported_with_json_extension: DiagnosticMessage;
            All_destructured_elements_are_unused: DiagnosticMessage;
            All_variables_are_unused: DiagnosticMessage;
            Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0: DiagnosticMessage;
            Conflicts_are_in_this_file: DiagnosticMessage;
            Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0: DiagnosticMessage;
            _0_was_also_declared_here: DiagnosticMessage;
            and_here: DiagnosticMessage;
            All_type_parameters_are_unused: DiagnosticMessage;
            package_json_has_a_typesVersions_field_with_version_specific_path_mappings: DiagnosticMessage;
            package_json_does_not_have_a_typesVersions_entry_that_matches_version_0: DiagnosticMessage;
            package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2: DiagnosticMessage;
            package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range: DiagnosticMessage;
            An_argument_for_0_was_not_provided: DiagnosticMessage;
            An_argument_matching_this_binding_pattern_was_not_provided: DiagnosticMessage;
            Did_you_mean_to_call_this_expression: DiagnosticMessage;
            Did_you_mean_to_use_new_with_this_expression: DiagnosticMessage;
            Enable_strict_bind_call_and_apply_methods_on_functions: DiagnosticMessage;
            Using_compiler_options_of_project_reference_redirect_0: DiagnosticMessage;
            Found_1_error: DiagnosticMessage;
            Found_0_errors: DiagnosticMessage;
            Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2: DiagnosticMessage;
            Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3: DiagnosticMessage;
            package_json_had_a_falsy_0_field: DiagnosticMessage;
            Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects: DiagnosticMessage;
            Emit_class_fields_with_Define_instead_of_Set: DiagnosticMessage;
            Generates_a_CPU_profile: DiagnosticMessage;
            Disable_solution_searching_for_this_project: DiagnosticMessage;
            Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling_UseFsEvents_UseFsEventsOnParentDirectory: DiagnosticMessage;
            Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively_Colon_UseFsEvents_default_FixedPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling: DiagnosticMessage;
            Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_FixedInterval_default_PriorityInterval_DynamicPriority_FixedChunkSize: DiagnosticMessage;
            Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3: DiagnosticMessage;
            Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line: DiagnosticMessage;
            Could_not_resolve_the_path_0_with_the_extensions_Colon_1: DiagnosticMessage;
            Declaration_augments_declaration_in_another_file_This_cannot_be_serialized: DiagnosticMessage;
            This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_file: DiagnosticMessage;
            This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without: DiagnosticMessage;
            Disable_loading_referenced_projects: DiagnosticMessage;
            Arguments_for_the_rest_parameter_0_were_not_provided: DiagnosticMessage;
            Generates_an_event_trace_and_a_list_of_types: DiagnosticMessage;
            Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react: DiagnosticMessage;
            File_0_exists_according_to_earlier_cached_lookups: DiagnosticMessage;
            File_0_does_not_exist_according_to_earlier_cached_lookups: DiagnosticMessage;
            Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1: DiagnosticMessage;
            Resolving_type_reference_directive_0_containing_file_1: DiagnosticMessage;
            Interpret_optional_property_types_as_written_rather_than_adding_undefined: DiagnosticMessage;
            Modules: DiagnosticMessage;
            File_Management: DiagnosticMessage;
            Emit: DiagnosticMessage;
            JavaScript_Support: DiagnosticMessage;
            Type_Checking: DiagnosticMessage;
            Editor_Support: DiagnosticMessage;
            Watch_and_Build_Modes: DiagnosticMessage;
            Compiler_Diagnostics: DiagnosticMessage;
            Interop_Constraints: DiagnosticMessage;
            Backwards_Compatibility: DiagnosticMessage;
            Language_and_Environment: DiagnosticMessage;
            Projects: DiagnosticMessage;
            Output_Formatting: DiagnosticMessage;
            Completeness: DiagnosticMessage;
            _0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file: DiagnosticMessage;
            Found_1_error_in_0: DiagnosticMessage;
            Found_0_errors_in_the_same_file_starting_at_Colon_1: DiagnosticMessage;
            Found_0_errors_in_1_files: DiagnosticMessage;
            File_name_0_has_a_1_extension_looking_up_2_instead: DiagnosticMessage;
            Module_0_was_resolved_to_1_but_allowArbitraryExtensions_is_not_set: DiagnosticMessage;
            Enable_importing_files_with_any_extension_provided_a_declaration_file_is_present: DiagnosticMessage;
            Resolving_type_reference_directive_for_program_that_specifies_custom_typeRoots_skipping_lookup_in_node_modules_folder: DiagnosticMessage;
            Option_0_can_only_be_specified_on_command_line: DiagnosticMessage;
            Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve: DiagnosticMessage;
            Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1: DiagnosticMessage;
            Invalid_import_specifier_0_has_no_possible_resolutions: DiagnosticMessage;
            package_json_scope_0_has_no_imports_defined: DiagnosticMessage;
            package_json_scope_0_explicitly_maps_specifier_1_to_null: DiagnosticMessage;
            package_json_scope_0_has_invalid_type_for_target_of_specifier_1: DiagnosticMessage;
            Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1: DiagnosticMessage;
            Resolution_of_non_relative_name_failed_trying_with_modern_Node_resolution_features_disabled_to_see_if_npm_library_needs_configuration_update: DiagnosticMessage;
            There_are_types_at_0_but_this_result_could_not_be_resolved_when_respecting_package_json_exports_The_1_library_may_need_to_update_its_package_json_or_typings: DiagnosticMessage;
            Resolution_of_non_relative_name_failed_trying_with_moduleResolution_bundler_to_see_if_project_may_need_configuration_update: DiagnosticMessage;
            There_are_types_at_0_but_this_result_could_not_be_resolved_under_your_current_moduleResolution_setting_Consider_updating_to_node16_nodenext_or_bundler: DiagnosticMessage;
            package_json_has_a_peerDependencies_field: DiagnosticMessage;
            Found_peerDependency_0_with_1_version: DiagnosticMessage;
            Failed_to_find_peerDependency_0: DiagnosticMessage;
            Enable_project_compilation: DiagnosticMessage;
            Composite_projects_may_not_disable_declaration_emit: DiagnosticMessage;
            Output_file_0_has_not_been_built_from_source_file_1: DiagnosticMessage;
            Referenced_project_0_must_have_setting_composite_Colon_true: DiagnosticMessage;
            File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_include_pattern: DiagnosticMessage;
            Referenced_project_0_may_not_disable_emit: DiagnosticMessage;
            Project_0_is_out_of_date_because_output_1_is_older_than_input_2: DiagnosticMessage;
            Project_0_is_up_to_date_because_newest_input_1_is_older_than_output_2: DiagnosticMessage;
            Project_0_is_out_of_date_because_output_file_1_does_not_exist: DiagnosticMessage;
            Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date: DiagnosticMessage;
            Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies: DiagnosticMessage;
            Projects_in_this_build_Colon_0: DiagnosticMessage;
            A_non_dry_build_would_delete_the_following_files_Colon_0: DiagnosticMessage;
            A_non_dry_build_would_build_project_0: DiagnosticMessage;
            Building_project_0: DiagnosticMessage;
            Updating_output_timestamps_of_project_0: DiagnosticMessage;
            Project_0_is_up_to_date: DiagnosticMessage;
            Skipping_build_of_project_0_because_its_dependency_1_has_errors: DiagnosticMessage;
            Project_0_can_t_be_built_because_its_dependency_1_has_errors: DiagnosticMessage;
            Build_one_or_more_projects_and_their_dependencies_if_out_of_date: DiagnosticMessage;
            Delete_the_outputs_of_all_projects: DiagnosticMessage;
            Show_what_would_be_built_or_deleted_if_specified_with_clean: DiagnosticMessage;
            Option_build_must_be_the_first_command_line_argument: DiagnosticMessage;
            Options_0_and_1_cannot_be_combined: DiagnosticMessage;
            Updating_unchanged_output_timestamps_of_project_0: DiagnosticMessage;
            A_non_dry_build_would_update_timestamps_for_output_of_project_0: DiagnosticMessage;
            Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1: DiagnosticMessage;
            Composite_projects_may_not_disable_incremental_compilation: DiagnosticMessage;
            Specify_file_to_store_incremental_compilation_information: DiagnosticMessage;
            Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_current_version_2: DiagnosticMessage;
            Skipping_build_of_project_0_because_its_dependency_1_was_not_built: DiagnosticMessage;
            Project_0_can_t_be_built_because_its_dependency_1_was_not_built: DiagnosticMessage;
            Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it: DiagnosticMessage;
            _0_is_deprecated: DiagnosticMessage;
            Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_native_implementation_of_the_Web_Performance_API_could_not_be_found: DiagnosticMessage;
            The_signature_0_of_1_is_deprecated: DiagnosticMessage;
            Project_0_is_being_forcibly_rebuilt: DiagnosticMessage;
            Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved: DiagnosticMessage;
            Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2: DiagnosticMessage;
            Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3: DiagnosticMessage;
            Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved: DiagnosticMessage;
            Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3: DiagnosticMessage;
            Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4: DiagnosticMessage;
            Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved: DiagnosticMessage;
            Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3: DiagnosticMessage;
            Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4: DiagnosticMessage;
            Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_resolved: DiagnosticMessage;
            Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_some_of_the_changes_were_not_emitted: DiagnosticMessage;
            Project_0_is_up_to_date_but_needs_to_update_timestamps_of_output_files_that_are_older_than_input_files: DiagnosticMessage;
            Project_0_is_out_of_date_because_there_was_error_reading_file_1: DiagnosticMessage;
            Resolving_in_0_mode_with_conditions_1: DiagnosticMessage;
            Matched_0_condition_1: DiagnosticMessage;
            Using_0_subpath_1_with_target_2: DiagnosticMessage;
            Saw_non_matching_condition_0: DiagnosticMessage;
            Project_0_is_out_of_date_because_buildinfo_file_1_indicates_there_is_change_in_compilerOptions: DiagnosticMessage;
            Allow_imports_to_include_TypeScript_file_extensions_Requires_moduleResolution_bundler_and_either_noEmit_or_emitDeclarationOnly_to_be_set: DiagnosticMessage;
            Use_the_package_json_exports_field_when_resolving_package_imports: DiagnosticMessage;
            Use_the_package_json_imports_field_when_resolving_imports: DiagnosticMessage;
            Conditions_to_set_in_addition_to_the_resolver_specific_defaults_when_resolving_imports: DiagnosticMessage;
            true_when_moduleResolution_is_node16_nodenext_or_bundler_otherwise_false: DiagnosticMessage;
            Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_file_2_was_root_file_of_compilation_but_not_any_more: DiagnosticMessage;
            Entering_conditional_exports: DiagnosticMessage;
            Resolved_under_condition_0: DiagnosticMessage;
            Failed_to_resolve_under_condition_0: DiagnosticMessage;
            Exiting_conditional_exports: DiagnosticMessage;
            Searching_all_ancestor_node_modules_directories_for_preferred_extensions_Colon_0: DiagnosticMessage;
            Searching_all_ancestor_node_modules_directories_for_fallback_extensions_Colon_0: DiagnosticMessage;
            Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_program_needs_to_report_errors: DiagnosticMessage;
            Project_0_is_out_of_date_because_1: DiagnosticMessage;
            Rewrite_ts_tsx_mts_and_cts_file_extensions_in_relative_import_paths_to_their_JavaScript_equivalent_in_output_files: DiagnosticMessage;
            The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1: DiagnosticMessage;
            The_expected_type_comes_from_this_index_signature: DiagnosticMessage;
            The_expected_type_comes_from_the_return_type_of_this_signature: DiagnosticMessage;
            Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing: DiagnosticMessage;
            File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option: DiagnosticMessage;
            Print_names_of_files_and_the_reason_they_are_part_of_the_compilation: DiagnosticMessage;
            Consider_adding_a_declare_modifier_to_this_class: DiagnosticMessage;
            Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these_files: DiagnosticMessage;
            Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export: DiagnosticMessage;
            Allow_accessing_UMD_globals_from_modules: DiagnosticMessage;
            Disable_error_reporting_for_unreachable_code: DiagnosticMessage;
            Disable_error_reporting_for_unused_labels: DiagnosticMessage;
            Ensure_use_strict_is_always_emitted: DiagnosticMessage;
            Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it: DiagnosticMessage;
            Specify_the_base_directory_to_resolve_non_relative_module_names: DiagnosticMessage;
            No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files: DiagnosticMessage;
            Enable_error_reporting_in_type_checked_JavaScript_files: DiagnosticMessage;
            Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references: DiagnosticMessage;
            Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project: DiagnosticMessage;
            Specify_the_output_directory_for_generated_declaration_files: DiagnosticMessage;
            Create_sourcemaps_for_d_ts_files: DiagnosticMessage;
            Output_compiler_performance_information_after_building: DiagnosticMessage;
            Disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project: DiagnosticMessage;
            Reduce_the_number_of_projects_loaded_automatically_by_TypeScript: DiagnosticMessage;
            Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server: DiagnosticMessage;
            Opt_a_project_out_of_multi_project_reference_checking_when_editing: DiagnosticMessage;
            Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects: DiagnosticMessage;
            Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration: DiagnosticMessage;
            Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files: DiagnosticMessage;
            Only_output_d_ts_files_and_not_JavaScript_files: DiagnosticMessage;
            Emit_design_type_metadata_for_decorated_declarations_in_source_files: DiagnosticMessage;
            Disable_the_type_acquisition_for_JavaScript_projects: DiagnosticMessage;
            Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheticDefaultImports_for_type_compatibility: DiagnosticMessage;
            Filters_results_from_the_include_option: DiagnosticMessage;
            Remove_a_list_of_directories_from_the_watch_process: DiagnosticMessage;
            Remove_a_list_of_files_from_the_watch_mode_s_processing: DiagnosticMessage;
            Enable_experimental_support_for_legacy_experimental_decorators: DiagnosticMessage;
            Print_files_read_during_the_compilation_including_why_it_was_included: DiagnosticMessage;
            Output_more_detailed_compiler_performance_information_after_building: DiagnosticMessage;
            Specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_are_inherited: DiagnosticMessage;
            Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers: DiagnosticMessage;
            Include_a_list_of_files_This_does_not_support_glob_patterns_as_opposed_to_include: DiagnosticMessage;
            Build_all_projects_including_those_that_appear_to_be_up_to_date: DiagnosticMessage;
            Ensure_that_casing_is_correct_in_imports: DiagnosticMessage;
            Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging: DiagnosticMessage;
            Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file: DiagnosticMessage;
            Skip_building_downstream_projects_on_error_in_upstream_project: DiagnosticMessage;
            Specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation: DiagnosticMessage;
            Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects: DiagnosticMessage;
            Include_sourcemap_files_inside_the_emitted_JavaScript: DiagnosticMessage;
            Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript: DiagnosticMessage;
            Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports: DiagnosticMessage;
            Specify_what_JSX_code_is_generated: DiagnosticMessage;
            Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h: DiagnosticMessage;
            Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragment_or_Fragment: DiagnosticMessage;
            Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Asterisk: DiagnosticMessage;
            Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option: DiagnosticMessage;
            Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment: DiagnosticMessage;
            Print_the_names_of_emitted_files_after_a_compilation: DiagnosticMessage;
            Print_all_of_the_files_read_during_the_compilation: DiagnosticMessage;
            Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit: DiagnosticMessage;
            Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: DiagnosticMessage;
            Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicable_with_allowJs: DiagnosticMessage;
            Specify_what_module_code_is_generated: DiagnosticMessage;
            Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier: DiagnosticMessage;
            Set_the_newline_character_for_emitting_files: DiagnosticMessage;
            Disable_emitting_files_from_a_compilation: DiagnosticMessage;
            Disable_generating_custom_helper_functions_like_extends_in_compiled_output: DiagnosticMessage;
            Disable_emitting_files_if_any_type_checking_errors_are_reported: DiagnosticMessage;
            Disable_truncating_types_in_error_messages: DiagnosticMessage;
            Enable_error_reporting_for_fallthrough_cases_in_switch_statements: DiagnosticMessage;
            Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type: DiagnosticMessage;
            Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier: DiagnosticMessage;
            Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function: DiagnosticMessage;
            Enable_error_reporting_when_this_is_given_the_type_any: DiagnosticMessage;
            Disable_adding_use_strict_directives_in_emitted_JavaScript_files: DiagnosticMessage;
            Disable_including_any_library_files_including_the_default_lib_d_ts: DiagnosticMessage;
            Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type: DiagnosticMessage;
            Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add_to_a_project: DiagnosticMessage;
            Disable_strict_checking_of_generic_signatures_in_function_types: DiagnosticMessage;
            Add_undefined_to_a_type_when_accessed_using_an_index: DiagnosticMessage;
            Enable_error_reporting_when_local_variables_aren_t_read: DiagnosticMessage;
            Raise_an_error_when_a_function_parameter_isn_t_read: DiagnosticMessage;
            Deprecated_setting_Use_outFile_instead: DiagnosticMessage;
            Specify_an_output_folder_for_all_emitted_files: DiagnosticMessage;
            Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designates_a_file_that_bundles_all_d_ts_output: DiagnosticMessage;
            Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations: DiagnosticMessage;
            Specify_a_list_of_language_service_plugins_to_include: DiagnosticMessage;
            Disable_erasing_const_enum_declarations_in_generated_code: DiagnosticMessage;
            Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node: DiagnosticMessage;
            Disable_wiping_the_console_in_watch_mode: DiagnosticMessage;
            Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read: DiagnosticMessage;
            Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit: DiagnosticMessage;
            Specify_an_array_of_objects_that_specify_paths_for_projects_Used_in_project_references: DiagnosticMessage;
            Disable_emitting_comments: DiagnosticMessage;
            Enable_importing_json_files: DiagnosticMessage;
            Specify_the_root_folder_within_your_source_files: DiagnosticMessage;
            Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules: DiagnosticMessage;
            Skip_type_checking_d_ts_files_that_are_included_with_TypeScript: DiagnosticMessage;
            Skip_type_checking_all_d_ts_files: DiagnosticMessage;
            Create_source_map_files_for_emitted_JavaScript_files: DiagnosticMessage;
            Specify_the_root_path_for_debuggers_to_find_the_reference_source_code: DiagnosticMessage;
            Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function: DiagnosticMessage;
            When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible: DiagnosticMessage;
            When_type_checking_take_into_account_null_and_undefined: DiagnosticMessage;
            Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor: DiagnosticMessage;
            Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments: DiagnosticMessage;
            Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals: DiagnosticMessage;
            Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures: DiagnosticMessage;
            Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_support_recursive_watching_natively: DiagnosticMessage;
            Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declarations: DiagnosticMessage;
            Log_paths_used_during_the_moduleResolution_process: DiagnosticMessage;
            Specify_the_path_to_tsbuildinfo_incremental_compilation_file: DiagnosticMessage;
            Specify_options_for_automatic_acquisition_of_declaration_files: DiagnosticMessage;
            Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types: DiagnosticMessage;
            Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file: DiagnosticMessage;
            Emit_ECMAScript_standard_compliant_class_fields: DiagnosticMessage;
            Enable_verbose_logging: DiagnosticMessage;
            Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality: DiagnosticMessage;
            Specify_how_the_TypeScript_watch_mode_works: DiagnosticMessage;
            Require_undeclared_properties_from_index_signatures_to_use_element_accesses: DiagnosticMessage;
            Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types: DiagnosticMessage;
            Require_sufficient_annotation_on_exports_so_other_tools_can_trivially_generate_declaration_files: DiagnosticMessage;
            Built_in_iterators_are_instantiated_with_a_TReturn_type_of_undefined_instead_of_any: DiagnosticMessage;
            Do_not_allow_runtime_constructs_that_are_not_part_of_ECMAScript: DiagnosticMessage;
            Default_catch_clause_variables_as_unknown_instead_of_any: DiagnosticMessage;
            Do_not_transform_or_elide_any_imports_or_exports_not_marked_as_type_only_ensuring_they_are_written_in_the_output_file_s_format_based_on_the_module_setting: DiagnosticMessage;
            Disable_full_type_checking_only_critical_parse_and_emit_errors_will_be_reported: DiagnosticMessage;
            Check_side_effect_imports: DiagnosticMessage;
            This_operation_can_be_simplified_This_shift_is_identical_to_0_1_2: DiagnosticMessage;
            Enable_lib_replacement: DiagnosticMessage;
            one_of_Colon: DiagnosticMessage;
            one_or_more_Colon: DiagnosticMessage;
            type_Colon: DiagnosticMessage;
            default_Colon: DiagnosticMessage;
            module_system_or_esModuleInterop: DiagnosticMessage;
            false_unless_strict_is_set: DiagnosticMessage;
            false_unless_composite_is_set: DiagnosticMessage;
            node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified: DiagnosticMessage;
            if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk: DiagnosticMessage;
            true_if_composite_false_otherwise: DiagnosticMessage;
            module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node: DiagnosticMessage;
            Computed_from_the_list_of_input_files: DiagnosticMessage;
            Platform_specific: DiagnosticMessage;
            You_can_learn_about_all_of_the_compiler_options_at_0: DiagnosticMessage;
            Including_watch_w_will_start_watching_the_current_project_for_the_file_changes_Once_set_you_can_config_watch_mode_with_Colon: DiagnosticMessage;
            Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_trigger_building_composite_projects_which_you_can_learn_more_about_at_0: DiagnosticMessage;
            COMMON_COMMANDS: DiagnosticMessage;
            ALL_COMPILER_OPTIONS: DiagnosticMessage;
            WATCH_OPTIONS: DiagnosticMessage;
            BUILD_OPTIONS: DiagnosticMessage;
            COMMON_COMPILER_OPTIONS: DiagnosticMessage;
            COMMAND_LINE_FLAGS: DiagnosticMessage;
            tsc_Colon_The_TypeScript_Compiler: DiagnosticMessage;
            Compiles_the_current_project_tsconfig_json_in_the_working_directory: DiagnosticMessage;
            Ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options: DiagnosticMessage;
            Build_a_composite_project_in_the_working_directory: DiagnosticMessage;
            Creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory: DiagnosticMessage;
            Compiles_the_TypeScript_project_located_at_the_specified_path: DiagnosticMessage;
            An_expanded_version_of_this_information_showing_all_possible_compiler_options: DiagnosticMessage;
            Compiles_the_current_project_with_additional_settings: DiagnosticMessage;
            true_for_ES2022_and_above_including_ESNext: DiagnosticMessage;
            List_of_file_name_suffixes_to_search_when_resolving_a_module: DiagnosticMessage;
            Variable_0_implicitly_has_an_1_type: DiagnosticMessage;
            Parameter_0_implicitly_has_an_1_type: DiagnosticMessage;
            Member_0_implicitly_has_an_1_type: DiagnosticMessage;
            new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type: DiagnosticMessage;
            _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type: DiagnosticMessage;
            Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: DiagnosticMessage;
            This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation: DiagnosticMessage;
            Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: DiagnosticMessage;
            Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: DiagnosticMessage;
            Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number: DiagnosticMessage;
            Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type: DiagnosticMessage;
            Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature: DiagnosticMessage;
            Object_literal_s_property_0_implicitly_has_an_1_type: DiagnosticMessage;
            Rest_parameter_0_implicitly_has_an_any_type: DiagnosticMessage;
            Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: DiagnosticMessage;
            _0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer: DiagnosticMessage;
            _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: DiagnosticMessage;
            Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: DiagnosticMessage;
            Generator_implicitly_has_yield_type_0_Consider_supplying_a_return_type_annotation: DiagnosticMessage;
            JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists: DiagnosticMessage;
            Unreachable_code_detected: DiagnosticMessage;
            Unused_label: DiagnosticMessage;
            Fallthrough_case_in_switch: DiagnosticMessage;
            Not_all_code_paths_return_a_value: DiagnosticMessage;
            Binding_element_0_implicitly_has_an_1_type: DiagnosticMessage;
            Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation: DiagnosticMessage;
            Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation: DiagnosticMessage;
            Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined: DiagnosticMessage;
            Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0: DiagnosticMessage;
            Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0: DiagnosticMessage;
            Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for_all_imports_Implies_allowSyntheticDefaultImports: DiagnosticMessage;
            Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead: DiagnosticMessage;
            Mapped_object_type_implicitly_has_an_any_template_type: DiagnosticMessage;
            If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1: DiagnosticMessage;
            The_containing_arrow_function_captures_the_global_value_of_this: DiagnosticMessage;
            Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used: DiagnosticMessage;
            Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: DiagnosticMessage;
            Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: DiagnosticMessage;
            Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: DiagnosticMessage;
            Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage: DiagnosticMessage;
            Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage: DiagnosticMessage;
            Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage: DiagnosticMessage;
            Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage: DiagnosticMessage;
            _0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage: DiagnosticMessage;
            Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1: DiagnosticMessage;
            Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1: DiagnosticMessage;
            Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1: DiagnosticMessage;
            No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1: DiagnosticMessage;
            _0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type: DiagnosticMessage;
            The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_type_annotation_is_needed: DiagnosticMessage;
            yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation: DiagnosticMessage;
            If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_declare_module_1: DiagnosticMessage;
            This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead: DiagnosticMessage;
            This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint: DiagnosticMessage;
            A_mapped_type_may_not_declare_properties_or_methods: DiagnosticMessage;
            You_cannot_rename_this_element: DiagnosticMessage;
            You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library: DiagnosticMessage;
            import_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            export_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            Type_parameter_declarations_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            implements_clauses_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            _0_declarations_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            Type_aliases_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            The_0_modifier_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            Type_annotations_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            Type_arguments_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            Parameter_modifiers_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            Non_null_assertions_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            Type_assertion_expressions_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            Signature_declarations_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            Report_errors_in_js_files: DiagnosticMessage;
            JSDoc_types_can_only_be_used_inside_documentation_comments: DiagnosticMessage;
            JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags: DiagnosticMessage;
            JSDoc_0_is_not_attached_to_a_class: DiagnosticMessage;
            JSDoc_0_1_does_not_match_the_extends_2_clause: DiagnosticMessage;
            JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name: DiagnosticMessage;
            Class_declarations_cannot_have_more_than_one_augments_or_extends_tag: DiagnosticMessage;
            Expected_0_type_arguments_provide_these_with_an_extends_tag: DiagnosticMessage;
            Expected_0_1_type_arguments_provide_these_with_an_extends_tag: DiagnosticMessage;
            JSDoc_may_only_appear_in_the_last_parameter_of_a_signature: DiagnosticMessage;
            JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type: DiagnosticMessage;
            The_type_of_a_function_declaration_must_match_the_function_s_signature: DiagnosticMessage;
            You_cannot_rename_a_module_via_a_global_import: DiagnosticMessage;
            Qualified_name_0_is_not_allowed_without_a_leading_param_object_1: DiagnosticMessage;
            A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags: DiagnosticMessage;
            The_tag_was_first_specified_here: DiagnosticMessage;
            You_cannot_rename_elements_that_are_defined_in_a_node_modules_folder: DiagnosticMessage;
            You_cannot_rename_elements_that_are_defined_in_another_node_modules_folder: DiagnosticMessage;
            Type_satisfaction_expressions_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
            Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export: DiagnosticMessage;
            A_JSDoc_template_tag_may_not_follow_a_typedef_callback_or_overload_tag: DiagnosticMessage;
            Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_declaration_emit: DiagnosticMessage;
            Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotation_may_unblock_declaration_emit: DiagnosticMessage;
            Function_must_have_an_explicit_return_type_annotation_with_isolatedDeclarations: DiagnosticMessage;
            Method_must_have_an_explicit_return_type_annotation_with_isolatedDeclarations: DiagnosticMessage;
            At_least_one_accessor_must_have_an_explicit_type_annotation_with_isolatedDeclarations: DiagnosticMessage;
            Variable_must_have_an_explicit_type_annotation_with_isolatedDeclarations: DiagnosticMessage;
            Parameter_must_have_an_explicit_type_annotation_with_isolatedDeclarations: DiagnosticMessage;
            Property_must_have_an_explicit_type_annotation_with_isolatedDeclarations: DiagnosticMessage;
            Expression_type_can_t_be_inferred_with_isolatedDeclarations: DiagnosticMessage;
            Computed_properties_must_be_number_or_string_literals_variables_or_dotted_expressions_with_isolatedDeclarations: DiagnosticMessage;
            Objects_that_contain_spread_assignments_can_t_be_inferred_with_isolatedDeclarations: DiagnosticMessage;
            Objects_that_contain_shorthand_properties_can_t_be_inferred_with_isolatedDeclarations: DiagnosticMessage;
            Only_const_arrays_can_be_inferred_with_isolatedDeclarations: DiagnosticMessage;
            Arrays_with_spread_elements_can_t_inferred_with_isolatedDeclarations: DiagnosticMessage;
            Binding_elements_can_t_be_exported_directly_with_isolatedDeclarations: DiagnosticMessage;
            Enum_member_initializers_must_be_computable_without_references_to_external_symbols_with_isolatedDeclarations: DiagnosticMessage;
            Extends_clause_can_t_contain_an_expression_with_isolatedDeclarations: DiagnosticMessage;
            Inference_from_class_expressions_is_not_supported_with_isolatedDeclarations: DiagnosticMessage;
            Assigning_properties_to_functions_without_declaring_them_is_not_supported_with_isolatedDeclarations_Add_an_explicit_declaration_for_the_properties_assigned_to_this_function: DiagnosticMessage;
            Declaration_emit_for_this_parameter_requires_implicitly_adding_undefined_to_its_type_This_is_not_supported_with_isolatedDeclarations: DiagnosticMessage;
            Declaration_emit_for_this_file_requires_preserving_this_import_for_augmentations_This_is_not_supported_with_isolatedDeclarations: DiagnosticMessage;
            Add_a_type_annotation_to_the_variable_0: DiagnosticMessage;
            Add_a_type_annotation_to_the_parameter_0: DiagnosticMessage;
            Add_a_type_annotation_to_the_property_0: DiagnosticMessage;
            Add_a_return_type_to_the_function_expression: DiagnosticMessage;
            Add_a_return_type_to_the_function_declaration: DiagnosticMessage;
            Add_a_return_type_to_the_get_accessor_declaration: DiagnosticMessage;
            Add_a_type_to_parameter_of_the_set_accessor_declaration: DiagnosticMessage;
            Add_a_return_type_to_the_method: DiagnosticMessage;
            Add_satisfies_and_a_type_assertion_to_this_expression_satisfies_T_as_T_to_make_the_type_explicit: DiagnosticMessage;
            Move_the_expression_in_default_export_to_a_variable_and_add_a_type_annotation_to_it: DiagnosticMessage;
            Default_exports_can_t_be_inferred_with_isolatedDeclarations: DiagnosticMessage;
            Computed_property_names_on_class_or_object_literals_cannot_be_inferred_with_isolatedDeclarations: DiagnosticMessage;
            Type_containing_private_name_0_can_t_be_used_with_isolatedDeclarations: DiagnosticMessage;
            JSX_attributes_must_only_be_assigned_a_non_empty_expression: DiagnosticMessage;
            JSX_elements_cannot_have_multiple_attributes_with_the_same_name: DiagnosticMessage;
            Expected_corresponding_JSX_closing_tag_for_0: DiagnosticMessage;
            Cannot_use_JSX_unless_the_jsx_flag_is_provided: DiagnosticMessage;
            A_constructor_cannot_contain_a_super_call_when_its_class_extends_null: DiagnosticMessage;
            An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: DiagnosticMessage;
            A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: DiagnosticMessage;
            JSX_element_0_has_no_corresponding_closing_tag: DiagnosticMessage;
            super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class: DiagnosticMessage;
            Unknown_type_acquisition_option_0: DiagnosticMessage;
            super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class: DiagnosticMessage;
            _0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2: DiagnosticMessage;
            Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor: DiagnosticMessage;
            JSX_fragment_has_no_corresponding_closing_tag: DiagnosticMessage;
            Expected_corresponding_closing_tag_for_JSX_fragment: DiagnosticMessage;
            The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option: DiagnosticMessage;
            An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments: DiagnosticMessage;
            Unknown_type_acquisition_option_0_Did_you_mean_1: DiagnosticMessage;
            _0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1: DiagnosticMessage;
            _0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1: DiagnosticMessage;
            Unicode_escape_sequence_cannot_appear_here: DiagnosticMessage;
            Circularity_detected_while_resolving_configuration_Colon_0: DiagnosticMessage;
            The_files_list_in_config_file_0_is_empty: DiagnosticMessage;
            No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2: DiagnosticMessage;
            File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module: DiagnosticMessage;
            This_constructor_function_may_be_converted_to_a_class_declaration: DiagnosticMessage;
            Import_may_be_converted_to_a_default_import: DiagnosticMessage;
            JSDoc_types_may_be_moved_to_TypeScript_types: DiagnosticMessage;
            require_call_may_be_converted_to_an_import: DiagnosticMessage;
            This_may_be_converted_to_an_async_function: DiagnosticMessage;
            await_has_no_effect_on_the_type_of_this_expression: DiagnosticMessage;
            Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers: DiagnosticMessage;
            JSDoc_typedef_may_be_converted_to_TypeScript_type: DiagnosticMessage;
            JSDoc_typedefs_may_be_converted_to_TypeScript_types: DiagnosticMessage;
            Add_missing_super_call: DiagnosticMessage;
            Make_super_call_the_first_statement_in_the_constructor: DiagnosticMessage;
            Change_extends_to_implements: DiagnosticMessage;
            Remove_unused_declaration_for_Colon_0: DiagnosticMessage;
            Remove_import_from_0: DiagnosticMessage;
            Implement_interface_0: DiagnosticMessage;
            Implement_inherited_abstract_class: DiagnosticMessage;
            Add_0_to_unresolved_variable: DiagnosticMessage;
            Remove_variable_statement: DiagnosticMessage;
            Remove_template_tag: DiagnosticMessage;
            Remove_type_parameters: DiagnosticMessage;
            Import_0_from_1: DiagnosticMessage;
            Change_0_to_1: DiagnosticMessage;
            Declare_property_0: DiagnosticMessage;
            Add_index_signature_for_property_0: DiagnosticMessage;
            Disable_checking_for_this_file: DiagnosticMessage;
            Ignore_this_error_message: DiagnosticMessage;
            Initialize_property_0_in_the_constructor: DiagnosticMessage;
            Initialize_static_property_0: DiagnosticMessage;
            Change_spelling_to_0: DiagnosticMessage;
            Declare_method_0: DiagnosticMessage;
            Declare_static_method_0: DiagnosticMessage;
            Prefix_0_with_an_underscore: DiagnosticMessage;
            Rewrite_as_the_indexed_access_type_0: DiagnosticMessage;
            Declare_static_property_0: DiagnosticMessage;
            Call_decorator_expression: DiagnosticMessage;
            Add_async_modifier_to_containing_function: DiagnosticMessage;
            Replace_infer_0_with_unknown: DiagnosticMessage;
            Replace_all_unused_infer_with_unknown: DiagnosticMessage;
            Add_parameter_name: DiagnosticMessage;
            Declare_private_property_0: DiagnosticMessage;
            Replace_0_with_Promise_1: DiagnosticMessage;
            Fix_all_incorrect_return_type_of_an_async_functions: DiagnosticMessage;
            Declare_private_method_0: DiagnosticMessage;
            Remove_unused_destructuring_declaration: DiagnosticMessage;
            Remove_unused_declarations_for_Colon_0: DiagnosticMessage;
            Declare_a_private_field_named_0: DiagnosticMessage;
            Includes_imports_of_types_referenced_by_0: DiagnosticMessage;
            Remove_type_from_import_declaration_from_0: DiagnosticMessage;
            Remove_type_from_import_of_0_from_1: DiagnosticMessage;
            Add_import_from_0: DiagnosticMessage;
            Update_import_from_0: DiagnosticMessage;
            Export_0_from_module_1: DiagnosticMessage;
            Export_all_referenced_locals: DiagnosticMessage;
            Update_modifiers_of_0: DiagnosticMessage;
            Add_annotation_of_type_0: DiagnosticMessage;
            Add_return_type_0: DiagnosticMessage;
            Extract_base_class_to_variable: DiagnosticMessage;
            Extract_default_export_to_variable: DiagnosticMessage;
            Extract_binding_expressions_to_variable: DiagnosticMessage;
            Add_all_missing_type_annotations: DiagnosticMessage;
            Add_satisfies_and_an_inline_type_assertion_with_0: DiagnosticMessage;
            Extract_to_variable_and_replace_with_0_as_typeof_0: DiagnosticMessage;
            Mark_array_literal_as_const: DiagnosticMessage;
            Annotate_types_of_properties_expando_function_in_a_namespace: DiagnosticMessage;
            Convert_function_to_an_ES2015_class: DiagnosticMessage;
            Convert_0_to_1_in_0: DiagnosticMessage;
            Extract_to_0_in_1: DiagnosticMessage;
            Extract_function: DiagnosticMessage;
            Extract_constant: DiagnosticMessage;
            Extract_to_0_in_enclosing_scope: DiagnosticMessage;
            Extract_to_0_in_1_scope: DiagnosticMessage;
            Annotate_with_type_from_JSDoc: DiagnosticMessage;
            Infer_type_of_0_from_usage: DiagnosticMessage;
            Infer_parameter_types_from_usage: DiagnosticMessage;
            Convert_to_default_import: DiagnosticMessage;
            Install_0: DiagnosticMessage;
            Replace_import_with_0: DiagnosticMessage;
            Use_synthetic_default_member: DiagnosticMessage;
            Convert_to_ES_module: DiagnosticMessage;
            Add_undefined_type_to_property_0: DiagnosticMessage;
            Add_initializer_to_property_0: DiagnosticMessage;
            Add_definite_assignment_assertion_to_property_0: DiagnosticMessage;
            Convert_all_type_literals_to_mapped_type: DiagnosticMessage;
            Add_all_missing_members: DiagnosticMessage;
            Infer_all_types_from_usage: DiagnosticMessage;
            Delete_all_unused_declarations: DiagnosticMessage;
            Prefix_all_unused_declarations_with_where_possible: DiagnosticMessage;
            Fix_all_detected_spelling_errors: DiagnosticMessage;
            Add_initializers_to_all_uninitialized_properties: DiagnosticMessage;
            Add_definite_assignment_assertions_to_all_uninitialized_properties: DiagnosticMessage;
            Add_undefined_type_to_all_uninitialized_properties: DiagnosticMessage;
            Change_all_jsdoc_style_types_to_TypeScript: DiagnosticMessage;
            Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types: DiagnosticMessage;
            Implement_all_unimplemented_interfaces: DiagnosticMessage;
            Install_all_missing_types_packages: DiagnosticMessage;
            Rewrite_all_as_indexed_access_types: DiagnosticMessage;
            Convert_all_to_default_imports: DiagnosticMessage;
            Make_all_super_calls_the_first_statement_in_their_constructor: DiagnosticMessage;
            Add_qualifier_to_all_unresolved_variables_matching_a_member_name: DiagnosticMessage;
            Change_all_extended_interfaces_to_implements: DiagnosticMessage;
            Add_all_missing_super_calls: DiagnosticMessage;
            Implement_all_inherited_abstract_classes: DiagnosticMessage;
            Add_all_missing_async_modifiers: DiagnosticMessage;
            Add_ts_ignore_to_all_error_messages: DiagnosticMessage;
            Annotate_everything_with_types_from_JSDoc: DiagnosticMessage;
            Add_to_all_uncalled_decorators: DiagnosticMessage;
            Convert_all_constructor_functions_to_classes: DiagnosticMessage;
            Generate_get_and_set_accessors: DiagnosticMessage;
            Convert_require_to_import: DiagnosticMessage;
            Convert_all_require_to_import: DiagnosticMessage;
            Move_to_a_new_file: DiagnosticMessage;
            Remove_unreachable_code: DiagnosticMessage;
            Remove_all_unreachable_code: DiagnosticMessage;
            Add_missing_typeof: DiagnosticMessage;
            Remove_unused_label: DiagnosticMessage;
            Remove_all_unused_labels: DiagnosticMessage;
            Convert_0_to_mapped_object_type: DiagnosticMessage;
            Convert_namespace_import_to_named_imports: DiagnosticMessage;
            Convert_named_imports_to_namespace_import: DiagnosticMessage;
            Add_or_remove_braces_in_an_arrow_function: DiagnosticMessage;
            Add_braces_to_arrow_function: DiagnosticMessage;
            Remove_braces_from_arrow_function: DiagnosticMessage;
            Convert_default_export_to_named_export: DiagnosticMessage;
            Convert_named_export_to_default_export: DiagnosticMessage;
            Add_missing_enum_member_0: DiagnosticMessage;
            Add_all_missing_imports: DiagnosticMessage;
            Convert_to_async_function: DiagnosticMessage;
            Convert_all_to_async_functions: DiagnosticMessage;
            Add_missing_call_parentheses: DiagnosticMessage;
            Add_all_missing_call_parentheses: DiagnosticMessage;
            Add_unknown_conversion_for_non_overlapping_types: DiagnosticMessage;
            Add_unknown_to_all_conversions_of_non_overlapping_types: DiagnosticMessage;
            Add_missing_new_operator_to_call: DiagnosticMessage;
            Add_missing_new_operator_to_all_calls: DiagnosticMessage;
            Add_names_to_all_parameters_without_names: DiagnosticMessage;
            Enable_the_experimentalDecorators_option_in_your_configuration_file: DiagnosticMessage;
            Convert_parameters_to_destructured_object: DiagnosticMessage;
            Extract_type: DiagnosticMessage;
            Extract_to_type_alias: DiagnosticMessage;
            Extract_to_typedef: DiagnosticMessage;
            Infer_this_type_of_0_from_usage: DiagnosticMessage;
            Add_const_to_unresolved_variable: DiagnosticMessage;
            Add_const_to_all_unresolved_variables: DiagnosticMessage;
            Add_await: DiagnosticMessage;
            Add_await_to_initializer_for_0: DiagnosticMessage;
            Fix_all_expressions_possibly_missing_await: DiagnosticMessage;
            Remove_unnecessary_await: DiagnosticMessage;
            Remove_all_unnecessary_uses_of_await: DiagnosticMessage;
            Enable_the_jsx_flag_in_your_configuration_file: DiagnosticMessage;
            Add_await_to_initializers: DiagnosticMessage;
            Extract_to_interface: DiagnosticMessage;
            Convert_to_a_bigint_numeric_literal: DiagnosticMessage;
            Convert_all_to_bigint_numeric_literals: DiagnosticMessage;
            Convert_const_to_let: DiagnosticMessage;
            Prefix_with_declare: DiagnosticMessage;
            Prefix_all_incorrect_property_declarations_with_declare: DiagnosticMessage;
            Convert_to_template_string: DiagnosticMessage;
            Add_export_to_make_this_file_into_a_module: DiagnosticMessage;
            Set_the_target_option_in_your_configuration_file_to_0: DiagnosticMessage;
            Set_the_module_option_in_your_configuration_file_to_0: DiagnosticMessage;
            Convert_invalid_character_to_its_html_entity_code: DiagnosticMessage;
            Convert_all_invalid_characters_to_HTML_entity_code: DiagnosticMessage;
            Convert_all_const_to_let: DiagnosticMessage;
            Convert_function_expression_0_to_arrow_function: DiagnosticMessage;
            Convert_function_declaration_0_to_arrow_function: DiagnosticMessage;
            Fix_all_implicit_this_errors: DiagnosticMessage;
            Wrap_invalid_character_in_an_expression_container: DiagnosticMessage;
            Wrap_all_invalid_characters_in_an_expression_container: DiagnosticMessage;
            Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file: DiagnosticMessage;
            Add_a_return_statement: DiagnosticMessage;
            Remove_braces_from_arrow_function_body: DiagnosticMessage;
            Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal: DiagnosticMessage;
            Add_all_missing_return_statement: DiagnosticMessage;
            Remove_braces_from_all_arrow_function_bodies_with_relevant_issues: DiagnosticMessage;
            Wrap_all_object_literal_with_parentheses: DiagnosticMessage;
            Move_labeled_tuple_element_modifiers_to_labels: DiagnosticMessage;
            Convert_overload_list_to_single_signature: DiagnosticMessage;
            Generate_get_and_set_accessors_for_all_overriding_properties: DiagnosticMessage;
            Wrap_in_JSX_fragment: DiagnosticMessage;
            Wrap_all_unparented_JSX_in_JSX_fragment: DiagnosticMessage;
            Convert_arrow_function_or_function_expression: DiagnosticMessage;
            Convert_to_anonymous_function: DiagnosticMessage;
            Convert_to_named_function: DiagnosticMessage;
            Convert_to_arrow_function: DiagnosticMessage;
            Remove_parentheses: DiagnosticMessage;
            Could_not_find_a_containing_arrow_function: DiagnosticMessage;
            Containing_function_is_not_an_arrow_function: DiagnosticMessage;
            Could_not_find_export_statement: DiagnosticMessage;
            This_file_already_has_a_default_export: DiagnosticMessage;
            Could_not_find_import_clause: DiagnosticMessage;
            Could_not_find_namespace_import_or_named_imports: DiagnosticMessage;
            Selection_is_not_a_valid_type_node: DiagnosticMessage;
            No_type_could_be_extracted_from_this_type_node: DiagnosticMessage;
            Could_not_find_property_for_which_to_generate_accessor: DiagnosticMessage;
            Name_is_not_valid: DiagnosticMessage;
            Can_only_convert_property_with_modifier: DiagnosticMessage;
            Switch_each_misused_0_to_1: DiagnosticMessage;
            Convert_to_optional_chain_expression: DiagnosticMessage;
            Could_not_find_convertible_access_expression: DiagnosticMessage;
            Could_not_find_matching_access_expressions: DiagnosticMessage;
            Can_only_convert_logical_AND_access_chains: DiagnosticMessage;
            Add_void_to_Promise_resolved_without_a_value: DiagnosticMessage;
            Add_void_to_all_Promises_resolved_without_a_value: DiagnosticMessage;
            Use_element_access_for_0: DiagnosticMessage;
            Use_element_access_for_all_undeclared_properties: DiagnosticMessage;
            Delete_all_unused_imports: DiagnosticMessage;
            Infer_function_return_type: DiagnosticMessage;
            Return_type_must_be_inferred_from_a_function: DiagnosticMessage;
            Could_not_determine_function_return_type: DiagnosticMessage;
            Could_not_convert_to_arrow_function: DiagnosticMessage;
            Could_not_convert_to_named_function: DiagnosticMessage;
            Could_not_convert_to_anonymous_function: DiagnosticMessage;
            Can_only_convert_string_concatenations_and_string_literals: DiagnosticMessage;
            Selection_is_not_a_valid_statement_or_statements: DiagnosticMessage;
            Add_missing_function_declaration_0: DiagnosticMessage;
            Add_all_missing_function_declarations: DiagnosticMessage;
            Method_not_implemented: DiagnosticMessage;
            Function_not_implemented: DiagnosticMessage;
            Add_override_modifier: DiagnosticMessage;
            Remove_override_modifier: DiagnosticMessage;
            Add_all_missing_override_modifiers: DiagnosticMessage;
            Remove_all_unnecessary_override_modifiers: DiagnosticMessage;
            Can_only_convert_named_export: DiagnosticMessage;
            Add_missing_properties: DiagnosticMessage;
            Add_all_missing_properties: DiagnosticMessage;
            Add_missing_attributes: DiagnosticMessage;
            Add_all_missing_attributes: DiagnosticMessage;
            Add_undefined_to_optional_property_type: DiagnosticMessage;
            Convert_named_imports_to_default_import: DiagnosticMessage;
            Delete_unused_param_tag_0: DiagnosticMessage;
            Delete_all_unused_param_tags: DiagnosticMessage;
            Rename_param_tag_name_0_to_1: DiagnosticMessage;
            Use_0: DiagnosticMessage;
            Use_Number_isNaN_in_all_conditions: DiagnosticMessage;
            Convert_typedef_to_TypeScript_type: DiagnosticMessage;
            Convert_all_typedef_to_TypeScript_types: DiagnosticMessage;
            Move_to_file: DiagnosticMessage;
            Cannot_move_to_file_selected_file_is_invalid: DiagnosticMessage;
            Use_import_type: DiagnosticMessage;
            Use_type_0: DiagnosticMessage;
            Fix_all_with_type_only_imports: DiagnosticMessage;
            Cannot_move_statements_to_the_selected_file: DiagnosticMessage;
            Inline_variable: DiagnosticMessage;
            Could_not_find_variable_to_inline: DiagnosticMessage;
            Variables_with_multiple_declarations_cannot_be_inlined: DiagnosticMessage;
            Add_missing_comma_for_object_member_completion_0: DiagnosticMessage;
            Add_missing_parameter_to_0: DiagnosticMessage;
            Add_missing_parameters_to_0: DiagnosticMessage;
            Add_all_missing_parameters: DiagnosticMessage;
            Add_optional_parameter_to_0: DiagnosticMessage;
            Add_optional_parameters_to_0: DiagnosticMessage;
            Add_all_optional_parameters: DiagnosticMessage;
            Wrap_in_parentheses: DiagnosticMessage;
            Wrap_all_invalid_decorator_expressions_in_parentheses: DiagnosticMessage;
            Add_resolution_mode_import_attribute: DiagnosticMessage;
            Add_resolution_mode_import_attribute_to_all_type_only_imports_that_need_it: DiagnosticMessage;
            No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer: DiagnosticMessage;
            Classes_may_not_have_a_field_named_constructor: DiagnosticMessage;
            JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array: DiagnosticMessage;
            Private_identifiers_cannot_be_used_as_parameters: DiagnosticMessage;
            An_accessibility_modifier_cannot_be_used_with_a_private_identifier: DiagnosticMessage;
            The_operand_of_a_delete_operator_cannot_be_a_private_identifier: DiagnosticMessage;
            constructor_is_a_reserved_word: DiagnosticMessage;
            Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier: DiagnosticMessage;
            The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling: DiagnosticMessage;
            Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2: DiagnosticMessage;
            Private_identifiers_are_not_allowed_outside_class_bodies: DiagnosticMessage;
            The_shadowing_declaration_of_0_is_defined_here: DiagnosticMessage;
            The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here: DiagnosticMessage;
            _0_modifier_cannot_be_used_with_a_private_identifier: DiagnosticMessage;
            An_enum_member_cannot_be_named_with_a_private_identifier: DiagnosticMessage;
            can_only_be_used_at_the_start_of_a_file: DiagnosticMessage;
            Compiler_reserves_name_0_when_emitting_private_identifier_downlevel: DiagnosticMessage;
            Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher: DiagnosticMessage;
            Private_identifiers_are_not_allowed_in_variable_declarations: DiagnosticMessage;
            An_optional_chain_cannot_contain_private_identifiers: DiagnosticMessage;
            The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents: DiagnosticMessage;
            The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some: DiagnosticMessage;
            Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values: DiagnosticMessage;
            Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compiler_option_is_specified_e_g_Fragment: DiagnosticMessage;
            Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name: DiagnosticMessage;
            Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator: DiagnosticMessage;
            await_expression_cannot_be_used_inside_a_class_static_block: DiagnosticMessage;
            for_await_loops_cannot_be_used_inside_a_class_static_block: DiagnosticMessage;
            Invalid_use_of_0_It_cannot_be_used_inside_a_class_static_block: DiagnosticMessage;
            A_return_statement_cannot_be_used_inside_a_class_static_block: DiagnosticMessage;
            _0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation: DiagnosticMessage;
            Types_cannot_appear_in_export_declarations_in_JavaScript_files: DiagnosticMessage;
            _0_is_automatically_exported_here: DiagnosticMessage;
            Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher: DiagnosticMessage;
            _0_is_of_type_unknown: DiagnosticMessage;
            _0_is_possibly_null: DiagnosticMessage;
            _0_is_possibly_undefined: DiagnosticMessage;
            _0_is_possibly_null_or_undefined: DiagnosticMessage;
            The_value_0_cannot_be_used_here: DiagnosticMessage;
            Compiler_option_0_cannot_be_given_an_empty_string: DiagnosticMessage;
            Its_type_0_is_not_a_valid_JSX_element_type: DiagnosticMessage;
            await_using_statements_cannot_be_used_inside_a_class_static_block: DiagnosticMessage;
            _0_has_a_string_type_but_must_have_syntactically_recognizable_string_syntax_when_isolatedModules_is_enabled: DiagnosticMessage;
            Enum_member_following_a_non_literal_numeric_member_must_have_an_initializer_when_isolatedModules_is_enabled: DiagnosticMessage;
            String_literal_import_and_export_names_are_not_supported_when_the_module_flag_is_set_to_es2015_or_es2020: DiagnosticMessage;
        };
        function tokenIsIdentifierOrKeyword(token: SyntaxKind): boolean;
        function tokenIsIdentifierOrKeywordOrGreaterThan(token: SyntaxKind): boolean;
        function isUnicodeIdentifierStart(code: number, languageVersion: ScriptTarget | undefined): boolean;
        function tokenToString(t: PunctuationOrKeywordSyntaxKind): string;
        function tokenToString(t: SyntaxKind): string | undefined;
        function stringToToken(s: string): SyntaxKind | undefined;
        function regularExpressionFlagToCharacterCode(f: RegularExpressionFlags): CharacterCodes | undefined;
        function characterCodeToRegularExpressionFlag(ch: CharacterCodes): RegularExpressionFlags | undefined;
        function computeLineStarts(text: string): number[];
        function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number;
        function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number, allowEdits?: true): number;
        function computePositionOfLineAndCharacter(lineStarts: readonly number[], line: number, character: number, debugText?: string, allowEdits?: true): number;
        function getLineStarts(sourceFile: SourceFileLike): readonly number[];
        function computeLineAndCharacterOfPosition(lineStarts: readonly number[], position: number): LineAndCharacter;
        function computeLineOfPosition(lineStarts: readonly number[], position: number, lowerBound?: number): number;
        function getLinesBetweenPositions(sourceFile: SourceFileLike, pos1: number, pos2: number): number;
        function getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter;
        function isWhiteSpaceLike(ch: number): boolean;
        function isWhiteSpaceSingleLine(ch: number): boolean;
        function isLineBreak(ch: number): boolean;
        function couldStartTrivia(text: string, pos: number): boolean;
        function skipTrivia(text: string, pos: number, stopAfterLineBreak?: boolean, stopAtComments?: boolean, inJSDoc?: boolean): number;
        function forEachLeadingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
        function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
        function forEachTrailingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
        function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
        function reduceEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T, initial: U): U | undefined;
        function reduceEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T, initial: U): U | undefined;
        function getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
        function getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
        function getShebang(text: string): string | undefined;
        function isIdentifierStart(ch: number, languageVersion: ScriptTarget | undefined): boolean;
        function isIdentifierPart(ch: number, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;
        function isIdentifierText(name: string, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;
        function createScanner(languageVersion: ScriptTarget, skipTrivia: boolean, languageVariant?: LanguageVariant, textInitial?: string, onError?: ErrorCallback, start?: number, length?: number): Scanner;
        function utf16EncodeAsString(codePoint: number): string;
        type ErrorCallback = (message: DiagnosticMessage, length: number, arg0?: any) => void;
        interface Scanner {
            getStartPos(): number;
            getToken(): SyntaxKind;
            getTokenFullStart(): number;
            getTokenStart(): number;
            getTokenEnd(): number;
            getTextPos(): number;
            getTokenPos(): number;
            getTokenText(): string;
            getTokenValue(): string;
            hasUnicodeEscape(): boolean;
            hasExtendedUnicodeEscape(): boolean;
            hasPrecedingLineBreak(): boolean;
            hasPrecedingJSDocComment(): boolean;
            hasPrecedingJSDocLeadingAsterisks(): boolean;
            isIdentifier(): boolean;
            isReservedWord(): boolean;
            isUnterminated(): boolean;
            getNumericLiteralFlags(): TokenFlags;
            getCommentDirectives(): CommentDirective[] | undefined;
            getTokenFlags(): TokenFlags;
            reScanGreaterToken(): SyntaxKind;
            reScanSlashToken(): SyntaxKind;
            reScanSlashToken(reportErrors?: boolean): SyntaxKind;
            reScanAsteriskEqualsToken(): SyntaxKind;
            reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind;
            reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind;
            scanJsxIdentifier(): SyntaxKind;
            scanJsxAttributeValue(): SyntaxKind;
            reScanJsxAttributeValue(): SyntaxKind;
            reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind;
            reScanLessThanToken(): SyntaxKind;
            reScanHashToken(): SyntaxKind;
            reScanQuestionToken(): SyntaxKind;
            reScanInvalidIdentifier(): SyntaxKind;
            scanJsxToken(): JsxTokenSyntaxKind;
            scanJsDocToken(): JSDocSyntaxKind;
            scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken;
            scan(): SyntaxKind;
            getText(): string;
            clearCommentDirectives(): void;
            setText(text: string | undefined, start?: number, length?: number): void;
            setOnError(onError: ErrorCallback | undefined): void;
            setScriptTarget(scriptTarget: ScriptTarget): void;
            setLanguageVariant(variant: LanguageVariant): void;
            setScriptKind(scriptKind: ScriptKind): void;
            setJSDocParsingMode(kind: JSDocParsingMode): void;
            setTextPos(textPos: number): void;
            resetTokenState(pos: number): void;
            setSkipJsDocLeadingAsterisks(skip: boolean): void;
            lookAhead<T>(callback: () => T): T;
            scanRange<T>(start: number, length: number, callback: () => T): T;
            tryScan<T>(callback: () => T): T;
        }
        const textToKeywordObj: MapLike<KeywordSyntaxKind>;
        function isExternalModuleNameRelative(moduleName: string): boolean;
        function sortAndDeduplicateDiagnostics<T extends Diagnostic>(diagnostics: readonly T[]): SortedReadonlyArray<T>;
        function getDefaultLibFileName(options: CompilerOptions): string;
        function textSpanEnd(span: TextSpan): number;
        function textSpanIsEmpty(span: TextSpan): boolean;
        function textSpanContainsPosition(span: TextSpan, position: number): boolean;
        function textRangeContainsPositionInclusive(range: TextRange, position: number): boolean;
        function textSpanContainsTextSpan(span: TextSpan, other: TextSpan): boolean;
        function textSpanContainsTextRange(span: TextSpan, range: TextRange): boolean;
        function textRangeContainsTextSpan(range: TextRange, span: TextSpan): boolean;
        function textSpanOverlapsWith(span: TextSpan, other: TextSpan): boolean;
        function textSpanOverlap(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
        function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): boolean;
        function textSpanIntersectsWith(span: TextSpan, start: number, length: number): boolean;
        function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number): boolean;
        function textSpanIntersectsWithPosition(span: TextSpan, position: number): boolean;
        function textRangeIntersectsWithTextSpan(range: TextRange, span: TextSpan): boolean;
        function textSpanIntersection(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
        function normalizeSpans(spans: readonly TextSpan[]): TextSpan[];
        function createTextSpan(start: number, length: number): TextSpan;
        function createTextSpanFromBounds(start: number, end: number): TextSpan;
        function textChangeRangeNewSpan(range: TextChangeRange): TextSpan;
        function textChangeRangeIsUnchanged(range: TextChangeRange): boolean;
        function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange;
        function collapseTextChangeRangesAcrossMultipleVersions(changes: readonly TextChangeRange[]): TextChangeRange;
        function getTypeParameterOwner(d: Declaration): Declaration | undefined;
        function isParameterPropertyDeclaration(node: Node, parent: Node): node is ParameterPropertyDeclaration;
        function isEmptyBindingPattern(node: BindingName): node is BindingPattern;
        function isEmptyBindingElement(node: BindingElement | ArrayBindingElement): boolean;
        function walkUpBindingElementsAndPatterns(binding: BindingElement): VariableDeclaration | ParameterDeclaration;
        function getCombinedModifierFlags(node: Declaration): ModifierFlags;
        function getCombinedNodeFlagsAlwaysIncludeJSDoc(node: Declaration): ModifierFlags;
        function getCombinedNodeFlags(node: Node): NodeFlags;
        function validateLocaleAndSetLanguage(locale: string, sys: {
            getExecutingFilePath(): string;
            resolvePath(path: string): string;
            fileExists(fileName: string): boolean;
            readFile(fileName: string): string | undefined;
        }, errors?: Diagnostic[]): void;
        function getOriginalNode(node: Node): Node;
        function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T;
        function getOriginalNode(node: Node | undefined): Node | undefined;
        function getOriginalNode<T extends Node>(node: Node | undefined, nodeTest: (node: Node) => node is T): T | undefined;
        function findAncestor<T extends Node>(node: Node | undefined, callback: (element: Node) => element is T): T | undefined;
        function findAncestor(node: Node | undefined, callback: (element: Node) => boolean | "quit"): Node | undefined;
        function isParseTreeNode(node: Node): boolean;
        function getParseTreeNode(node: Node | undefined): Node | undefined;
        function getParseTreeNode<T extends Node>(node: T | undefined, nodeTest?: (node: Node) => node is T): T | undefined;
        function escapeLeadingUnderscores(identifier: string): __String;
        function unescapeLeadingUnderscores(identifier: __String): string;
        function idText(identifierOrPrivateName: Identifier | PrivateIdentifier): string;
        function identifierToKeywordKind(node: Identifier): KeywordSyntaxKind | undefined;
        function symbolName(symbol: Symbol): string;
        function nodeHasName(statement: Node, name: Identifier): boolean;
        function getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | PrivateIdentifier | undefined;
        function isNamedDeclaration(node: Node): node is NamedDeclaration & {
            name: DeclarationName;
        };
        function getNonAssignedNameOfDeclaration(declaration: Declaration | Expression): DeclarationName | undefined;
        function getNameOfDeclaration(declaration: Declaration | Expression | undefined): DeclarationName | undefined;
        function getAssignedName(node: Node): DeclarationName | undefined;
        function getDecorators(node: HasDecorators): readonly Decorator[] | undefined;
        function getModifiers(node: HasModifiers): readonly Modifier[] | undefined;
        function getJSDocParameterTags(param: ParameterDeclaration): readonly JSDocParameterTag[];
        function getJSDocParameterTagsNoCache(param: ParameterDeclaration): readonly JSDocParameterTag[];
        function getJSDocTypeParameterTags(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];
        function getJSDocTypeParameterTagsNoCache(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];
        function hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean;
        function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined;
        function getJSDocImplementsTags(node: Node): readonly JSDocImplementsTag[];
        function getJSDocClassTag(node: Node): JSDocClassTag | undefined;
        function getJSDocPublicTag(node: Node): JSDocPublicTag | undefined;
        function getJSDocPublicTagNoCache(node: Node): JSDocPublicTag | undefined;
        function getJSDocPrivateTag(node: Node): JSDocPrivateTag | undefined;
        function getJSDocPrivateTagNoCache(node: Node): JSDocPrivateTag | undefined;
        function getJSDocProtectedTag(node: Node): JSDocProtectedTag | undefined;
        function getJSDocProtectedTagNoCache(node: Node): JSDocProtectedTag | undefined;
        function getJSDocReadonlyTag(node: Node): JSDocReadonlyTag | undefined;
        function getJSDocReadonlyTagNoCache(node: Node): JSDocReadonlyTag | undefined;
        function getJSDocOverrideTagNoCache(node: Node): JSDocOverrideTag | undefined;
        function getJSDocDeprecatedTag(node: Node): JSDocDeprecatedTag | undefined;
        function getJSDocDeprecatedTagNoCache(node: Node): JSDocDeprecatedTag | undefined;
        function getJSDocEnumTag(node: Node): JSDocEnumTag | undefined;
        function getJSDocThisTag(node: Node): JSDocThisTag | undefined;
        function getJSDocReturnTag(node: Node): JSDocReturnTag | undefined;
        function getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined;
        function getJSDocSatisfiesTag(node: Node): JSDocSatisfiesTag | undefined;
        function getJSDocTypeTag(node: Node): JSDocTypeTag | undefined;
        function getJSDocType(node: Node): TypeNode | undefined;
        function getJSDocReturnType(node: Node): TypeNode | undefined;
        function getJSDocTags(node: Node): readonly JSDocTag[];
        function getAllJSDocTags<T extends JSDocTag>(node: Node, predicate: (tag: JSDocTag) => tag is T): readonly T[];
        function getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): readonly JSDocTag[];
        function getTextOfJSDocComment(comment?: string | NodeArray<JSDocComment>): string | undefined;
        function getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];
        function getEffectiveConstraintOfTypeParameter(node: TypeParameterDeclaration): TypeNode | undefined;
        function isMemberName(node: Node): node is MemberName;
        function isGetOrSetAccessorDeclaration(node: Node): node is AccessorDeclaration;
        function isPropertyAccessChain(node: Node): node is PropertyAccessChain;
        function isElementAccessChain(node: Node): node is ElementAccessChain;
        function isCallChain(node: Node): node is CallChain;
        function isOptionalChain(node: Node): node is PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;
        function isOptionalChainRoot(node: Node): node is OptionalChainRoot;
        function isExpressionOfOptionalChainRoot(node: Node): node is Expression & {
            parent: OptionalChainRoot;
        };
        function isOutermostOptionalChain(node: OptionalChain): boolean;
        function isNullishCoalesce(node: Node): boolean;
        function isConstTypeReference(node: Node): boolean;
        function skipPartiallyEmittedExpressions(node: Expression): Expression;
        function skipPartiallyEmittedExpressions(node: Node): Node;
        function isNonNullChain(node: Node): node is NonNullChain;
        function isBreakOrContinueStatement(node: Node): node is BreakOrContinueStatement;
        function isNamedExportBindings(node: Node): node is NamedExportBindings;
        function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag;
        function isNodeKind(kind: SyntaxKind): boolean;
        function isTokenKind(kind: SyntaxKind): boolean;
        function isToken(n: Node): boolean;
        function isNodeArray<T extends Node>(array: readonly T[]): array is NodeArray<T>;
        function isLiteralKind(kind: SyntaxKind): kind is LiteralToken["kind"];
        function isLiteralExpression(node: Node): node is LiteralExpression;
        function isLiteralExpressionOfObject(node: Node): boolean;
        function isTemplateLiteralKind(kind: SyntaxKind): kind is TemplateLiteralToken["kind"];
        function isTemplateLiteralToken(node: Node): node is TemplateLiteralToken;
        function isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail;
        function isImportOrExportSpecifier(node: Node): node is ImportSpecifier | ExportSpecifier;
        function isTypeOnlyImportDeclaration(node: Node): node is TypeOnlyImportDeclaration;
        function isTypeOnlyExportDeclaration(node: Node): node is TypeOnlyExportDeclaration;
        function isTypeOnlyImportOrExportDeclaration(node: Node): node is TypeOnlyAliasDeclaration;
        function isPartOfTypeOnlyImportOrExportDeclaration(node: Node): boolean;
        function isStringTextContainingNode(node: Node): node is StringLiteral | TemplateLiteralToken;
        function isImportAttributeName(node: Node): node is ImportAttributeName;
        function isGeneratedIdentifier(node: Node): node is GeneratedIdentifier;
        function isGeneratedPrivateIdentifier(node: Node): node is GeneratedPrivateIdentifier;
        function isFileLevelReservedGeneratedIdentifier(node: GeneratedIdentifier): boolean;
        function isPrivateIdentifierClassElementDeclaration(node: Node): node is PrivateClassElementDeclaration;
        function isPrivateIdentifierPropertyAccessExpression(node: Node): node is PrivateIdentifierPropertyAccessExpression;
        function isModifierKind(token: SyntaxKind): token is Modifier["kind"];
        function isParameterPropertyModifier(kind: SyntaxKind): boolean;
        function isClassMemberModifier(idToken: SyntaxKind): boolean;
        function isModifier(node: Node): node is Modifier;
        function isEntityName(node: Node): node is EntityName;
        function isPropertyName(node: Node): node is PropertyName;
        function isBindingName(node: Node): node is BindingName;
        function isFunctionLike(node: Node | undefined): node is SignatureDeclaration;
        function isFunctionLikeOrClassStaticBlockDeclaration(node: Node | undefined): node is SignatureDeclaration | ClassStaticBlockDeclaration;
        function isFunctionLikeDeclaration(node: Node): node is FunctionLikeDeclaration;
        function isBooleanLiteral(node: Node): node is BooleanLiteral;
        function isFunctionLikeKind(kind: SyntaxKind): boolean;
        function isFunctionOrModuleBlock(node: Node): boolean;
        function isClassElement(node: Node): node is ClassElement;
        function isClassLike(node: Node): node is ClassLikeDeclaration;
        function isAccessor(node: Node): node is AccessorDeclaration;
        function isAutoAccessorPropertyDeclaration(node: Node): node is AutoAccessorPropertyDeclaration;
        function isClassInstanceProperty(node: Declaration): boolean;
        function isMethodOrAccessor(node: Node): node is MethodDeclaration | AccessorDeclaration;
        function isModifierLike(node: Node): node is ModifierLike;
        function isTypeElement(node: Node): node is TypeElement;
        function isClassOrTypeElement(node: Node): node is ClassElement | TypeElement;
        function isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike;
        function isTypeNode(node: Node): node is TypeNode;
        function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode;
        function isBindingPattern(node: Node | undefined): node is BindingPattern;
        function isAssignmentPattern(node: Node): node is AssignmentPattern;
        function isArrayBindingElement(node: Node): node is ArrayBindingElement;
        function isDeclarationBindingElement(bindingElement: BindingOrAssignmentElement): bindingElement is VariableDeclaration | ParameterDeclaration | BindingElement;
        function isBindingOrAssignmentElement(node: Node): node is BindingOrAssignmentElement;
        function isBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is BindingOrAssignmentPattern;
        function isObjectBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is ObjectBindingOrAssignmentPattern;
        function isObjectBindingOrAssignmentElement(node: Node): node is ObjectBindingOrAssignmentElement;
        function isArrayBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is ArrayBindingOrAssignmentPattern;
        function isArrayBindingOrAssignmentElement(node: Node): node is ArrayBindingOrAssignmentElement;
        function isPropertyAccessOrQualifiedNameOrImportTypeNode(node: Node): node is PropertyAccessExpression | QualifiedName | ImportTypeNode;
        function isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName;
        function isCallLikeOrFunctionLikeExpression(node: Node): node is CallLikeExpression | FunctionExpression | ArrowFunction;
        function isCallLikeExpression(node: Node): node is CallLikeExpression;
        function isCallOrNewExpression(node: Node): node is CallExpression | NewExpression;
        function isTemplateLiteral(node: Node): node is TemplateLiteral;
        function isLeftHandSideExpression(node: Node): node is LeftHandSideExpression;
        function isUnaryExpression(node: Node): node is UnaryExpression;
        function isUnaryExpressionWithWrite(expr: Node): expr is PrefixUnaryExpression | PostfixUnaryExpression;
        function isLiteralTypeLiteral(node: Node): node is NullLiteral | BooleanLiteral | LiteralExpression | PrefixUnaryExpression;
        function isExpression(node: Node): node is Expression;
        function isAssertionExpression(node: Node): node is AssertionExpression;
        function isIterationStatement(node: Node, lookInLabeledStatements: false): node is IterationStatement;
        function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement;
        function hasScopeMarker(statements: readonly Statement[]): boolean;
        function needsScopeMarker(result: Statement): boolean;
        function isExternalModuleIndicator(result: Statement): boolean;
        function isForInOrOfStatement(node: Node): node is ForInOrOfStatement;
        function isConciseBody(node: Node): node is ConciseBody;
        function isFunctionBody(node: Node): node is FunctionBody;
        function isForInitializer(node: Node): node is ForInitializer;
        function isModuleBody(node: Node): node is ModuleBody;
        function isNamespaceBody(node: Node): node is NamespaceBody;
        function isJSDocNamespaceBody(node: Node): node is JSDocNamespaceBody;
        function isNamedImportBindings(node: Node): node is NamedImportBindings;
        function isModuleOrEnumDeclaration(node: Node): node is ModuleDeclaration | EnumDeclaration;
        function canHaveSymbol(node: Node): node is Declaration;
        function canHaveLocals(node: Node): node is HasLocals;
        function isDeclaration(node: Node): node is NamedDeclaration;
        function isDeclarationStatement(node: Node): node is DeclarationStatement;
        function isStatementButNotDeclaration(node: Node): node is Statement;
        function isStatement(node: Node): node is Statement;
        function isStatementOrBlock(node: Node): node is Statement | Block;
        function isModuleReference(node: Node): node is ModuleReference;
        function isJsxTagNameExpression(node: Node): node is JsxTagNameExpression;
        function isJsxChild(node: Node): node is JsxChild;
        function isJsxAttributeLike(node: Node): node is JsxAttributeLike;
        function isStringLiteralOrJsxExpression(node: Node): node is StringLiteral | JsxExpression;
        function isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement;
        function isJsxCallLike(node: Node): node is JsxCallLike;
        function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause;
        function isJSDocNode(node: Node): boolean;
        function isJSDocCommentContainingNode(node: Node): boolean;
        function isJSDocTag(node: Node): node is JSDocTag;
        function isSetAccessor(node: Node): node is SetAccessorDeclaration;
        function isGetAccessor(node: Node): node is GetAccessorDeclaration;
        function hasJSDocNodes(node: Node): node is HasJSDoc;
        function hasType(node: Node): node is HasType;
        function hasInitializer(node: Node): node is HasInitializer;
        function hasOnlyExpressionInitializer(node: Node): node is HasExpressionInitializer;
        function isObjectLiteralElement(node: Node): node is ObjectLiteralElement;
        function isTypeReferenceType(node: Node): node is TypeReferenceType;
        function guessIndentation(lines: string[]): number | undefined;
        function isStringLiteralLike(node: Node | FileReference): node is StringLiteralLike;
        function isJSDocLinkLike(node: Node): node is JSDocLink | JSDocLinkCode | JSDocLinkPlain;
        function hasRestParameter(s: SignatureDeclaration | JSDocSignature): boolean;
        function isRestParameter(node: ParameterDeclaration | JSDocParameterTag): boolean;
        function isInternalDeclaration(node: Node, sourceFile?: SourceFile): boolean;
        const targetToLibMap: Map<ScriptTarget, string>;
        const unchangedTextChangeRange: TextChangeRange;
        type ParameterPropertyDeclaration = ParameterDeclaration & {
            parent: ConstructorDeclaration;
            name: Identifier;
        };
        const supportedLocaleDirectories: readonly [
            "cs",
            "de",
            "es",
            "fr",
            "it",
            "ja",
            "ko",
            "pl",
            "pt-br",
            "ru",
            "tr",
            "zh-cn",
            "zh-tw"
        ];
        function getDeclarationOfKind<T extends Declaration>(symbol: Symbol, kind: T["kind"]): T | undefined;
        function getDeclarationsOfKind<T extends Declaration>(symbol: Symbol, kind: T["kind"]): T[];
        function createSymbolTable(symbols?: readonly Symbol[]): SymbolTable;
        function isTransientSymbol(symbol: Symbol): symbol is TransientSymbol;
        function isExternalModuleSymbol(moduleSymbol: Symbol): boolean;
        function changesAffectModuleResolution(oldOptions: CompilerOptions, newOptions: CompilerOptions): boolean;
        function changesAffectingProgramStructure(oldOptions: CompilerOptions, newOptions: CompilerOptions): boolean;
        function optionsHaveChanges(oldOptions: CompilerOptions, newOptions: CompilerOptions, optionDeclarations: readonly CommandLineOption[]): boolean;
        function forEachAncestor<T>(node: Node, callback: (n: Node) => T | undefined | "quit"): T | undefined;
        function forEachEntry<K, V, U>(map: ReadonlyMap<K, V>, callback: (value: V, key: K) => U | undefined): U | undefined;
        function forEachKey<K, T>(map: ReadonlyCollection<K>, callback: (key: K) => T | undefined): T | undefined;
        function copyEntries<K, V>(source: ReadonlyMap<K, V>, target: Map<K, V>): void;
        function usingSingleLineStringWriter(action: (writer: EmitTextWriter) => void): string;
        function getFullWidth(node: Node): number;
        function projectReferenceIsEqualTo(oldRef: ProjectReference, newRef: ProjectReference): boolean;
        function moduleResolutionIsEqualTo(oldResolution: ResolvedModuleWithFailedLookupLocations, newResolution: ResolvedModuleWithFailedLookupLocations): boolean;
        function getResolvedModuleFromResolution(resolution: ResolvedModuleWithFailedLookupLocations): ResolvedModuleFull | undefined;
        function getResolvedTypeReferenceDirectiveFromResolution(resolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations): ResolvedTypeReferenceDirective | undefined;
        function createModuleNotFoundChain(sourceFile: SourceFile, host: TypeCheckerHost, moduleReference: string, mode: ResolutionMode, packageName: string): DiagnosticMessageChain;
        function createModeMismatchDetails(currentSourceFile: SourceFile): DiagnosticMessageChain;
        function packageIdToPackageName({ name, subModuleName }: PackageId): string;
        function packageIdToString(packageId: PackageId): string;
        function typeDirectiveIsEqualTo(oldResolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, newResolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations): boolean;
        function hasChangesInResolutions<K, V>(names: readonly K[], newResolutions: readonly V[], getOldResolution: (name: K) => V | undefined, comparer: (oldResolution: V, newResolution: V) => boolean): boolean;
        function containsParseError(node: Node): boolean;
        function getSourceFileOfNode(node: Node): SourceFile;
        function getSourceFileOfNode(node: Node | undefined): SourceFile | undefined;
        function getSourceFileOfModule(module: Symbol): SourceFile | undefined;
        function isPlainJsFile(file: SourceFile | undefined, checkJs: boolean | undefined): boolean;
        function isStatementWithLocals(node: Node): boolean;
        function getStartPositionOfLine(line: number, sourceFile: SourceFileLike): number;
        function nodePosToString(node: Node): string;
        function getEndLinePosition(line: number, sourceFile: SourceFileLike): number;
        function isFileLevelUniqueName(sourceFile: SourceFile, name: string, hasGlobalName?: PrintHandlers["hasGlobalName"]): boolean;
        function nodeIsMissing(node: Node | undefined): boolean;
        function nodeIsPresent(node: Node | undefined): boolean;
        function isGrammarError(parent: Node, child: Node | NodeArray<Node>): boolean;
        function insertStatementsAfterStandardPrologue<T extends Statement>(to: T[], from: readonly T[] | undefined): T[];
        function insertStatementsAfterCustomPrologue<T extends Statement>(to: T[], from: readonly T[] | undefined): T[];
        function insertStatementAfterStandardPrologue<T extends Statement>(to: T[], statement: T | undefined): T[];
        function insertStatementAfterCustomPrologue<T extends Statement>(to: T[], statement: T | undefined): T[];
        function isRecognizedTripleSlashComment(text: string, commentPos: number, commentEnd: number): boolean;
        function isPinnedComment(text: string, start: number): boolean;
        function createCommentDirectivesMap(sourceFile: SourceFile, commentDirectives: CommentDirective[]): CommentDirectivesMap;
        function getTokenPosOfNode(node: Node, sourceFile?: SourceFileLike, includeJsDoc?: boolean): number;
        function getNonDecoratorTokenPosOfNode(node: Node, sourceFile?: SourceFileLike): number;
        function getNonModifierTokenPosOfNode(node: Node, sourceFile?: SourceFileLike): number;
        function getSourceTextOfNodeFromSourceFile(sourceFile: SourceFile, node: Node, includeTrivia?: boolean): string;
        function isExportNamespaceAsDefaultDeclaration(node: Node): boolean;
        function moduleExportNameTextUnescaped(node: ModuleExportName): string;
        function moduleExportNameTextEscaped(node: ModuleExportName): __String;
        function moduleExportNameIsDefault(node: ModuleExportName): boolean;
        function getTextOfNodeFromSourceText(sourceText: string, node: Node, includeTrivia?: boolean): string;
        function getTextOfNode(node: Node, includeTrivia?: boolean): string;
        function indexOfNode(nodeArray: readonly Node[], node: Node): number;
        function getEmitFlags(node: Node): EmitFlags;
        function getInternalEmitFlags(node: Node): InternalEmitFlags;
        function getLiteralText(node: LiteralLikeNode, sourceFile: SourceFile | undefined, flags: GetLiteralTextFlags): string;
        function getTextOfConstantValue(value: string | number): string;
        function makeIdentifierFromModuleName(moduleName: string): string;
        function isBlockOrCatchScoped(declaration: Declaration): boolean;
        function isCatchClauseVariableDeclarationOrBindingElement(declaration: Declaration): boolean;
        function isAmbientModule(node: Node): node is AmbientModuleDeclaration;
        function isModuleWithStringLiteralName(node: Node): node is ModuleDeclaration;
        function isNonGlobalAmbientModule(node: Node): node is ModuleDeclaration & {
            name: StringLiteral;
        };
        function isShorthandAmbientModuleSymbol(moduleSymbol: Symbol): boolean;
        function isBlockScopedContainerTopLevel(node: Node): boolean;
        function isGlobalScopeAugmentation(module: ModuleDeclaration): boolean;
        function isExternalModuleAugmentation(node: Node): node is AmbientModuleDeclaration;
        function isModuleAugmentationExternal(node: AmbientModuleDeclaration): boolean;
        function getNonAugmentationDeclaration(symbol: Symbol): Declaration | undefined;
        function isEffectiveExternalModule(node: SourceFile, compilerOptions: CompilerOptions): boolean;
        function isEffectiveStrictModeSourceFile(node: SourceFile, compilerOptions: CompilerOptions): boolean;
        function isAmbientPropertyDeclaration(node: PropertyDeclaration): boolean;
        function isBlockScope(node: Node, parentNode: Node | undefined): boolean;
        function isDeclarationWithTypeParameters(node: Node): node is DeclarationWithTypeParameters;
        function isDeclarationWithTypeParameterChildren(node: Node): node is DeclarationWithTypeParameterChildren;
        function isAnyImportSyntax(node: Node): node is AnyImportSyntax;
        function isAnyImportOrBareOrAccessedRequire(node: Node): node is AnyImportOrBareOrAccessedRequire;
        function isAnyImportOrRequireStatement(node: Node): node is AnyImportOrRequireStatement;
        function isLateVisibilityPaintedStatement(node: Node): node is LateVisibilityPaintedStatement;
        function hasPossibleExternalModuleReference(node: Node): node is AnyImportOrReExport | ModuleDeclaration | ImportTypeNode | ImportCall;
        function isAnyImportOrReExport(node: Node): node is AnyImportOrReExport;
        function getEnclosingContainer(node: Node): Node | undefined;
        function getEnclosingBlockScopeContainer(node: Node): Node;
        function forEachEnclosingBlockScopeContainer(node: Node, cb: (container: Node) => void): void;
        function declarationNameToString(name: DeclarationName | QualifiedName | undefined): string;
        function getNameFromIndexInfo(info: IndexInfo): string | undefined;
        function isComputedNonLiteralName(name: PropertyName): boolean;
        function tryGetTextOfPropertyName(name: PropertyName | NoSubstitutionTemplateLiteral | JsxAttributeName): __String | undefined;
        function getTextOfPropertyName(name: PropertyName | NoSubstitutionTemplateLiteral | JsxAttributeName): __String;
        function entityNameToString(name: EntityNameOrEntityNameExpression | JSDocMemberName | JsxTagNameExpression | PrivateIdentifier): string;
        function createDiagnosticForNode(node: Node, message: DiagnosticMessage, ...args: DiagnosticArguments): DiagnosticWithLocation;
        function createDiagnosticForNodeArray(sourceFile: SourceFile, nodes: NodeArray<Node>, message: DiagnosticMessage, ...args: DiagnosticArguments): DiagnosticWithLocation;
        function createDiagnosticForNodeInSourceFile(sourceFile: SourceFile, node: Node, message: DiagnosticMessage, ...args: DiagnosticArguments): DiagnosticWithLocation;
        function createDiagnosticForNodeFromMessageChain(sourceFile: SourceFile, node: Node, messageChain: DiagnosticMessageChain, relatedInformation?: DiagnosticRelatedInformation[]): DiagnosticWithLocation;
        function createDiagnosticForNodeArrayFromMessageChain(sourceFile: SourceFile, nodes: NodeArray<Node>, messageChain: DiagnosticMessageChain, relatedInformation?: DiagnosticRelatedInformation[]): DiagnosticWithLocation;
        function createFileDiagnosticFromMessageChain(file: SourceFile, start: number, length: number, messageChain: DiagnosticMessageChain, relatedInformation?: DiagnosticRelatedInformation[]): DiagnosticWithLocation;
        function createDiagnosticForFileFromMessageChain(sourceFile: SourceFile, messageChain: DiagnosticMessageChain, relatedInformation?: DiagnosticRelatedInformation[]): DiagnosticWithLocation;
        function createDiagnosticMessageChainFromDiagnostic(diagnostic: DiagnosticRelatedInformation): DiagnosticMessageChain;
        function createDiagnosticForRange(sourceFile: SourceFile, range: TextRange, message: DiagnosticMessage): DiagnosticWithLocation;
        function getCanonicalDiagnostic(message: DiagnosticMessage, ...args: string[]): CanonicalDiagnostic;
        function getSpanOfTokenAtPosition(sourceFile: SourceFile, pos: number): TextSpan;
        function scanTokenAtPosition(sourceFile: SourceFile, pos: number): SyntaxKind;
        function getErrorSpanForNode(sourceFile: SourceFile, node: Node): TextSpan;
        function isGlobalSourceFile(node: Node): boolean;
        function isExternalOrCommonJsModule(file: SourceFile): boolean;
        function isJsonSourceFile(file: SourceFile): file is JsonSourceFile;
        function isEnumConst(node: EnumDeclaration): boolean;
        function isDeclarationReadonly(declaration: Declaration): boolean;
        function isVarAwaitUsing(node: VariableDeclaration | VariableDeclarationList): boolean;
        function isVarUsing(node: VariableDeclaration | VariableDeclarationList): boolean;
        function isVarConst(node: VariableDeclaration | VariableDeclarationList): boolean;
        function isVarConstLike(node: VariableDeclaration | VariableDeclarationList): boolean;
        function isLet(node: Node): boolean;
        function isSuperCall(n: Node): n is SuperCall;
        function isImportCall(n: Node): n is ImportCall;
        function isImportMeta(n: Node): n is ImportMetaProperty;
        function isLiteralImportTypeNode(n: Node): n is LiteralImportTypeNode;
        function isPrologueDirective(node: Node): node is PrologueDirective;
        function isCustomPrologue(node: Statement): boolean;
        function isHoistedFunction(node: Statement): boolean;
        function isHoistedVariableStatement(node: Statement): boolean;
        function getLeadingCommentRangesOfNode(node: Node, sourceFileOfNode: SourceFile): CommentRange[] | undefined;
        function getJSDocCommentRanges(node: Node, text: string): CommentRange[] | undefined;
        function isPartOfTypeNode(node: Node): boolean;
        function forEachReturnStatement<T>(body: Block | Statement, visitor: (stmt: ReturnStatement) => T): T | undefined;
        function forEachYieldExpression(body: Block, visitor: (expr: YieldExpression) => void): void;
        function getRestParameterElementType(node: TypeNode | undefined): TypeNode | undefined;
        function getMembersOfDeclaration(node: Declaration): NodeArray<ClassElement | TypeElement | ObjectLiteralElement> | undefined;
        function isVariableLike(node: Node): node is VariableLikeDeclaration;
        function isVariableDeclarationInVariableStatement(node: VariableDeclaration): boolean;
        function isCommonJsExportedExpression(node: Node): boolean;
        function isCommonJsExportPropertyAssignment(node: Node): boolean;
        function isValidESSymbolDeclaration(node: Node): boolean;
        function introducesArgumentsExoticObject(node: Node): boolean;
        function unwrapInnermostStatementOfLabel(node: LabeledStatement, beforeUnwrapLabelCallback?: (node: LabeledStatement) => void): Statement;
        function isFunctionBlock(node: Node): boolean;
        function isObjectLiteralMethod(node: Node): node is MethodDeclaration;
        function isObjectLiteralOrClassExpressionMethodOrAccessor(node: Node): node is MethodDeclaration | AccessorDeclaration;
        function isIdentifierTypePredicate(predicate: TypePredicate): predicate is IdentifierTypePredicate;
        function isThisTypePredicate(predicate: TypePredicate): predicate is ThisTypePredicate;
        function forEachPropertyAssignment<T>(objectLiteral: ObjectLiteralExpression | undefined, key: string, callback: (property: PropertyAssignment) => T | undefined, key2?: string): T | undefined;
        function getTsConfigObjectLiteralExpression(tsConfigSourceFile: TsConfigSourceFile | undefined): ObjectLiteralExpression | undefined;
        function getTsConfigPropArrayElementValue(tsConfigSourceFile: TsConfigSourceFile | undefined, propKey: string, elementValue: string): StringLiteral | undefined;
        function forEachTsConfigPropArray<T>(tsConfigSourceFile: TsConfigSourceFile | undefined, propKey: string, callback: (property: PropertyAssignment) => T | undefined): T | undefined;
        function getContainingFunction(node: Node): SignatureDeclaration | undefined;
        function getContainingFunctionDeclaration(node: Node): FunctionLikeDeclaration | undefined;
        function getContainingClass(node: Node): ClassLikeDeclaration | undefined;
        function getContainingClassStaticBlock(node: Node): Node | undefined;
        function getContainingFunctionOrClassStaticBlock(node: Node): SignatureDeclaration | ClassStaticBlockDeclaration | undefined;
        function getContainingClassExcludingClassDecorators(node: Node): ClassLikeDeclaration | undefined;
        function getThisContainer(node: Node, includeArrowFunctions: false, includeClassComputedPropertyName: false): ThisContainer;
        function getThisContainer(node: Node, includeArrowFunctions: false, includeClassComputedPropertyName: boolean): ThisContainer | ComputedPropertyName;
        function getThisContainer(node: Node, includeArrowFunctions: boolean, includeClassComputedPropertyName: false): ThisContainer | ArrowFunction;
        function getThisContainer(node: Node, includeArrowFunctions: boolean, includeClassComputedPropertyName: boolean): ThisContainer | ArrowFunction | ComputedPropertyName;
        function isThisContainerOrFunctionBlock(node: Node): boolean;
        function isInTopLevelContext(node: Node): boolean;
        function getNewTargetContainer(node: Node): FunctionDeclaration | ConstructorDeclaration | FunctionExpression | undefined;
        function getSuperContainer(node: Node, stopOnFunctions: false): SuperContainer | undefined;
        function getSuperContainer(node: Node, stopOnFunctions: boolean): SuperContainerOrFunctions | undefined;
        function getImmediatelyInvokedFunctionExpression(func: Node): CallExpression | undefined;
        function isSuperProperty(node: Node): node is SuperProperty;
        function isThisProperty(node: Node): boolean;
        function isThisInitializedDeclaration(node: Node | undefined): boolean;
        function isThisInitializedObjectBindingExpression(node: Node | undefined): boolean;
        function getEntityNameFromTypeNode(node: TypeNode): EntityNameOrEntityNameExpression | undefined;
        function getInvokedExpression(node: CallLikeExpression): Expression | JsxTagNameExpression;
        function nodeCanBeDecorated(useLegacyDecorators: boolean, node: ClassDeclaration): true;
        function nodeCanBeDecorated(useLegacyDecorators: boolean, node: ClassExpression): boolean;
        function nodeCanBeDecorated(useLegacyDecorators: boolean, node: ClassElement, parent: Node): boolean;
        function nodeCanBeDecorated(useLegacyDecorators: boolean, node: Node, parent: Node, grandparent: Node): boolean;
        function nodeIsDecorated(useLegacyDecorators: boolean, node: ClassDeclaration | ClassExpression): boolean;
        function nodeIsDecorated(useLegacyDecorators: boolean, node: ClassElement, parent: Node): boolean;
        function nodeIsDecorated(useLegacyDecorators: boolean, node: Node, parent: Node, grandparent: Node): boolean;
        function nodeOrChildIsDecorated(useLegacyDecorators: boolean, node: ClassDeclaration | ClassExpression): boolean;
        function nodeOrChildIsDecorated(useLegacyDecorators: boolean, node: ClassElement, parent: Node): boolean;
        function nodeOrChildIsDecorated(useLegacyDecorators: boolean, node: Node, parent: Node, grandparent: Node): boolean;
        function childIsDecorated(useLegacyDecorators: boolean, node: ClassDeclaration | ClassExpression): boolean;
        function childIsDecorated(useLegacyDecorators: boolean, node: Node, parent: Node): boolean;
        function classOrConstructorParameterIsDecorated(useLegacyDecorators: boolean, node: ClassDeclaration | ClassExpression): boolean;
        function classElementOrClassElementParameterIsDecorated(useLegacyDecorators: boolean, node: ClassElement, parent: ClassDeclaration | ClassExpression): boolean;
        function isEmptyStringLiteral(node: StringLiteral): boolean;
        function isJSXTagName(node: Node): boolean;
        function isExpressionNode(node: Node): boolean;
        function isInExpressionContext(node: Node): boolean;
        function isPartOfTypeQuery(node: Node): boolean;
        function isNamespaceReexportDeclaration(node: Node): boolean;
        function isExternalModuleImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration & {
            moduleReference: ExternalModuleReference;
        };
        function getExternalModuleImportEqualsDeclarationExpression(node: Node): Expression;
        function getExternalModuleRequireArgument(node: Node): false | StringLiteral;
        function isInternalModuleImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;
        function isFullSourceFile(sourceFile: object): sourceFile is SourceFile;
        function isSourceFileJS(file: SourceFile): boolean;
        function isInJSFile(node: Node | undefined): boolean;
        function isInJsonFile(node: Node | undefined): boolean;
        function isSourceFileNotJson(file: SourceFile): boolean;
        function isInJSDoc(node: Node | undefined): boolean;
        function isJSDocIndexSignature(node: TypeReferenceNode | ExpressionWithTypeArguments): boolean | undefined;
        function isRequireCall(callExpression: Node, requireStringLiteralLikeArgument: true): callExpression is RequireOrImportCall & {
            expression: Identifier;
            arguments: [
                StringLiteralLike
            ];
        };
        function isRequireCall(callExpression: Node, requireStringLiteralLikeArgument: boolean): callExpression is CallExpression;
        function isVariableDeclarationInitializedToRequire(node: Node): node is VariableDeclarationInitializedTo<RequireOrImportCall>;
        function isVariableDeclarationInitializedToBareOrAccessedRequire(node: Node): node is VariableDeclarationInitializedTo<RequireOrImportCall | AccessExpression>;
        function isBindingElementOfBareOrAccessedRequire(node: Node): node is BindingElementOfBareOrAccessedRequire;
        function isRequireVariableStatement(node: Node): node is RequireVariableStatement;
        function isSingleOrDoubleQuote(charCode: number): boolean;
        function isStringDoubleQuoted(str: StringLiteralLike, sourceFile: SourceFile): boolean;
        function isAssignmentDeclaration(decl: Declaration): boolean;
        function getEffectiveInitializer(node: HasExpressionInitializer): Expression | undefined;
        function getDeclaredExpandoInitializer(node: HasExpressionInitializer): Expression | undefined;
        function getAssignedExpandoInitializer(node: Node | undefined): Expression | undefined;
        function getExpandoInitializer(initializer: Node, isPrototypeAssignment: boolean): Expression | undefined;
        function isDefaultedExpandoInitializer(node: BinaryExpression): boolean | undefined;
        function getNameOfExpando(node: Declaration): DeclarationName | undefined;
        function isSameEntityName(name: Expression, initializer: Expression): boolean;
        function getRightMostAssignedExpression(node: Expression): Expression;
        function isExportsIdentifier(node: Node): boolean;
        function isModuleIdentifier(node: Node): boolean;
        function isModuleExportsAccessExpression(node: Node): node is LiteralLikeElementAccessExpression & {
            expression: Identifier;
        };
        function getAssignmentDeclarationKind(expr: BinaryExpression | CallExpression): AssignmentDeclarationKind;
        function isBindableObjectDefinePropertyCall(expr: CallExpression): expr is BindableObjectDefinePropertyCall;
        function isBindableStaticAccessExpression(node: Node, excludeThisKeyword?: boolean): node is BindableStaticAccessExpression;
        function isBindableStaticElementAccessExpression(node: Node, excludeThisKeyword?: boolean): node is BindableStaticElementAccessExpression;
        function isBindableStaticNameExpression(node: Node, excludeThisKeyword?: boolean): node is BindableStaticNameExpression;
        function getNameOrArgument(expr: PropertyAccessExpression | LiteralLikeElementAccessExpression): MemberName | (Expression & (NumericLiteral | StringLiteralLike));
        function getElementOrPropertyAccessArgumentExpressionOrName(node: AccessExpression): Identifier | PrivateIdentifier | StringLiteralLike | NumericLiteral | ElementAccessExpression | undefined;
        function getElementOrPropertyAccessName(node: LiteralLikeElementAccessExpression | PropertyAccessExpression): __String;
        function getElementOrPropertyAccessName(node: AccessExpression): __String | undefined;
        function getAssignmentDeclarationPropertyAccessKind(lhs: AccessExpression): AssignmentDeclarationKind;
        function getInitializerOfBinaryExpression(expr: BinaryExpression): Expression;
        function isPrototypePropertyAssignment(node: Node): node is PrototypePropertyAssignment;
        function isSpecialPropertyDeclaration(expr: PropertyAccessExpression | ElementAccessExpression): expr is PropertyAccessExpression | LiteralLikeElementAccessExpression;
        function setValueDeclaration(symbol: Symbol, node: Declaration): void;
        function isFunctionSymbol(symbol: Symbol | undefined): boolean | undefined;
        function canHaveModuleSpecifier(node: Node | undefined): node is CanHaveModuleSpecifier;
        function tryGetModuleSpecifierFromDeclaration(node: CanHaveModuleSpecifier | JSDocImportTag): StringLiteralLike | undefined;
        function importFromModuleSpecifier(node: StringLiteralLike): AnyValidImportOrReExport;
        function tryGetImportFromModuleSpecifier(node: StringLiteralLike): AnyValidImportOrReExport | undefined;
        function shouldRewriteModuleSpecifier(specifier: string, compilerOptions: CompilerOptions): boolean;
        function getExternalModuleName(node: AnyImportOrReExport | ImportTypeNode | ImportCall | ModuleDeclaration | JSDocImportTag): Expression | undefined;
        function getNamespaceDeclarationNode(node: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration): ImportEqualsDeclaration | NamespaceImport | NamespaceExport | undefined;
        function isDefaultImport(node: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration | JSDocImportTag): boolean;
        function forEachImportClauseDeclaration<T>(node: ImportClause, action: (declaration: ImportClause | NamespaceImport | ImportSpecifier) => T | undefined): T | undefined;
        function hasQuestionToken(node: Node): boolean;
        function isJSDocConstructSignature(node: Node): boolean;
        function isJSDocTypeAlias(node: Node): node is JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag;
        function isTypeAlias(node: Node): node is JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag | TypeAliasDeclaration;
        function getSingleVariableOfVariableStatement(node: Node): VariableDeclaration | undefined;
        function canHaveFlowNode(node: Node): node is HasFlowNode;
        function canHaveJSDoc(node: Node): node is HasJSDoc;
        function getJSDocCommentsAndTags(hostNode: Node): readonly (JSDoc | JSDocTag)[];
        function getJSDocCommentsAndTags(hostNode: Node, noCache?: boolean): readonly (JSDoc | JSDocTag)[];
        function getNextJSDocCommentLocation(node: Node): Node | undefined;
        function getParameterSymbolFromJSDoc(node: JSDocParameterTag): Symbol | undefined;
        function getEffectiveContainerForJSDocTemplateTag(node: JSDocTemplateTag): SignatureDeclaration | JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag | undefined;
        function getJSDocOverloadTags(node: Node): readonly JSDocOverloadTag[];
        function getHostSignatureFromJSDoc(node: Node): SignatureDeclaration | undefined;
        function getEffectiveJSDocHost(node: Node): Node | undefined;
        function getJSDocHost(node: Node): HasJSDoc | undefined;
        function getJSDocRoot(node: Node): JSDoc | undefined;
        function getTypeParameterFromJsDoc(node: TypeParameterDeclaration & {
            parent: JSDocTemplateTag;
        }): TypeParameterDeclaration | undefined;
        function hasTypeArguments(node: Node): node is HasTypeArguments;
        function getAssignmentTargetKind(node: Node): AssignmentKind;
        function isAssignmentTarget(node: Node): boolean;
        function isInCompoundLikeAssignment(node: Node): boolean;
        function isNodeWithPossibleHoistedDeclaration(node: Node): node is NodeWithPossibleHoistedDeclaration;
        function isValueSignatureDeclaration(node: Node): node is ValueSignatureDeclaration;
        function walkUpParenthesizedTypes(node: Node): Node;
        function walkUpParenthesizedExpressions(node: Node): Node;
        function walkUpParenthesizedTypesAndGetParentAndChild(node: Node): [
            ParenthesizedTypeNode | undefined,
            Node
        ];
        function skipTypeParentheses(node: TypeNode): TypeNode;
        function skipParentheses(node: Expression, excludeJSDocTypeAssertions?: boolean): Expression;
        function skipParentheses(node: Node, excludeJSDocTypeAssertions?: boolean): Node;
        function isDeleteTarget(node: Node): boolean;
        function isNodeDescendantOf(node: Node, ancestor: Node | undefined): boolean;
        function isDeclarationName(name: Node): boolean;
        function getDeclarationFromName(name: Node): Declaration | undefined;
        function isLiteralComputedPropertyDeclarationName(node: Node): boolean;
        function isIdentifierName(node: Identifier): boolean;
        function getAliasDeclarationFromName(node: EntityName): Declaration | undefined;
        function isAliasableExpression(e: Expression): boolean;
        function exportAssignmentIsAlias(node: ExportAssignment | BinaryExpression): boolean;
        function getExportAssignmentExpression(node: ExportAssignment | BinaryExpression): Expression;
        function getPropertyAssignmentAliasLikeExpression(node: PropertyAssignment | ShorthandPropertyAssignment | PropertyAccessExpression): Expression;
        function getEffectiveBaseTypeNode(node: ClassLikeDeclaration | InterfaceDeclaration): ExpressionWithTypeArguments | undefined;
        function getClassExtendsHeritageElement(node: ClassLikeDeclaration | InterfaceDeclaration): ExpressionWithTypeArguments | undefined;
        function getEffectiveImplementsTypeNodes(node: ClassLikeDeclaration): undefined | readonly ExpressionWithTypeArguments[];
        function getAllSuperTypeNodes(node: Node): readonly TypeNode[];
        function getInterfaceBaseTypeNodes(node: InterfaceDeclaration): NodeArray<ExpressionWithTypeArguments> | undefined;
        function getHeritageClause(clauses: NodeArray<HeritageClause> | undefined, kind: SyntaxKind): HeritageClause | undefined;
        function getAncestor(node: Node | undefined, kind: SyntaxKind): Node | undefined;
        function isKeyword(token: SyntaxKind): token is KeywordSyntaxKind;
        function isPunctuation(token: SyntaxKind): token is PunctuationSyntaxKind;
        function isKeywordOrPunctuation(token: SyntaxKind): token is PunctuationOrKeywordSyntaxKind;
        function isContextualKeyword(token: SyntaxKind): boolean;
        function isNonContextualKeyword(token: SyntaxKind): boolean;
        function isStringANonContextualKeyword(name: string): boolean;
        function isIdentifierANonContextualKeyword(node: Identifier): boolean;
        function isTrivia(token: SyntaxKind): token is TriviaSyntaxKind;
        function getFunctionFlags(node: SignatureDeclaration | undefined): FunctionFlags;
        function isAsyncFunction(node: Node): boolean;
        function isStringOrNumericLiteralLike(node: Node): node is StringLiteralLike | NumericLiteral;
        function isSignedNumericLiteral(node: Node): node is PrefixUnaryExpression & {
            operand: NumericLiteral;
        };
        function hasDynamicName(declaration: Declaration): declaration is DynamicNamedDeclaration | DynamicNamedBinaryExpression;
        function isDynamicName(name: DeclarationName): boolean;
        function getPropertyNameForPropertyNameNode(name: PropertyName | JsxAttributeName): __String | undefined;
        function isPropertyNameLiteral(node: Node): node is PropertyNameLiteral;
        function getTextOfIdentifierOrLiteral(node: PropertyNameLiteral | PrivateIdentifier): string;
        function getEscapedTextOfIdentifierOrLiteral(node: PropertyNameLiteral): __String;
        function getSymbolNameForPrivateIdentifier(containingClassSymbol: Symbol, description: __String): __String;
        function isKnownSymbol(symbol: Symbol): boolean;
        function isPrivateIdentifierSymbol(symbol: Symbol): boolean;
        function isNamedEvaluationSource(node: Node): node is NamedEvaluationSource;
        function isNamedEvaluation(node: Node, cb?: (node: AnonymousFunctionDefinition) => boolean): node is NamedEvaluation;
        function isPushOrUnshiftIdentifier(node: Identifier): boolean;
        function isPartOfParameterDeclaration(node: Declaration): boolean;
        function getRootDeclaration(node: Node): Node;
        function nodeStartsNewLexicalEnvironment(node: Node): boolean;
        function nodeIsSynthesized(range: TextRange): boolean;
        function getExpressionAssociativity(expression: Expression): Associativity;
        function getOperatorAssociativity(kind: SyntaxKind, operator: SyntaxKind, hasArguments?: boolean): Associativity;
        function getExpressionPrecedence(expression: Expression): OperatorPrecedence;
        function getOperatorPrecedence(nodeKind: SyntaxKind, operatorKind: SyntaxKind, hasArguments?: boolean): OperatorPrecedence;
        function getBinaryOperatorPrecedence(kind: SyntaxKind): OperatorPrecedence;
        function getSemanticJsxChildren(children: readonly JsxChild[]): readonly JsxChild[];
        function createDiagnosticCollection(): DiagnosticCollection;
        function escapeTemplateSubstitution(str: string): string;
        function hasInvalidEscape(template: TemplateLiteral): boolean;
        function escapeString(s: string, quoteChar?: CharacterCodes.doubleQuote | CharacterCodes.singleQuote | CharacterCodes.backtick): string;
        function escapeNonAsciiString(s: string, quoteChar?: CharacterCodes.doubleQuote | CharacterCodes.singleQuote | CharacterCodes.backtick): string;
        function escapeJsxAttributeString(s: string, quoteChar?: CharacterCodes.doubleQuote | CharacterCodes.singleQuote): string;
        function stripQuotes(name: string): string;
        function isIntrinsicJsxName(name: __String | string): boolean;
        function getIndentString(level: number): string;
        function createTextWriter(newLine: string): EmitTextWriter;
        function getTrailingSemicolonDeferringWriter(writer: EmitTextWriter): EmitTextWriter;
        function hostUsesCaseSensitiveFileNames(host: {
            useCaseSensitiveFileNames?(): boolean;
        }): boolean;
        function hostGetCanonicalFileName(host: {
            useCaseSensitiveFileNames?(): boolean;
        }): GetCanonicalFileName;
        function getResolvedExternalModuleName(host: ResolveModuleNameResolutionHost, file: SourceFile, referenceFile?: SourceFile): string;
        function getExternalModuleNameFromDeclaration(host: ResolveModuleNameResolutionHost, resolver: EmitResolver, declaration: ImportEqualsDeclaration | ImportDeclaration | ExportDeclaration | ModuleDeclaration | ImportTypeNode): string | undefined;
        function getExternalModuleNameFromPath(host: ResolveModuleNameResolutionHost, fileName: string, referencePath?: string): string;
        function getOwnEmitOutputFilePath(fileName: string, host: EmitHost, extension: string): string;
        function getDeclarationEmitOutputFilePath(fileName: string, host: EmitHost): string;
        function getDeclarationEmitOutputFilePathWorker(fileName: string, options: CompilerOptions, host: Pick<EmitHost, "getCommonSourceDirectory" | "getCurrentDirectory" | "getCanonicalFileName">): string;
        function getDeclarationEmitExtensionForPath(path: string): Extension.Dts | Extension.Dmts | Extension.Dcts | ".d.json.ts";
        function getPossibleOriginalInputExtensionForExtension(path: string): Extension[];
        function getPossibleOriginalInputPathWithoutChangingExt(filePath: string, ignoreCase: boolean, outputDir: string | undefined, getCommonSourceDirectory: () => string): string;
        function getPathsBasePath(options: CompilerOptions, host: {
            getCurrentDirectory?(): string;
        }): string | undefined;
        function getSourceFilesToEmit(host: EmitHost, targetSourceFile?: SourceFile, forceDtsEmit?: boolean): readonly SourceFile[];
        function sourceFileMayBeEmitted(sourceFile: SourceFile, host: SourceFileMayBeEmittedHost, forceDtsEmit?: boolean): boolean;
        function getSourceFilePathInNewDir(fileName: string, host: EmitHost, newDirPath: string): string;
        function writeFile(host: {
            writeFile: WriteFileCallback;
        }, diagnostics: DiagnosticCollection, fileName: string, text: string, writeByteOrderMark: boolean, sourceFiles?: readonly SourceFile[], data?: WriteFileCallbackData): void;
        function writeFileEnsuringDirectories(path: string, data: string, writeByteOrderMark: boolean, writeFile: (path: string, data: string, writeByteOrderMark: boolean) => void, createDirectory: (path: string) => void, directoryExists: (path: string) => boolean): void;
        function getLineOfLocalPosition(sourceFile: SourceFile, pos: number): number;
        function getFirstConstructorWithBody(node: ClassLikeDeclaration): ConstructorDeclaration & {
            body: FunctionBody;
        } | undefined;
        function getSetAccessorValueParameter(accessor: SetAccessorDeclaration): ParameterDeclaration | undefined;
        function getSetAccessorTypeAnnotationNode(accessor: SetAccessorDeclaration): TypeNode | undefined;
        function getThisParameter(signature: SignatureDeclaration | JSDocSignature): ParameterDeclaration | undefined;
        function parameterIsThisKeyword(parameter: ParameterDeclaration): boolean;
        function isThisIdentifier(node: Node | undefined): boolean;
        function isInTypeQuery(node: Node): boolean;
        function isThisInTypeQuery(node: Node): boolean;
        function identifierIsThisKeyword(id: Identifier): boolean;
        function getAllAccessorDeclarations(declarations: readonly Declaration[] | undefined, accessor: AccessorDeclaration): AllAccessorDeclarations;
        function getEffectiveTypeAnnotationNode(node: Node): TypeNode | undefined;
        function getTypeAnnotationNode(node: Node): TypeNode | undefined;
        function getEffectiveReturnTypeNode(node: SignatureDeclaration | JSDocSignature): TypeNode | undefined;
        function getJSDocTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];
        function getEffectiveSetAccessorTypeAnnotationNode(node: SetAccessorDeclaration): TypeNode | undefined;
        function emitNewLineBeforeLeadingCommentOfPosition(lineMap: readonly number[], writer: EmitTextWriter, pos: number, commentPos: number): void;
        function emitDetachedComments(text: string, lineMap: readonly number[], writer: EmitTextWriter, writeComment: (text: string, lineMap: readonly number[], writer: EmitTextWriter, commentPos: number, commentEnd: number, newLine: string) => void, node: TextRange, newLine: string, removeComments: boolean): DetachedCommentInfo | undefined;
        function writeCommentRange(text: string, lineMap: readonly number[], writer: EmitTextWriter, commentPos: number, commentEnd: number, newLine: string): void;
        function hasEffectiveModifiers(node: Node): boolean;
        function hasSyntacticModifiers(node: Node): boolean;
        function hasEffectiveModifier(node: Node, flags: ModifierFlags): boolean;
        function hasSyntacticModifier(node: Node, flags: ModifierFlags): boolean;
        function isStatic(node: Node): boolean;
        function hasStaticModifier(node: Node): boolean;
        function hasOverrideModifier(node: Node): boolean;
        function hasAbstractModifier(node: Node): boolean;
        function hasAmbientModifier(node: Node): boolean;
        function hasAccessorModifier(node: Node): boolean;
        function hasEffectiveReadonlyModifier(node: Node): boolean;
        function hasDecorators(node: Node): boolean;
        function getSelectedEffectiveModifierFlags(node: Node, flags: ModifierFlags): ModifierFlags;
        function getSelectedSyntacticModifierFlags(node: Node, flags: ModifierFlags): ModifierFlags;
        function getEffectiveModifierFlags(node: Node): ModifierFlags;
        function getEffectiveModifierFlagsAlwaysIncludeJSDoc(node: Node): ModifierFlags;
        function getSyntacticModifierFlags(node: Node): ModifierFlags;
        function getEffectiveModifierFlagsNoCache(node: Node): ModifierFlags;
        function getSyntacticModifierFlagsNoCache(node: Node): ModifierFlags;
        function modifiersToFlags(modifiers: readonly ModifierLike[] | undefined): ModifierFlags;
        function modifierToFlag(token: SyntaxKind): ModifierFlags;
        function isBinaryLogicalOperator(token: SyntaxKind): boolean;
        function isLogicalOperator(token: SyntaxKind): boolean;
        function isLogicalOrCoalescingAssignmentOperator(token: SyntaxKind): token is LogicalOrCoalescingAssignmentOperator;
        function isLogicalOrCoalescingAssignmentExpression(expr: Node): expr is AssignmentExpression<Token<LogicalOrCoalescingAssignmentOperator>>;
        function isLogicalOrCoalescingBinaryOperator(token: SyntaxKind): token is LogicalOperator | SyntaxKind.QuestionQuestionToken;
        function isLogicalOrCoalescingBinaryExpression(expr: Node): expr is BinaryExpression;
        function isAssignmentOperator(token: SyntaxKind): boolean;
        function tryGetClassExtendingExpressionWithTypeArguments(node: Node): ClassLikeDeclaration | undefined;
        function tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node: Node): ClassImplementingOrExtendingExpressionWithTypeArguments | undefined;
        function isAssignmentExpression(node: Node, excludeCompoundAssignment: true): node is AssignmentExpression<EqualsToken>;
        function isAssignmentExpression(node: Node, excludeCompoundAssignment?: false): node is AssignmentExpression<AssignmentOperatorToken>;
        function isDestructuringAssignment(node: Node): node is DestructuringAssignment;
        function isExpressionWithTypeArgumentsInClassExtendsClause(node: Node): node is ExpressionWithTypeArguments;
        function isEntityNameExpression(node: Node): node is EntityNameExpression;
        function getFirstIdentifier(node: EntityNameOrEntityNameExpression): Identifier;
        function isDottedName(node: Expression): boolean;
        function isPropertyAccessEntityNameExpression(node: Node): node is PropertyAccessEntityNameExpression;
        function tryGetPropertyAccessOrIdentifierToString(expr: Expression | JsxTagNameExpression): string | undefined;
        function isPrototypeAccess(node: Node): node is BindableStaticAccessExpression;
        function isRightSideOfQualifiedNameOrPropertyAccess(node: Node): boolean;
        function isRightSideOfAccessExpression(node: Node): boolean;
        function isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(node: Node): boolean;
        function isInstanceOfExpression(node: Node): node is InstanceofExpression;
        function isRightSideOfInstanceofExpression(node: Node): boolean;
        function isEmptyObjectLiteral(expression: Node): boolean;
        function isEmptyArrayLiteral(expression: Node): boolean;
        function getLocalSymbolForExportDefault(symbol: Symbol): Symbol | undefined;
        function tryExtractTSExtension(fileName: string): string | undefined;
        function convertToBase64(input: string): string;
        function base64encode(host: {
            base64encode?(input: string): string;
        } | undefined, input: string): string;
        function base64decode(host: {
            base64decode?(input: string): string;
        } | undefined, input: string): string;
        function readJsonOrUndefined(path: string, hostOrText: {
            readFile(fileName: string): string | undefined;
        } | string): object | undefined;
        function readJson(path: string, host: {
            readFile(fileName: string): string | undefined;
        }): object;
        function tryParseJson(text: string): any;
        function directoryProbablyExists(directoryName: string, host: {
            directoryExists?: (directoryName: string) => boolean;
        }): boolean;
        function getNewLineCharacter(options: CompilerOptions | PrinterOptions): string;
        function createRange(pos: number, end?: number): TextRange;
        function moveRangeEnd(range: TextRange, end: number): TextRange;
        function moveRangePos(range: TextRange, pos: number): TextRange;
        function moveRangePastDecorators(node: Node): TextRange;
        function moveRangePastModifiers(node: Node): TextRange;
        function createTokenRange(pos: number, token: SyntaxKind): TextRange;
        function rangeIsOnSingleLine(range: TextRange, sourceFile: SourceFile): boolean;
        function rangeStartPositionsAreOnSameLine(range1: TextRange, range2: TextRange, sourceFile: SourceFile): boolean;
        function rangeEndPositionsAreOnSameLine(range1: TextRange, range2: TextRange, sourceFile: SourceFile): boolean;
        function rangeStartIsOnSameLineAsRangeEnd(range1: TextRange, range2: TextRange, sourceFile: SourceFile): boolean;
        function rangeEndIsOnSameLineAsRangeStart(range1: TextRange, range2: TextRange, sourceFile: SourceFile): boolean;
        function getLinesBetweenRangeEndAndRangeStart(range1: TextRange, range2: TextRange, sourceFile: SourceFile, includeSecondRangeComments: boolean): number;
        function getLinesBetweenRangeEndPositions(range1: TextRange, range2: TextRange, sourceFile: SourceFile): number;
        function isNodeArrayMultiLine(list: NodeArray<Node>, sourceFile: SourceFile): boolean;
        function positionsAreOnSameLine(pos1: number, pos2: number, sourceFile: SourceFile): boolean;
        function getStartPositionOfRange(range: TextRange, sourceFile: SourceFile, includeComments: boolean): number;
        function getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter(pos: number, stopPos: number, sourceFile: SourceFile, includeComments?: boolean): number;
        function getLinesBetweenPositionAndNextNonWhitespaceCharacter(pos: number, stopPos: number, sourceFile: SourceFile, includeComments?: boolean): number;
        function rangeContainsRange(r1: TextRange, r2: TextRange): boolean;
        function startEndContainsRange(start: number, end: number, range: TextRange): boolean;
        function isDeclarationNameOfEnumOrNamespace(node: Identifier): boolean;
        function getInitializedVariables(node: VariableDeclarationList): readonly InitializedVariableDeclaration[];
        function isInitializedVariable(node: Node): node is InitializedVariableDeclaration;
        function isWatchSet(options: CompilerOptions): boolean | undefined;
        function closeFileWatcher(watcher: FileWatcher): void;
        function getCheckFlags(symbol: Symbol): CheckFlags;
        function getDeclarationModifierFlagsFromSymbol(s: Symbol, isWrite?: boolean): ModifierFlags;
        function skipAlias(symbol: Symbol, checker: TypeChecker): Symbol;
        function getCombinedLocalAndExportSymbolFlags(symbol: Symbol): SymbolFlags;
        function isWriteOnlyAccess(node: Node): boolean;
        function isWriteAccess(node: Node): boolean;
        function compareDataObjects(dst: any, src: any): boolean;
        function clearMap<K, T>(map: {
            forEach: Map<K, T>["forEach"];
            clear: Map<K, T>["clear"];
        }, onDeleteValue: (valueInMap: T, key: K) => void): void;
        function mutateMapSkippingNewValues<K, T>(map: Map<K, T>, newMap: ReadonlySet<K> | undefined, options: MutateMapSkippingNewValuesDelete<K, T>): void;
        function mutateMapSkippingNewValues<K, T, U>(map: Map<K, T>, newMap: ReadonlyMap<K, U> | undefined, options: MutateMapSkippingNewValuesOptions<K, T, U>): void;
        function mutateMap<K, T>(map: Map<K, T>, newMap: ReadonlySet<K> | undefined, options: MutateMapWithNewSetOptions<K, T>): void;
        function mutateMap<K, T, U>(map: Map<K, T>, newMap: ReadonlyMap<K, U> | undefined, options: MutateMapOptions<K, T, U>): void;
        function isAbstractConstructorSymbol(symbol: Symbol): boolean;
        function getClassLikeDeclarationOfSymbol(symbol: Symbol): ClassLikeDeclaration | undefined;
        function getObjectFlags(type: Type): ObjectFlags;
        function isUMDExportSymbol(symbol: Symbol | undefined): boolean;
        function showModuleSpecifier({ moduleSpecifier }: ImportDeclaration): string;
        function getLastChild(node: Node): Node | undefined;
        function addToSeen<K>(seen: Set<K>, key: K): boolean;
        function isObjectTypeDeclaration(node: Node): node is ObjectTypeDeclaration;
        function isTypeNodeKind(kind: SyntaxKind): kind is TypeNodeSyntaxKind;
        function isAccessExpression(node: Node): node is AccessExpression;
        function getNameOfAccessExpression(node: AccessExpression): Expression;
        function isNamedImportsOrExports(node: Node): node is NamedImportsOrExports;
        function getLeftmostAccessExpression(expr: Expression): Expression;
        function forEachNameInAccessChainWalkingLeft<T>(name: MemberName | StringLiteralLike, action: (name: MemberName | StringLiteralLike) => T | undefined): T | undefined;
        function getLeftmostExpression(node: Expression, stopAtCallExpressions: boolean): Expression;
        function addObjectAllocatorPatcher(fn: (objectAllocator: ObjectAllocator) => void): void;
        function setObjectAllocator(alloc: ObjectAllocator): void;
        function formatStringFromArgs(text: string, args: DiagnosticArguments): string;
        function setLocalizedDiagnosticMessages(messages: MapLike<string> | undefined): void;
        function maybeSetLocalizedDiagnosticMessages(getMessages: undefined | (() => MapLike<string> | undefined)): void;
        function getLocaleSpecificMessage(message: DiagnosticMessage): string;
        function createDetachedDiagnostic(fileName: string, sourceText: string, start: number, length: number, message: DiagnosticMessage, ...args: DiagnosticArguments): DiagnosticWithDetachedLocation;
        function attachFileToDiagnostics(diagnostics: DiagnosticWithDetachedLocation[], file: SourceFile): DiagnosticWithLocation[];
        function createFileDiagnostic(file: SourceFile, start: number, length: number, message: DiagnosticMessage, ...args: DiagnosticArguments): DiagnosticWithLocation;
        function formatMessage(message: DiagnosticMessage, ...args: DiagnosticArguments): string;
        function createCompilerDiagnostic(message: DiagnosticMessage, ...args: DiagnosticArguments): Diagnostic;
        function createCompilerDiagnosticFromMessageChain(chain: DiagnosticMessageChain, relatedInformation?: DiagnosticRelatedInformation[]): Diagnostic;
        function chainDiagnosticMessages(details: DiagnosticMessageChain | DiagnosticMessageChain[] | undefined, message: DiagnosticMessage, ...args: DiagnosticArguments): DiagnosticMessageChain;
        function concatenateDiagnosticMessageChains(headChain: DiagnosticMessageChain, tailChain: DiagnosticMessageChain): void;
        function compareDiagnostics(d1: Diagnostic, d2: Diagnostic): Comparison;
        function diagnosticsEqualityComparer(d1: Diagnostic, d2: Diagnostic): boolean;
        function getLanguageVariant(scriptKind: ScriptKind): LanguageVariant;
        function getSetExternalModuleIndicator(options: CompilerOptions): (file: SourceFile) => void;
        function importSyntaxAffectsModuleResolution(options: CompilerOptions): boolean;
        function emitModuleKindIsNonNodeESM(moduleKind: ModuleKind): boolean;
        function hasJsonModuleEmitEnabled(options: CompilerOptions): boolean;
        function unreachableCodeIsError(options: CompilerOptions): boolean;
        function unusedLabelIsError(options: CompilerOptions): boolean;
        function moduleResolutionSupportsPackageJsonExportsAndImports(moduleResolution: ModuleResolutionKind): boolean;
        function moduleSupportsImportAttributes(moduleKind: ModuleKind): boolean;
        function getStrictOptionValue(compilerOptions: CompilerOptions, flag: StrictOptionName): boolean;
        function getNameOfScriptTarget(scriptTarget: ScriptTarget): string | undefined;
        function getEmitStandardClassFields(compilerOptions: CompilerOptions): boolean;
        function compilerOptionsAffectSemanticDiagnostics(newOptions: CompilerOptions, oldOptions: CompilerOptions): boolean;
        function compilerOptionsAffectEmit(newOptions: CompilerOptions, oldOptions: CompilerOptions): boolean;
        function compilerOptionsAffectDeclarationPath(newOptions: CompilerOptions, oldOptions: CompilerOptions): boolean;
        function getCompilerOptionValue(options: CompilerOptions, option: CommandLineOption): unknown;
        function getJSXTransformEnabled(options: CompilerOptions): boolean;
        function getJSXImplicitImportBase(compilerOptions: CompilerOptions, file?: SourceFile): string | undefined;
        function getJSXRuntimeImport(base: string | undefined, options: CompilerOptions): string | undefined;
        function hasZeroOrOneAsteriskCharacter(str: string): boolean;
        function createSymlinkCache(cwd: string, getCanonicalFileName: GetCanonicalFileName): SymlinkCache;
        function tryRemoveDirectoryPrefix(path: string, dirPath: string, getCanonicalFileName: GetCanonicalFileName): string | undefined;
        function regExpEscape(text: string): string;
        function getRegularExpressionForWildcard(specs: readonly string[] | undefined, basePath: string, usage: "files" | "directories" | "exclude"): string | undefined;
        function getRegularExpressionsForWildcards(specs: readonly string[] | undefined, basePath: string, usage: "files" | "directories" | "exclude"): readonly string[] | undefined;
        function isImplicitGlob(lastPathComponent: string): boolean;
        function getPatternFromSpec(spec: string, basePath: string, usage: "files" | "directories" | "exclude"): string | undefined;
        function getSubPatternFromSpec(spec: string, basePath: string, usage: "files" | "directories" | "exclude", { singleAsteriskRegexFragment, doubleAsteriskRegexFragment, replaceWildcardCharacter }?: WildcardMatcher): string | undefined;
        function getFileMatcherPatterns(path: string, excludes: readonly string[] | undefined, includes: readonly string[] | undefined, useCaseSensitiveFileNames: boolean, currentDirectory: string): FileMatcherPatterns;
        function getRegexFromPattern(pattern: string, useCaseSensitiveFileNames: boolean): RegExp;
        function matchFiles(path: string, extensions: readonly string[] | undefined, excludes: readonly string[] | undefined, includes: readonly string[] | undefined, useCaseSensitiveFileNames: boolean, currentDirectory: string, depth: number | undefined, getFileSystemEntries: (path: string) => FileSystemEntries, realpath: (path: string) => string): string[];
        function ensureScriptKind(fileName: string, scriptKind: ScriptKind | undefined): ScriptKind;
        function getScriptKindFromFileName(fileName: string): ScriptKind;
        function getSupportedExtensions(options?: CompilerOptions): readonly Extension[][];
        function getSupportedExtensions(options?: CompilerOptions, extraFileExtensions?: readonly FileExtensionInfo[]): readonly string[][];
        function getSupportedExtensionsWithJsonIfResolveJsonModule(options: CompilerOptions | undefined, supportedExtensions: readonly Extension[][]): readonly Extension[][];
        function getSupportedExtensionsWithJsonIfResolveJsonModule(options: CompilerOptions | undefined, supportedExtensions: readonly string[][]): readonly string[][];
        function hasJSFileExtension(fileName: string): boolean;
        function hasTSFileExtension(fileName: string): boolean;
        function hasImplementationTSFileExtension(fileName: string): boolean;
        function getModuleSpecifierEndingPreference(preference: UserPreferences["importModuleSpecifierEnding"], resolutionMode: ResolutionMode, compilerOptions: CompilerOptions, sourceFile?: SourceFile): ModuleSpecifierEnding;
        function isSupportedSourceFileName(fileName: string, compilerOptions?: CompilerOptions, extraFileExtensions?: readonly FileExtensionInfo[]): boolean;
        function compareNumberOfDirectorySeparators(path1: string, path2: string): Comparison;
        function removeFileExtension(path: string): string;
        function tryRemoveExtension(path: string, extension: string): string | undefined;
        function removeExtension(path: string, extension: string): string;
        function changeExtension<T extends string | Path>(path: T, newExtension: string): T;
        function tryParsePattern(pattern: string): string | Pattern | undefined;
        function tryParsePatterns(paths: MapLike<string[]>): ParsedPatterns;
        function positionIsSynthesized(pos: number): boolean;
        function extensionIsTS(ext: string): boolean;
        function resolutionExtensionIsTSOrJson(ext: string): boolean;
        function extensionFromPath(path: string): Extension;
        function isAnySupportedFileExtension(path: string): boolean;
        function tryGetExtensionFromPath(path: string): Extension | undefined;
        function isCheckJsEnabledForFile(sourceFile: SourceFile, compilerOptions: CompilerOptions): boolean | undefined;
        function matchPatternOrExact(parsedPatterns: ParsedPatterns, candidate: string): string | Pattern | undefined;
        function sliceAfter<T>(arr: readonly T[], value: T): readonly T[];
        function addRelatedInfo<T extends Diagnostic>(diagnostic: T, ...relatedInformation: DiagnosticRelatedInformation[]): T;
        function minAndMax<T>(arr: readonly T[], getValue: (value: T) => number): {
            readonly min: number;
            readonly max: number;
        };
        function rangeOfNode(node: Node): TextRange;
        function rangeOfTypeParameters(sourceFile: SourceFile, typeParameters: NodeArray<TypeParameterDeclaration>): TextRange;
        function skipTypeChecking(sourceFile: SourceFile, options: CompilerOptions, host: HostWithIsSourceOfProjectReferenceRedirect): boolean;
        function skipTypeCheckingIgnoringNoCheck(sourceFile: SourceFile, options: CompilerOptions, host: HostWithIsSourceOfProjectReferenceRedirect): boolean;
        function canIncludeBindAndCheckDiagnostics(sourceFile: SourceFile, options: CompilerOptions): boolean;
        function isJsonEqual(a: unknown, b: unknown): boolean;
        function parsePseudoBigInt(stringValue: string): string;
        function pseudoBigIntToString({ negative, base10Value }: PseudoBigInt): string;
        function parseBigInt(text: string): PseudoBigInt | undefined;
        function parseValidBigInt(text: string): PseudoBigInt;
        function isValidBigIntString(s: string, roundTripOnly: boolean): boolean;
        function isValidTypeOnlyAliasUseSite(useSite: Node): boolean;
        function isIdentifierTypeReference(node: Node): node is TypeReferenceNode & {
            typeName: Identifier;
        };
        function arrayIsHomogeneous<T>(array: readonly T[], comparer?: EqualityComparer<T>): boolean;
        function setTextRangePos<T extends ReadonlyTextRange>(range: T, pos: number): T;
        function setTextRangeEnd<T extends ReadonlyTextRange>(range: T, end: number): T;
        function setTextRangePosEnd<T extends ReadonlyTextRange>(range: T, pos: number, end: number): T;
        function setTextRangePosWidth<T extends ReadonlyTextRange>(range: T, pos: number, width: number): T;
        function setNodeFlags<T extends Node>(node: T, newFlags: NodeFlags): T;
        function setNodeFlags<T extends Node>(node: T | undefined, newFlags: NodeFlags): T | undefined;
        function setParent<T extends Node>(child: T, parent: T["parent"] | undefined): T;
        function setParent<T extends Node>(child: T | undefined, parent: T["parent"] | undefined): T | undefined;
        function setParentRecursive<T extends Node>(rootNode: T, incremental: boolean): T;
        function setParentRecursive<T extends Node>(rootNode: T | undefined, incremental: boolean): T | undefined;
        function isPackedArrayLiteral(node: Expression): boolean;
        function expressionResultIsUnused(node: Expression): boolean;
        function containsIgnoredPath(path: string): boolean;
        function getContainingNodeArray(node: Node): NodeArray<Node> | undefined;
        function hasContextSensitiveParameters(node: FunctionLikeDeclaration): boolean;
        function isInfinityOrNaNString(name: string | __String): boolean;
        function isCatchClauseVariableDeclaration(node: Node): boolean;
        function isFunctionExpressionOrArrowFunction(node: Node): node is FunctionExpression | ArrowFunction;
        function escapeSnippetText(text: string): string;
        function isNumericLiteralName(name: string | __String): boolean;
        function createPropertyNameNodeForIdentifierOrLiteral(name: string, target: ScriptTarget, singleQuote: boolean, stringNamed: boolean, isMethod: boolean): Identifier | StringLiteral | NumericLiteral;
        function isThisTypeParameter(type: Type): boolean;
        function getNodeModulePathParts(fullPath: string): NodeModulePathParts | undefined;
        function isTypeDeclaration(node: Node): node is TypeParameterDeclaration | ClassDeclaration | InterfaceDeclaration | TypeAliasDeclaration | JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag | EnumDeclaration | ImportClause | ImportSpecifier | ExportSpecifier;
        function canHaveExportModifier(node: Node): node is Extract<HasModifiers, Statement>;
        function isOptionalJSDocPropertyLikeTag(node: Node): boolean;
        function canUsePropertyAccess(name: string, languageVersion: ScriptTarget): boolean;
        function hasTabstop(node: Node): boolean;
        function isJSDocOptionalParameter(node: ParameterDeclaration): boolean;
        function isOptionalDeclaration(declaration: Declaration): boolean;
        function isNonNullAccess(node: Node): node is AccessExpression;
        function isJSDocSatisfiesExpression(node: Node): node is JSDocSatisfiesExpression;
        function getJSDocSatisfiesExpressionType(node: JSDocSatisfiesExpression): TypeNode;
        function tryGetJSDocSatisfiesTypeNode(node: Node): TypeNode | undefined;
        function getEscapedTextOfJsxAttributeName(node: JsxAttributeName): __String;
        function getTextOfJsxAttributeName(node: JsxAttributeName): string;
        function isJsxAttributeName(node: Node): node is JsxAttributeName;
        function getEscapedTextOfJsxNamespacedName(node: JsxNamespacedName): __String;
        function getTextOfJsxNamespacedName(node: JsxNamespacedName): string;
        function intrinsicTagNameToString(node: Identifier | JsxNamespacedName): string;
        function isTypeUsableAsPropertyName(type: Type): type is StringLiteralType | NumberLiteralType | UniqueESSymbolType;
        function getPropertyNameFromType(type: StringLiteralType | NumberLiteralType | UniqueESSymbolType): __String;
        function isExpandoPropertyDeclaration(declaration: Declaration | undefined): declaration is PropertyAccessExpression | ElementAccessExpression | BinaryExpression;
        function hasResolutionModeOverride(node: ImportTypeNode | ImportDeclaration | ExportDeclaration | JSDocImportTag | undefined): boolean;
        function replaceFirstStar(s: string, replacement: string): string;
        function getNameFromImportAttribute(node: ImportAttribute): __String;
        function isSourceElement(node: Node): boolean;
        function evaluatorResult<T extends string | number | undefined>(value: T, isSyntacticallyString?: boolean, resolvedOtherFiles?: boolean, hasExternalReferences?: boolean): EvaluatorResult<T>;
        function createEvaluator({ evaluateElementAccessExpression, evaluateEntityNameExpression }: EvaluationResolver): {
            (expr: TemplateExpression, location?: Declaration): EvaluatorResult<string | undefined>;
            (expr: Expression, location?: Declaration): EvaluatorResult;
        };
        function isConstAssertion(location: Node): boolean;
        function findConstructorDeclaration(node: ClassLikeDeclaration): ConstructorDeclaration | undefined;
        function createNameResolver({ compilerOptions, requireSymbol, argumentsSymbol, error, getSymbolOfDeclaration, globals, lookup, setRequiresScopeChangeCache, getRequiresScopeChangeCache, onPropertyWithInvalidInitializer, onFailedToResolveSymbol, onSuccessfullyResolvedSymbol }: NameResolverOptions): NameResolver;
        function isPrimitiveLiteralValue(node: Expression, includeBigInt?: boolean): node is PrimitiveLiteral;
        function unwrapParenthesizedExpression(o: Expression): Expression;
        function hasInferredType(node: Node): node is HasInferredType;
        function isSideEffectImport(node: Node): boolean;
        function forEachDynamicImportOrRequireCall<IncludeTypeSpaceImports extends boolean, RequireStringLiteralLikeArgument extends boolean>(file: SourceFile, includeTypeSpaceImports: IncludeTypeSpaceImports, requireStringLiteralLikeArgument: RequireStringLiteralLikeArgument, cb: (node: CallExpression | (IncludeTypeSpaceImports extends false ? never : JSDocImportTag | ImportTypeNode), argument: RequireStringLiteralLikeArgument extends true ? StringLiteralLike : Expression) => void): void;
        function isNewScopeNode(node: Node): node is IntroducesNewScopeNode;
        function getLibNameFromLibReference(libReference: FileReference): string;
        function getLibFileNameFromLibReference(libReference: FileReference): string | undefined;
        function forEachResolvedProjectReference<T>(resolvedProjectReferences: readonly (ResolvedProjectReference | undefined)[] | undefined, cb: (resolvedProjectReference: ResolvedProjectReference, parent: ResolvedProjectReference | undefined) => T | undefined): T | undefined;
        function forEachProjectReference<T>(projectReferences: readonly ProjectReference[] | undefined, resolvedProjectReferences: readonly (ResolvedProjectReference | undefined)[] | undefined, cbResolvedRef: (resolvedRef: ResolvedProjectReference | undefined, parent: ResolvedProjectReference | undefined, index: number) => T | undefined, cbRef?: (projectReferences: readonly ProjectReference[] | undefined, parent: ResolvedProjectReference | undefined) => T | undefined): T | undefined;
        function getOptionsSyntaxByArrayElementValue(optionsObject: ObjectLiteralExpression | undefined, name: string, value: string): StringLiteral | undefined;
        function getOptionsSyntaxByValue(optionsObject: ObjectLiteralExpression | undefined, name: string, value: string): StringLiteral | undefined;
        function forEachOptionsSyntaxByName<T>(optionsObject: ObjectLiteralExpression | undefined, name: string, callback: (prop: PropertyAssignment) => T | undefined): T | undefined;
        function getSynthesizedDeepClone<T extends Node | undefined>(node: T, includeTrivia?: boolean): T;
        function getSynthesizedDeepCloneWithReplacements<T extends Node>(node: T, includeTrivia: boolean, replaceNode: (node: Node) => Node | undefined): T;
        function getSynthesizedDeepClones<T extends Node>(nodes: NodeArray<T>, includeTrivia?: boolean): NodeArray<T>;
        function getSynthesizedDeepClones<T extends Node>(nodes: NodeArray<T> | undefined, includeTrivia?: boolean): NodeArray<T> | undefined;
        function getSynthesizedDeepClonesWithReplacements<T extends Node>(nodes: NodeArray<T>, includeTrivia: boolean, replaceNode: (node: Node) => Node | undefined): NodeArray<T>;
        function suppressLeadingAndTrailingTrivia(node: Node): void;
        function suppressLeadingTrivia(node: Node): void;
        function suppressTrailingTrivia(node: Node): void;
        const resolvingEmptyArray: never[];
        const externalHelpersModuleNameText = "tslib";
        const defaultMaximumTruncationLength = 160;
        const noTruncationMaximumTruncationLength = 1000000;
        type ScriptTargetFeatures = ReadonlyMap<string, ReadonlyMap<string, string[]>>;
        const getScriptTargetFeatures: () => ScriptTargetFeatures;
        enum GetLiteralTextFlags {
            None = 0,
            NeverAsciiEscape = 1,
            JsxAttributeEscape = 2,
            TerminateUnterminatedLiterals = 4,
            AllowNumericSeparator = 8
        }
        type ThisContainer = FunctionDeclaration | FunctionExpression | ModuleDeclaration | ClassStaticBlockDeclaration | PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | CallSignatureDeclaration | ConstructSignatureDeclaration | IndexSignatureDeclaration | EnumDeclaration | SourceFile;
        type SuperContainer = PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ClassStaticBlockDeclaration;
        type SuperContainerOrFunctions = SuperContainer | FunctionDeclaration | FunctionExpression | ArrowFunction;
        interface PrototypePropertyAssignment extends AssignmentExpression<EqualsToken> {
            _prototypePropertyAssignmentBrand: any;
            readonly left: AccessExpression;
        }
        enum AssignmentKind {
            None = 0,
            Definite = 1,
            Compound = 2
        }
        type NodeWithPossibleHoistedDeclaration = Block | VariableStatement | WithStatement | IfStatement | SwitchStatement | CaseBlock | CaseClause | DefaultClause | LabeledStatement | ForStatement | ForInOrOfStatement | DoStatement | WhileStatement | TryStatement | CatchClause;
        type ValueSignatureDeclaration = FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | AccessorDeclaration | FunctionExpression | ArrowFunction;
        enum FunctionFlags {
            Normal = 0,
            Generator = 1,
            Async = 2,
            Invalid = 4,
            AsyncGenerator = 3
        }
        type AnonymousFunctionDefinition = ClassExpression & {
            readonly name?: undefined;
        } | FunctionExpression & {
            readonly name?: undefined;
        } | ArrowFunction;
        type NamedEvaluationSource = PropertyAssignment & {
            readonly name: Identifier;
        } | ShorthandPropertyAssignment & {
            readonly objectAssignmentInitializer: Expression;
        } | VariableDeclaration & {
            readonly name: Identifier;
            readonly initializer: Expression;
        } | ParameterDeclaration & {
            readonly name: Identifier;
            readonly initializer: Expression;
            readonly dotDotDotToken: undefined;
        } | BindingElement & {
            readonly name: Identifier;
            readonly initializer: Expression;
            readonly dotDotDotToken: undefined;
        } | PropertyDeclaration & {
            readonly initializer: Expression;
        } | AssignmentExpression<EqualsToken | AmpersandAmpersandEqualsToken | BarBarEqualsToken | QuestionQuestionEqualsToken> & {
            readonly left: Identifier;
        } | ExportAssignment;
        type NamedEvaluation = PropertyAssignment & {
            readonly name: Identifier;
            readonly initializer: WrappedExpression<AnonymousFunctionDefinition>;
        } | ShorthandPropertyAssignment & {
            readonly objectAssignmentInitializer: WrappedExpression<AnonymousFunctionDefinition>;
        } | VariableDeclaration & {
            readonly name: Identifier;
            readonly initializer: WrappedExpression<AnonymousFunctionDefinition>;
        } | ParameterDeclaration & {
            readonly name: Identifier;
            readonly dotDotDotToken: undefined;
            readonly initializer: WrappedExpression<AnonymousFunctionDefinition>;
        } | BindingElement & {
            readonly name: Identifier;
            readonly dotDotDotToken: undefined;
            readonly initializer: WrappedExpression<AnonymousFunctionDefinition>;
        } | PropertyDeclaration & {
            readonly initializer: WrappedExpression<AnonymousFunctionDefinition>;
        } | AssignmentExpression<EqualsToken> & {
            readonly left: Identifier;
            readonly right: WrappedExpression<AnonymousFunctionDefinition>;
        } | AssignmentExpression<AmpersandAmpersandEqualsToken | BarBarEqualsToken | QuestionQuestionEqualsToken> & {
            readonly left: Identifier;
            readonly right: WrappedExpression<AnonymousFunctionDefinition>;
        } | ExportAssignment & {
            readonly expression: WrappedExpression<AnonymousFunctionDefinition>;
        };
        enum Associativity {
            Left = 0,
            Right = 1
        }
        enum OperatorPrecedence {
            Comma = 0,
            Spread = 1,
            Yield = 2,
            Assignment = 3,
            Conditional = 4,
            Coalesce = 4,
            LogicalOR = 5,
            LogicalAND = 6,
            BitwiseOR = 7,
            BitwiseXOR = 8,
            BitwiseAND = 9,
            Equality = 10,
            Relational = 11,
            Shift = 12,
            Additive = 13,
            Multiplicative = 14,
            Exponentiation = 15,
            Unary = 16,
            Update = 17,
            LeftHandSide = 18,
            Member = 19,
            Primary = 20,
            Highest = 20,
            Lowest = 0,
            Invalid = -1
        }
        interface ResolveModuleNameResolutionHost {
            getCanonicalFileName(p: string): string;
            getCommonSourceDirectory(): string;
            getCurrentDirectory(): string;
        }
        interface EmitFileNames {
            jsFilePath?: string | undefined;
            sourceMapFilePath?: string | undefined;
            declarationFilePath?: string | undefined;
            declarationMapPath?: string | undefined;
            buildInfoPath?: string | undefined;
        }
        interface DetachedCommentInfo {
            nodePos: number;
            detachedCommentEndPos: number;
        }
        interface ClassImplementingOrExtendingExpressionWithTypeArguments {
            readonly class: ClassLikeDeclaration;
            readonly isImplements: boolean;
        }
        interface MutateMapSkippingNewValuesDelete<K, T> {
            onDeleteValue(existingValue: T, key: K): void;
        }
        interface MutateMapSkippingNewValuesOptions<K, T, U> extends MutateMapSkippingNewValuesDelete<K, T> {
            onExistingValue?(existingValue: T, valueInNewMap: U, key: K): void;
        }
        interface MutateMapOptionsCreate<K, T, U> {
            createNewValue(key: K, valueInNewMap: U): T;
        }
        interface MutateMapWithNewSetOptions<K, T> extends MutateMapSkippingNewValuesDelete<K, T>, MutateMapOptionsCreate<K, T, K> {
        }
        interface MutateMapOptions<K, T, U> extends MutateMapSkippingNewValuesOptions<K, T, U>, MutateMapOptionsCreate<K, T, U> {
        }
        interface ObjectAllocator {
            getNodeConstructor(): new (kind: SyntaxKind, pos: number, end: number) => Node;
            getTokenConstructor(): new <TKind extends SyntaxKind>(kind: TKind, pos: number, end: number) => Token<TKind>;
            getIdentifierConstructor(): new (kind: SyntaxKind.Identifier, pos: number, end: number) => Identifier;
            getPrivateIdentifierConstructor(): new (kind: SyntaxKind.PrivateIdentifier, pos: number, end: number) => PrivateIdentifier;
            getSourceFileConstructor(): new (kind: SyntaxKind.SourceFile, pos: number, end: number) => SourceFile;
            getSymbolConstructor(): new (flags: SymbolFlags, name: __String) => Symbol;
            getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type;
            getSignatureConstructor(): new (checker: TypeChecker, flags: SignatureFlags) => Signature;
            getSourceMapSourceConstructor(): new (fileName: string, text: string, skipTrivia?: (pos: number) => number) => SourceMapSource;
        }
        const objectAllocator: ObjectAllocator;
        const computedOptions: Record<string, {
            dependencies: readonly string[];
            computeValue: (options: CompilerOptions) => CompilerOptionsValue;
        }>;
        const getAllowImportingTsExtensions: (compilerOptions: CompilerOptions) => boolean;
        const getEmitScriptTarget: (compilerOptions: CompilerOptions) => ScriptTarget;
        const getEmitModuleKind: (compilerOptions: Pick<CompilerOptions, "module" | "target">) => ModuleKind;
        const getEmitModuleResolutionKind: (compilerOptions: CompilerOptions) => ModuleResolutionKind;
        const getEmitModuleDetectionKind: (compilerOptions: CompilerOptions) => ModuleDetectionKind;
        const getIsolatedModules: (compilerOptions: CompilerOptions) => boolean;
        const getESModuleInterop: (compilerOptions: CompilerOptions) => boolean;
        const getAllowSyntheticDefaultImports: (compilerOptions: CompilerOptions) => boolean;
        const getResolvePackageJsonExports: (compilerOptions: CompilerOptions) => boolean;
        const getResolvePackageJsonImports: (compilerOptions: CompilerOptions) => boolean;
        const getResolveJsonModule: (compilerOptions: CompilerOptions) => boolean;
        const getEmitDeclarations: (compilerOptions: CompilerOptions) => boolean;
        const shouldPreserveConstEnums: (compilerOptions: CompilerOptions) => boolean;
        const isIncrementalCompilation: (compilerOptions: CompilerOptions) => boolean;
        const getAreDeclarationMapsEnabled: (compilerOptions: CompilerOptions) => boolean;
        const getAllowJSCompilerOption: (compilerOptions: CompilerOptions) => boolean;
        const getUseDefineForClassFields: (compilerOptions: CompilerOptions) => boolean;
        type StrictOptionName = "noImplicitAny" | "noImplicitThis" | "strictNullChecks" | "strictFunctionTypes" | "strictBindCallApply" | "strictPropertyInitialization" | "strictBuiltinIteratorReturn" | "alwaysStrict" | "useUnknownInCatchVariables";
        interface SymlinkedDirectory {
            real: string;
            realPath: Path;
        }
        interface SymlinkCache {
            getSymlinkedDirectories(): ReadonlyMap<Path, SymlinkedDirectory | false> | undefined;
            getSymlinkedDirectoriesByRealpath(): MultiMap<Path, string> | undefined;
            getSymlinkedFiles(): ReadonlyMap<Path, string> | undefined;
            setSymlinkedDirectory(symlink: string, real: SymlinkedDirectory | false): void;
            setSymlinkedFile(symlinkPath: Path, real: string): void;
            hasAnySymlinks(): boolean;
            setSymlinksFromResolutions(forEachResolvedModule: (callback: (resolution: ResolvedModuleWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void) => void, forEachResolvedTypeReferenceDirective: (callback: (resolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void) => void, typeReferenceDirectives: ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>): void;
            setSymlinksFromResolution(resolution: ResolvedModuleFull | undefined): void;
            hasProcessedResolutions(): boolean;
        }
        interface WildcardMatcher {
            singleAsteriskRegexFragment: string;
            doubleAsteriskRegexFragment: string;
            replaceWildcardCharacter: (match: string) => string;
        }
        interface FileSystemEntries {
            readonly files: readonly string[];
            readonly directories: readonly string[];
        }
        interface FileMatcherPatterns {
            includeFilePatterns: readonly string[] | undefined;
            includeFilePattern: string | undefined;
            includeDirectoryPattern: string | undefined;
            excludePattern: string | undefined;
            basePaths: readonly string[];
        }
        const supportedTSExtensionsFlat: readonly Extension[];
        const supportedJSExtensionsFlat: readonly Extension[];
        const supportedDeclarationExtensions: readonly Extension[];
        const supportedTSImplementationExtensions: readonly Extension[];
        const extensionsNotSupportingExtensionlessResolution: readonly Extension[];
        enum ModuleSpecifierEnding {
            Minimal = 0,
            Index = 1,
            JsExtension = 2,
            TsExtension = 3
        }
        interface ParsedPatterns {
            matchableStringSet: ReadonlySet<string> | undefined;
            patterns: (readonly Pattern[]) | undefined;
        }
        const emptyFileSystemEntries: FileSystemEntries;
        type Mutable<T extends object> = {
            -readonly [K in keyof T]: T[K];
        };
        interface HostWithIsSourceOfProjectReferenceRedirect {
            isSourceOfProjectReferenceRedirect(fileName: string): boolean;
        }
        interface NodeModulePathParts {
            readonly topLevelNodeModulesIndex: number;
            readonly topLevelPackageNameIndex: number;
            readonly packageRootIndex: number;
            readonly fileNameIndex: number;
        }
        interface NameResolverOptions {
            compilerOptions: CompilerOptions;
            getSymbolOfDeclaration: (node: Declaration) => Symbol;
            error: (location: Node | undefined, message: DiagnosticMessage, ...args: DiagnosticArguments) => void;
            globals: SymbolTable;
            argumentsSymbol: Symbol;
            requireSymbol: Symbol;
            lookup: (symbols: SymbolTable, name: __String, meaning: SymbolFlags) => Symbol | undefined;
            setRequiresScopeChangeCache: undefined | ((node: FunctionLikeDeclaration, value: boolean) => void);
            getRequiresScopeChangeCache: undefined | ((node: FunctionLikeDeclaration) => boolean | undefined);
            onPropertyWithInvalidInitializer?: (location: Node | undefined, name: __String, declaration: PropertyDeclaration, result: Symbol | undefined) => boolean;
            onFailedToResolveSymbol?: (location: Node | undefined, name: __String | Identifier, meaning: SymbolFlags, nameNotFoundMessage: DiagnosticMessage) => void;
            onSuccessfullyResolvedSymbol?: (location: Node | undefined, result: Symbol, meaning: SymbolFlags, lastLocation: Node | undefined, associatedDeclarationForContainingInitializerOrBindingName: ParameterDeclaration | BindingElement | undefined, withinDeferredContext: boolean) => void;
        }
        type NameResolver = (location: Node | undefined, nameArg: __String | Identifier, meaning: SymbolFlags, nameNotFoundMessage: DiagnosticMessage | undefined, isUse: boolean, excludeGlobals?: boolean) => Symbol | undefined;
        const unprefixedNodeCoreModules: Set<string>;
        const exclusivelyPrefixedNodeCoreModules: Set<string>;
        const nodeCoreModules: Set<string>;
        function createBaseNodeFactory(): BaseNodeFactory;
        interface BaseNodeFactory {
            createBaseSourceFileNode(kind: SyntaxKind.SourceFile): Node;
            createBaseIdentifierNode(kind: SyntaxKind.Identifier): Node;
            createBasePrivateIdentifierNode(kind: SyntaxKind.PrivateIdentifier): Node;
            createBaseTokenNode(kind: SyntaxKind): Node;
            createBaseNode(kind: SyntaxKind): Node;
        }
        function createParenthesizerRules(factory: NodeFactory): ParenthesizerRules;
        const nullParenthesizerRules: ParenthesizerRules;
        function createNodeConverters(factory: NodeFactory): NodeConverters;
        const nullNodeConverters: NodeConverters;
        function addNodeFactoryPatcher(fn: (factory: NodeFactory) => void): void;
        function createNodeFactory(flags: NodeFactoryFlags, baseFactory: BaseNodeFactory): NodeFactory;
        function createSourceMapSource(fileName: string, text: string, skipTrivia?: (pos: number) => number): SourceMapSource;
        function setOriginalNode<T extends Node>(node: T, original: Node | undefined): T;
        enum NodeFactoryFlags {
            None = 0,
            NoParenthesizerRules = 1,
            NoNodeConverters = 2,
            NoIndentationOnFreshPropertyAccess = 4,
            NoOriginalNode = 8
        }
        const factory: NodeFactory;
        function getOrCreateEmitNode(node: Node): EmitNode;
        function disposeEmitNodes(sourceFile: SourceFile | undefined): void;
        function removeAllComments<T extends Node>(node: T): T;
        function setEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags): T;
        function addEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags): T;
        function setInternalEmitFlags<T extends Node>(node: T, emitFlags: InternalEmitFlags): T;
        function addInternalEmitFlags<T extends Node>(node: T, emitFlags: InternalEmitFlags): T;
        function getSourceMapRange(node: Node): SourceMapRange;
        function setSourceMapRange<T extends Node>(node: T, range: SourceMapRange | undefined): T;
        function getTokenSourceMapRange(node: Node, token: SyntaxKind): SourceMapRange | undefined;
        function setTokenSourceMapRange<T extends Node>(node: T, token: SyntaxKind, range: SourceMapRange | undefined): T;
        function getStartsOnNewLine(node: Node): boolean | undefined;
        function setStartsOnNewLine<T extends Node>(node: T, newLine: boolean): T;
        function getCommentRange(node: Node): TextRange;
        function setCommentRange<T extends Node>(node: T, range: TextRange): T;
        function getSyntheticLeadingComments(node: Node): SynthesizedComment[] | undefined;
        function setSyntheticLeadingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
        function addSyntheticLeadingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
        function getSyntheticTrailingComments(node: Node): SynthesizedComment[] | undefined;
        function setSyntheticTrailingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
        function addSyntheticTrailingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
        function moveSyntheticComments<T extends Node>(node: T, original: Node): T;
        function getConstantValue(node: AccessExpression): string | number | undefined;
        function setConstantValue(node: AccessExpression, value: string | number): AccessExpression;
        function addEmitHelper<T extends Node>(node: T, helper: EmitHelper): T;
        function addEmitHelpers<T extends Node>(node: T, helpers: EmitHelper[] | undefined): T;
        function removeEmitHelper(node: Node, helper: EmitHelper): boolean;
        function getEmitHelpers(node: Node): EmitHelper[] | undefined;
        function moveEmitHelpers(source: Node, target: Node, predicate: (helper: EmitHelper) => boolean): void;
        function getSnippetElement(node: Node): SnippetElement | undefined;
        function setSnippetElement<T extends Node>(node: T, snippet: SnippetElement): T;
        function ignoreSourceNewlines<T extends Node>(node: T): T;
        function setTypeNode<T extends Node>(node: T, type: TypeNode): T;
        function getTypeNode<T extends Node>(node: T): TypeNode | undefined;
        function setIdentifierTypeArguments<T extends Identifier>(node: T, typeArguments: NodeArray<TypeNode | TypeParameterDeclaration> | undefined): T;
        function getIdentifierTypeArguments(node: Identifier): NodeArray<TypeNode | TypeParameterDeclaration> | undefined;
        function setIdentifierAutoGenerate<T extends Identifier | PrivateIdentifier>(node: T, autoGenerate: AutoGenerateInfo | undefined): T;
        function getIdentifierAutoGenerate(node: Identifier | PrivateIdentifier): AutoGenerateInfo | undefined;
        function setIdentifierGeneratedImportReference<T extends Identifier | PrivateIdentifier>(node: T, value: ImportSpecifier | undefined): T;
        function getIdentifierGeneratedImportReference(node: Identifier | PrivateIdentifier): ImportSpecifier | undefined;
        function createEmitHelperFactory(context: TransformationContext): EmitHelperFactory;
        function compareEmitHelpers(x: EmitHelper, y: EmitHelper): Comparison;
        function isCallToHelper(firstSegment: Expression, helperName: __String): boolean;
        enum PrivateIdentifierKind {
            Field = "f",
            Method = "m",
            Accessor = "a"
        }
        interface ESDecorateClassContext {
            kind: "class";
            name: Expression;
            metadata: Expression;
        }
        interface ESDecorateClassElementContext {
            kind: "method" | "getter" | "setter" | "accessor" | "field";
            name: ESDecorateName;
            static: boolean;
            private: boolean;
            access: ESDecorateClassElementAccess;
            metadata: Expression;
        }
        interface ESDecorateClassElementAccess {
            get?: boolean;
            set?: boolean;
        }
        type ESDecorateName = {
            computed: true;
            name: Expression;
        } | {
            computed: false;
            name: Identifier | PrivateIdentifier;
        };
        type ESDecorateContext = ESDecorateClassContext | ESDecorateClassElementContext;
        interface EmitHelperFactory {
            getUnscopedHelperName(name: string): Identifier;
            createDecorateHelper(decoratorExpressions: readonly Expression[], target: Expression, memberName?: Expression, descriptor?: Expression): Expression;
            createMetadataHelper(metadataKey: string, metadataValue: Expression): Expression;
            createParamHelper(expression: Expression, parameterOffset: number): Expression;
            createESDecorateHelper(ctor: Expression, descriptorIn: Expression, decorators: Expression, contextIn: ESDecorateContext, initializers: Expression, extraInitializers: Expression): Expression;
            createRunInitializersHelper(thisArg: Expression, initializers: Expression, value?: Expression): Expression;
            createAssignHelper(attributesSegments: readonly Expression[]): Expression;
            createAwaitHelper(expression: Expression): Expression;
            createAsyncGeneratorHelper(generatorFunc: FunctionExpression, hasLexicalThis: boolean): Expression;
            createAsyncDelegatorHelper(expression: Expression): Expression;
            createAsyncValuesHelper(expression: Expression): Expression;
            createRestHelper(value: Expression, elements: readonly BindingOrAssignmentElement[], computedTempVariables: readonly Expression[] | undefined, location: TextRange): Expression;
            createAwaiterHelper(hasLexicalThis: boolean, argumentsExpression: Expression | undefined, promiseConstructor: EntityName | Expression | undefined, parameters: readonly ParameterDeclaration[] | undefined, body: Block): Expression;
            createExtendsHelper(name: Identifier): Expression;
            createTemplateObjectHelper(cooked: ArrayLiteralExpression, raw: ArrayLiteralExpression): Expression;
            createSpreadArrayHelper(to: Expression, from: Expression, packFrom: boolean): Expression;
            createPropKeyHelper(expr: Expression): Expression;
            createSetFunctionNameHelper(f: Expression, name: Expression, prefix?: string): Expression;
            createValuesHelper(expression: Expression): Expression;
            createReadHelper(iteratorRecord: Expression, count: number | undefined): Expression;
            createGeneratorHelper(body: FunctionExpression): Expression;
            createImportStarHelper(expression: Expression): Expression;
            createImportStarCallbackHelper(): Expression;
            createImportDefaultHelper(expression: Expression): Expression;
            createExportStarHelper(moduleExpression: Expression, exportsExpression?: Expression): Expression;
            createClassPrivateFieldGetHelper(receiver: Expression, state: Identifier, kind: PrivateIdentifierKind, f: Identifier | undefined): Expression;
            createClassPrivateFieldSetHelper(receiver: Expression, state: Identifier, value: Expression, kind: PrivateIdentifierKind, f: Identifier | undefined): Expression;
            createClassPrivateFieldInHelper(state: Identifier, receiver: Expression): Expression;
            createAddDisposableResourceHelper(envBinding: Expression, value: Expression, async: boolean): Expression;
            createDisposeResourcesHelper(envBinding: Expression): Expression;
            createRewriteRelativeImportExtensionsHelper(expression: Expression): Expression;
        }
        const asyncSuperHelper: EmitHelper;
        const advancedAsyncSuperHelper: EmitHelper;
        function isNumericLiteral(node: Node): node is NumericLiteral;
        function isBigIntLiteral(node: Node): node is BigIntLiteral;
        function isStringLiteral(node: Node): node is StringLiteral;
        function isJsxText(node: Node): node is JsxText;
        function isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;
        function isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;
        function isTemplateHead(node: Node): node is TemplateHead;
        function isTemplateMiddle(node: Node): node is TemplateMiddle;
        function isTemplateTail(node: Node): node is TemplateTail;
        function isDotDotDotToken(node: Node): node is DotDotDotToken;
        function isCommaToken(node: Node): node is Token<SyntaxKind.CommaToken>;
        function isPlusToken(node: Node): node is PlusToken;
        function isMinusToken(node: Node): node is MinusToken;
        function isAsteriskToken(node: Node): node is AsteriskToken;
        function isExclamationToken(node: Node): node is ExclamationToken;
        function isQuestionToken(node: Node): node is QuestionToken;
        function isColonToken(node: Node): node is ColonToken;
        function isQuestionDotToken(node: Node): node is QuestionDotToken;
        function isEqualsGreaterThanToken(node: Node): node is EqualsGreaterThanToken;
        function isIdentifier(node: Node): node is Identifier;
        function isPrivateIdentifier(node: Node): node is PrivateIdentifier;
        function isExportModifier(node: Node): node is ExportKeyword;
        function isDefaultModifier(node: Node): node is DefaultKeyword;
        function isAsyncModifier(node: Node): node is AsyncKeyword;
        function isAssertsKeyword(node: Node): node is AssertsKeyword;
        function isAwaitKeyword(node: Node): node is AwaitKeyword;
        function isReadonlyKeyword(node: Node): node is ReadonlyKeyword;
        function isStaticModifier(node: Node): node is StaticKeyword;
        function isAbstractModifier(node: Node): node is AbstractKeyword;
        function isOverrideModifier(node: Node): node is OverrideKeyword;
        function isAccessorModifier(node: Node): node is AccessorKeyword;
        function isSuperKeyword(node: Node): node is SuperExpression;
        function isImportKeyword(node: Node): node is ImportExpression;
        function isCaseKeyword(node: Node): node is CaseKeyword;
        function isQualifiedName(node: Node): node is QualifiedName;
        function isComputedPropertyName(node: Node): node is ComputedPropertyName;
        function isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;
        function isParameter(node: Node): node is ParameterDeclaration;
        function isDecorator(node: Node): node is Decorator;
        function isPropertySignature(node: Node): node is PropertySignature;
        function isPropertyDeclaration(node: Node): node is PropertyDeclaration;
        function isMethodSignature(node: Node): node is MethodSignature;
        function isMethodDeclaration(node: Node): node is MethodDeclaration;
        function isClassStaticBlockDeclaration(node: Node): node is ClassStaticBlockDeclaration;
        function isConstructorDeclaration(node: Node): node is ConstructorDeclaration;
        function isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;
        function isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;
        function isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;
        function isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;
        function isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;
        function isTypePredicateNode(node: Node): node is TypePredicateNode;
        function isTypeReferenceNode(node: Node): node is TypeReferenceNode;
        function isFunctionTypeNode(node: Node): node is FunctionTypeNode;
        function isConstructorTypeNode(node: Node): node is ConstructorTypeNode;
        function isTypeQueryNode(node: Node): node is TypeQueryNode;
        function isTypeLiteralNode(node: Node): node is TypeLiteralNode;
        function isArrayTypeNode(node: Node): node is ArrayTypeNode;
        function isTupleTypeNode(node: Node): node is TupleTypeNode;
        function isNamedTupleMember(node: Node): node is NamedTupleMember;
        function isOptionalTypeNode(node: Node): node is OptionalTypeNode;
        function isRestTypeNode(node: Node): node is RestTypeNode;
        function isUnionTypeNode(node: Node): node is UnionTypeNode;
        function isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;
        function isConditionalTypeNode(node: Node): node is ConditionalTypeNode;
        function isInferTypeNode(node: Node): node is InferTypeNode;
        function isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode;
        function isThisTypeNode(node: Node): node is ThisTypeNode;
        function isTypeOperatorNode(node: Node): node is TypeOperatorNode;
        function isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode;
        function isMappedTypeNode(node: Node): node is MappedTypeNode;
        function isLiteralTypeNode(node: Node): node is LiteralTypeNode;
        function isImportTypeNode(node: Node): node is ImportTypeNode;
        function isTemplateLiteralTypeSpan(node: Node): node is TemplateLiteralTypeSpan;
        function isTemplateLiteralTypeNode(node: Node): node is TemplateLiteralTypeNode;
        function isObjectBindingPattern(node: Node): node is ObjectBindingPattern;
        function isArrayBindingPattern(node: Node): node is ArrayBindingPattern;
        function isBindingElement(node: Node): node is BindingElement;
        function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;
        function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;
        function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;
        function isElementAccessExpression(node: Node): node is ElementAccessExpression;
        function isCallExpression(node: Node): node is CallExpression;
        function isNewExpression(node: Node): node is NewExpression;
        function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;
        function isTypeAssertionExpression(node: Node): node is TypeAssertion;
        function isParenthesizedExpression(node: Node): node is ParenthesizedExpression;
        function isFunctionExpression(node: Node): node is FunctionExpression;
        function isArrowFunction(node: Node): node is ArrowFunction;
        function isDeleteExpression(node: Node): node is DeleteExpression;
        function isTypeOfExpression(node: Node): node is TypeOfExpression;
        function isVoidExpression(node: Node): node is VoidExpression;
        function isAwaitExpression(node: Node): node is AwaitExpression;
        function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;
        function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;
        function isBinaryExpression(node: Node): node is BinaryExpression;
        function isConditionalExpression(node: Node): node is ConditionalExpression;
        function isTemplateExpression(node: Node): node is TemplateExpression;
        function isYieldExpression(node: Node): node is YieldExpression;
        function isSpreadElement(node: Node): node is SpreadElement;
        function isClassExpression(node: Node): node is ClassExpression;
        function isOmittedExpression(node: Node): node is OmittedExpression;
        function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;
        function isAsExpression(node: Node): node is AsExpression;
        function isSatisfiesExpression(node: Node): node is SatisfiesExpression;
        function isNonNullExpression(node: Node): node is NonNullExpression;
        function isMetaProperty(node: Node): node is MetaProperty;
        function isSyntheticExpression(node: Node): node is SyntheticExpression;
        function isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression;
        function isCommaListExpression(node: Node): node is CommaListExpression;
        function isTemplateSpan(node: Node): node is TemplateSpan;
        function isSemicolonClassElement(node: Node): node is SemicolonClassElement;
        function isBlock(node: Node): node is Block;
        function isVariableStatement(node: Node): node is VariableStatement;
        function isEmptyStatement(node: Node): node is EmptyStatement;
        function isExpressionStatement(node: Node): node is ExpressionStatement;
        function isIfStatement(node: Node): node is IfStatement;
        function isDoStatement(node: Node): node is DoStatement;
        function isWhileStatement(node: Node): node is WhileStatement;
        function isForStatement(node: Node): node is ForStatement;
        function isForInStatement(node: Node): node is ForInStatement;
        function isForOfStatement(node: Node): node is ForOfStatement;
        function isContinueStatement(node: Node): node is ContinueStatement;
        function isBreakStatement(node: Node): node is BreakStatement;
        function isReturnStatement(node: Node): node is ReturnStatement;
        function isWithStatement(node: Node): node is WithStatement;
        function isSwitchStatement(node: Node): node is SwitchStatement;
        function isLabeledStatement(node: Node): node is LabeledStatement;
        function isThrowStatement(node: Node): node is ThrowStatement;
        function isTryStatement(node: Node): node is TryStatement;
        function isDebuggerStatement(node: Node): node is DebuggerStatement;
        function isVariableDeclaration(node: Node): node is VariableDeclaration;
        function isVariableDeclarationList(node: Node): node is VariableDeclarationList;
        function isFunctionDeclaration(node: Node): node is FunctionDeclaration;
        function isClassDeclaration(node: Node): node is ClassDeclaration;
        function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;
        function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;
        function isEnumDeclaration(node: Node): node is EnumDeclaration;
        function isModuleDeclaration(node: Node): node is ModuleDeclaration;
        function isModuleBlock(node: Node): node is ModuleBlock;
        function isCaseBlock(node: Node): node is CaseBlock;
        function isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration;
        function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;
        function isImportDeclaration(node: Node): node is ImportDeclaration;
        function isImportClause(node: Node): node is ImportClause;
        function isImportTypeAssertionContainer(node: Node): node is ImportTypeAssertionContainer;
        function isAssertClause(node: Node): node is AssertClause;
        function isAssertEntry(node: Node): node is AssertEntry;
        function isImportAttributes(node: Node): node is ImportAttributes;
        function isImportAttribute(node: Node): node is ImportAttribute;
        function isNamespaceImport(node: Node): node is NamespaceImport;
        function isNamespaceExport(node: Node): node is NamespaceExport;
        function isNamedImports(node: Node): node is NamedImports;
        function isImportSpecifier(node: Node): node is ImportSpecifier;
        function isExportAssignment(node: Node): node is ExportAssignment;
        function isExportDeclaration(node: Node): node is ExportDeclaration;
        function isNamedExports(node: Node): node is NamedExports;
        function isExportSpecifier(node: Node): node is ExportSpecifier;
        function isModuleExportName(node: Node): node is ModuleExportName;
        function isMissingDeclaration(node: Node): node is MissingDeclaration;
        function isNotEmittedStatement(node: Node): node is NotEmittedStatement;
        function isSyntheticReference(node: Node): node is SyntheticReferenceExpression;
        function isExternalModuleReference(node: Node): node is ExternalModuleReference;
        function isJsxElement(node: Node): node is JsxElement;
        function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;
        function isJsxOpeningElement(node: Node): node is JsxOpeningElement;
        function isJsxClosingElement(node: Node): node is JsxClosingElement;
        function isJsxFragment(node: Node): node is JsxFragment;
        function isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;
        function isJsxClosingFragment(node: Node): node is JsxClosingFragment;
        function isJsxAttribute(node: Node): node is JsxAttribute;
        function isJsxAttributes(node: Node): node is JsxAttributes;
        function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;
        function isJsxExpression(node: Node): node is JsxExpression;
        function isJsxNamespacedName(node: Node): node is JsxNamespacedName;
        function isCaseClause(node: Node): node is CaseClause;
        function isDefaultClause(node: Node): node is DefaultClause;
        function isHeritageClause(node: Node): node is HeritageClause;
        function isCatchClause(node: Node): node is CatchClause;
        function isPropertyAssignment(node: Node): node is PropertyAssignment;
        function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;
        function isSpreadAssignment(node: Node): node is SpreadAssignment;
        function isEnumMember(node: Node): node is EnumMember;
        function isSourceFile(node: Node): node is SourceFile;
        function isBundle(node: Node): node is Bundle;
        function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression;
        function isJSDocNameReference(node: Node): node is JSDocNameReference;
        function isJSDocMemberName(node: Node): node is JSDocMemberName;
        function isJSDocLink(node: Node): node is JSDocLink;
        function isJSDocLinkCode(node: Node): node is JSDocLinkCode;
        function isJSDocLinkPlain(node: Node): node is JSDocLinkPlain;
        function isJSDocAllType(node: Node): node is JSDocAllType;
        function isJSDocUnknownType(node: Node): node is JSDocUnknownType;
        function isJSDocNullableType(node: Node): node is JSDocNullableType;
        function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType;
        function isJSDocOptionalType(node: Node): node is JSDocOptionalType;
        function isJSDocFunctionType(node: Node): node is JSDocFunctionType;
        function isJSDocVariadicType(node: Node): node is JSDocVariadicType;
        function isJSDocNamepathType(node: Node): node is JSDocNamepathType;
        function isJSDoc(node: Node): node is JSDoc;
        function isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral;
        function isJSDocSignature(node: Node): node is JSDocSignature;
        function isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;
        function isJSDocAuthorTag(node: Node): node is JSDocAuthorTag;
        function isJSDocClassTag(node: Node): node is JSDocClassTag;
        function isJSDocCallbackTag(node: Node): node is JSDocCallbackTag;
        function isJSDocPublicTag(node: Node): node is JSDocPublicTag;
        function isJSDocPrivateTag(node: Node): node is JSDocPrivateTag;
        function isJSDocProtectedTag(node: Node): node is JSDocProtectedTag;
        function isJSDocReadonlyTag(node: Node): node is JSDocReadonlyTag;
        function isJSDocOverrideTag(node: Node): node is JSDocOverrideTag;
        function isJSDocOverloadTag(node: Node): node is JSDocOverloadTag;
        function isJSDocDeprecatedTag(node: Node): node is JSDocDeprecatedTag;
        function isJSDocSeeTag(node: Node): node is JSDocSeeTag;
        function isJSDocEnumTag(node: Node): node is JSDocEnumTag;
        function isJSDocParameterTag(node: Node): node is JSDocParameterTag;
        function isJSDocReturnTag(node: Node): node is JSDocReturnTag;
        function isJSDocThisTag(node: Node): node is JSDocThisTag;
        function isJSDocTypeTag(node: Node): node is JSDocTypeTag;
        function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag;
        function isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;
        function isJSDocUnknownTag(node: Node): node is JSDocUnknownTag;
        function isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;
        function isJSDocImplementsTag(node: Node): node is JSDocImplementsTag;
        function isJSDocSatisfiesTag(node: Node): node is JSDocSatisfiesTag;
        function isJSDocThrowsTag(node: Node): node is JSDocThrowsTag;
        function isJSDocImportTag(node: Node): node is JSDocImportTag;
        function isSyntaxList(n: Node): n is SyntaxList;
        function getNodeChildren(node: Node, sourceFile: SourceFileLike): readonly Node[] | undefined;
        function setNodeChildren(node: Node, sourceFile: SourceFileLike, children: readonly Node[]): readonly Node[];
        function unsetNodeChildren(node: Node, origSourceFile: SourceFileLike): void;
        function transferSourceFileChildren(sourceFile: SourceFileLike, targetSourceFile: SourceFileLike): void;
        function createEmptyExports(factory: NodeFactory): ExportDeclaration;
        function createMemberAccessForPropertyName(factory: NodeFactory, target: Expression, memberName: PropertyName, location?: TextRange): MemberExpression;
        function createJsxFactoryExpression(factory: NodeFactory, jsxFactoryEntity: EntityName | undefined, reactNamespace: string, parent: JsxOpeningLikeElement | JsxOpeningFragment): Expression;
        function createExpressionForJsxElement(factory: NodeFactory, callee: Expression, tagName: Expression, props: Expression | undefined, children: readonly Expression[] | undefined, location: TextRange): LeftHandSideExpression;
        function createExpressionForJsxFragment(factory: NodeFactory, jsxFactoryEntity: EntityName | undefined, jsxFragmentFactoryEntity: EntityName | undefined, reactNamespace: string, children: readonly Expression[], parentElement: JsxOpeningFragment, location: TextRange): LeftHandSideExpression;
        function createForOfBindingStatement(factory: NodeFactory, node: ForInitializer, boundValue: Expression): Statement;
        function createExpressionFromEntityName(factory: NodeFactory, node: EntityName | Expression): Expression;
        function createExpressionForPropertyName(factory: NodeFactory, memberName: Exclude<PropertyName, PrivateIdentifier>): Expression;
        function createExpressionForObjectLiteralElementLike(factory: NodeFactory, node: ObjectLiteralExpression, property: ObjectLiteralElementLike, receiver: Expression): Expression | undefined;
        function expandPreOrPostfixIncrementOrDecrementExpression(factory: NodeFactory, node: PrefixUnaryExpression | PostfixUnaryExpression, expression: Expression, recordTempVariable: (node: Identifier) => void, resultVariable: Identifier | undefined): Expression;
        function isInternalName(node: Identifier): boolean;
        function isLocalName(node: Identifier): boolean;
        function isExportName(node: Identifier): boolean;
        function findUseStrictPrologue(statements: readonly Statement[]): Statement | undefined;
        function startsWithUseStrict(statements: readonly Statement[]): boolean;
        function isCommaExpression(node: Expression): node is BinaryExpression & {
            operatorToken: Token<SyntaxKind.CommaToken>;
        };
        function isCommaSequence(node: Expression): node is BinaryExpression & {
            operatorToken: Token<SyntaxKind.CommaToken>;
        } | CommaListExpression;
        function isJSDocTypeAssertion(node: Node): node is JSDocTypeAssertion;
        function getJSDocTypeAssertionType(node: JSDocTypeAssertion): TypeNode;
        function isOuterExpression(node: Node, kinds?: OuterExpressionKinds): node is OuterExpression;
        function skipOuterExpressions<T extends Expression>(node: WrappedExpression<T>): T;
        function skipOuterExpressions(node: Expression, kinds?: OuterExpressionKinds): Expression;
        function skipOuterExpressions(node: Node, kinds?: OuterExpressionKinds): Node;
        function walkUpOuterExpressions(node: Expression, kinds?: OuterExpressionKinds): Node;
        function startOnNewLine<T extends Node>(node: T): T;
        function getExternalHelpersModuleName(node: SourceFile): Identifier | undefined;
        function hasRecordedExternalHelpers(sourceFile: SourceFile): boolean;
        function createExternalHelpersImportDeclarationIfNeeded(nodeFactory: NodeFactory, helperFactory: EmitHelperFactory, sourceFile: SourceFile, compilerOptions: CompilerOptions, hasExportStarsToExportValues?: boolean, hasImportStar?: boolean, hasImportDefault?: boolean): ImportDeclaration | ImportEqualsDeclaration | undefined;
        function getLocalNameForExternalImport(factory: NodeFactory, node: ImportDeclaration | ExportDeclaration | ImportEqualsDeclaration, sourceFile: SourceFile): Identifier | undefined;
        function getExternalModuleNameLiteral(factory: NodeFactory, importNode: ImportDeclaration | ExportDeclaration | ImportEqualsDeclaration | ImportCall, sourceFile: SourceFile, host: EmitHost, resolver: EmitResolver, compilerOptions: CompilerOptions): StringLiteral | undefined;
        function tryGetModuleNameFromFile(factory: NodeFactory, file: SourceFile | undefined, host: EmitHost, options: CompilerOptions): StringLiteral | undefined;
        function getInitializerOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): Expression | undefined;
        function getTargetOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): BindingOrAssignmentElementTarget | undefined;
        function getRestIndicatorOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): BindingOrAssignmentElementRestIndicator | undefined;
        function getPropertyNameOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): Exclude<PropertyName, PrivateIdentifier> | undefined;
        function tryGetPropertyNameOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): Exclude<PropertyName, PrivateIdentifier> | undefined;
        function getElementsOfBindingOrAssignmentPattern(name: BindingOrAssignmentPattern): readonly BindingOrAssignmentElement[];
        function getJSDocTypeAliasName(fullName: JSDocNamespaceBody | undefined): Identifier | undefined;
        function canHaveIllegalType(node: Node): node is HasIllegalType;
        function canHaveIllegalTypeParameters(node: Node): node is HasIllegalTypeParameters;
        function canHaveIllegalDecorators(node: Node): node is HasIllegalDecorators;
        function canHaveIllegalModifiers(node: Node): node is HasIllegalModifiers;
        function isQuestionOrExclamationToken(node: Node): node is QuestionToken | ExclamationToken;
        function isIdentifierOrThisTypeNode(node: Node): node is Identifier | ThisTypeNode;
        function isReadonlyKeywordOrPlusOrMinusToken(node: Node): node is ReadonlyKeyword | PlusToken | MinusToken;
        function isQuestionOrPlusOrMinusToken(node: Node): node is QuestionToken | PlusToken | MinusToken;
        function isModuleName(node: Node): node is ModuleName;
        function isShiftOperatorOrHigher(kind: SyntaxKind): kind is ShiftOperatorOrHigher;
        function isBinaryOperatorToken(node: Node): node is BinaryOperatorToken;
        function createBinaryExpressionTrampoline<TState, TResult>(onEnter: (node: BinaryExpression, prev: TState | undefined) => TState, onLeft: ((left: Expression, userState: TState, node: BinaryExpression) => BinaryExpression | void) | undefined, onOperator: ((operatorToken: BinaryOperatorToken, userState: TState, node: BinaryExpression) => void) | undefined, onRight: ((right: Expression, userState: TState, node: BinaryExpression) => BinaryExpression | void) | undefined, onExit: (node: BinaryExpression, userState: TState) => TResult, foldState: ((userState: TState, result: TResult, side: "left" | "right") => TState) | undefined): (node: BinaryExpression) => TResult;
        function createBinaryExpressionTrampoline<TOuterState, TState, TResult>(onEnter: (node: BinaryExpression, prev: TState | undefined, outerState: TOuterState) => TState, onLeft: ((left: Expression, userState: TState, node: BinaryExpression) => BinaryExpression | void) | undefined, onOperator: ((operatorToken: BinaryOperatorToken, userState: TState, node: BinaryExpression) => void) | undefined, onRight: ((right: Expression, userState: TState, node: BinaryExpression) => BinaryExpression | void) | undefined, onExit: (node: BinaryExpression, userState: TState) => TResult, foldState: ((userState: TState, result: TResult, side: "left" | "right") => TState) | undefined): (node: BinaryExpression, outerState: TOuterState) => TResult;
        function isExportOrDefaultModifier(node: Node): node is ExportKeyword | DefaultKeyword;
        function elideNodes<T extends Node>(factory: NodeFactory, nodes: NodeArray<T>): NodeArray<T>;
        function elideNodes<T extends Node>(factory: NodeFactory, nodes: NodeArray<T> | undefined): NodeArray<T> | undefined;
        function getNodeForGeneratedName(name: GeneratedIdentifier | GeneratedPrivateIdentifier): Node | GeneratedIdentifier | GeneratedPrivateIdentifier;
        function formatGeneratedNamePart(part: string | undefined): string;
        function formatGeneratedNamePart(part: string | GeneratedNamePart | undefined, generateName: (name: GeneratedIdentifier | GeneratedPrivateIdentifier) => string): string;
        function formatGeneratedName(privateName: boolean, prefix: string | undefined, baseName: string, suffix: string | undefined): string;
        function formatGeneratedName(privateName: boolean, prefix: string | GeneratedNamePart | undefined, baseName: string | Identifier | PrivateIdentifier, suffix: string | GeneratedNamePart | undefined, generateName: (name: GeneratedIdentifier | GeneratedPrivateIdentifier) => string): string;
        function createAccessorPropertyBackingField(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, initializer: Expression | undefined): PropertyDeclaration;
        function createAccessorPropertyGetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: readonly Modifier[] | undefined, name: PropertyName, receiver?: Expression): GetAccessorDeclaration;
        function createAccessorPropertySetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: readonly Modifier[] | undefined, name: PropertyName, receiver?: Expression): SetAccessorDeclaration;
        function findComputedPropertyNameCacheAssignment(name: ComputedPropertyName): AssignmentExpression<EqualsToken> & {
            readonly left: GeneratedIdentifier;
        } | undefined;
        function flattenCommaList(node: Expression): Expression[];
        function containsObjectRestOrSpread(node: AssignmentPattern): boolean;
        function setTextRange<T extends TextRange>(range: T, location: TextRange | undefined): T;
        function canHaveModifiers(node: Node): node is HasModifiers;
        function canHaveDecorators(node: Node): node is HasDecorators;
        function isJSDocLikeText(text: string, start: number): boolean;
        function isFileProbablyExternalModule(sourceFile: SourceFile): Node | undefined;
        function forEachChild<T>(node: Node, cbNode: (node: Node) => T | undefined, cbNodes?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
        function forEachChildRecursively<T>(rootNode: Node, cbNode: (node: Node, parent: Node) => T | "skip" | undefined, cbNodes?: (nodes: NodeArray<Node>, parent: Node) => T | "skip" | undefined): T | undefined;
        function createSourceFile(fileName: string, sourceText: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile;
        function parseIsolatedEntityName(text: string, languageVersion: ScriptTarget): EntityName | undefined;
        function parseJsonText(fileName: string, sourceText: string): JsonSourceFile;
        function isExternalModule(file: SourceFile): boolean;
        function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;
        function parseIsolatedJSDocComment(content: string, start?: number, length?: number): JsDocWithDiagnostics | undefined;
        function parseJSDocTypeExpressionForTests(content: string, start?: number, length?: number): {
            jsDocTypeExpression: JSDocTypeExpression;
            diagnostics: Diagnostic[];
        } | undefined;
        function isDeclarationFileName(fileName: string): boolean;
        function getDeclarationFileExtension(fileName: string): string | undefined;
        function processCommentPragmas(context: PragmaContext, sourceText: string): void;
        function processPragmasIntoFields(context: PragmaContext, reportDiagnostic: PragmaDiagnosticReporter): void;
        function tagNamesAreEquivalent(lhs: JsxTagNameExpression, rhs: JsxTagNameExpression): boolean;
        const parseBaseNodeFactory: BaseNodeFactory;
        const parseNodeFactory: NodeFactory;
        interface CreateSourceFileOptions {
            languageVersion: ScriptTarget;
            impliedNodeFormat?: ResolutionMode;
            setExternalModuleIndicator?: (file: SourceFile) => void;
            packageJsonLocations?: readonly string[];
            packageJsonScope?: PackageJsonInfo;
            jsDocParsingMode?: JSDocParsingMode;
        }
        interface JsDocWithDiagnostics {
            jsDoc: JSDoc;
            diagnostics: Diagnostic[];
        }
        type PragmaDiagnosticReporter = (pos: number, length: number, message: DiagnosticMessage) => void;
        function createOptionNameMap(optionDeclarations: readonly CommandLineOption[]): OptionsNameMap;
        function getOptionsNameMap(): OptionsNameMap;
        function createCompilerDiagnosticForInvalidCustomType(opt: CommandLineOptionOfCustomType): Diagnostic;
        function parseCustomTypeOption(opt: CommandLineOptionOfCustomType, value: string | undefined, errors: Diagnostic[]): string | number | undefined;
        function parseListTypeOption(opt: CommandLineOptionOfListType, value: string | undefined, errors: Diagnostic[]): string | (string | number)[] | undefined;
        function parseCommandLineWorker(diagnostics: ParseCommandLineWorkerDiagnostics, commandLine: readonly string[], readFile?: (path: string) => string | undefined): BaseParsedCommandLine;
        function parseCommandLine(commandLine: readonly string[], readFile?: (path: string) => string | undefined): ParsedCommandLine;
        function getOptionFromName(optionName: string, allowShort?: boolean): CommandLineOption | undefined;
        function parseBuildCommand(commandLine: readonly string[]): ParsedBuildCommand;
        function getDiagnosticText(message: DiagnosticMessage, ...args: any[]): string;
        function getParsedCommandLineOfConfigFile(configFileName: string, optionsToExtend: CompilerOptions | undefined, host: ParseConfigFileHost, extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): ParsedCommandLine | undefined;
        function readConfigFile(fileName: string, readFile: (path: string) => string | undefined): {
            config?: any;
            error?: Diagnostic;
        };
        function parseConfigFileTextToJson(fileName: string, jsonText: string): {
            config?: any;
            error?: Diagnostic;
        };
        function readJsonConfigFile(fileName: string, readFile: (path: string) => string | undefined): TsConfigSourceFile;
        function tryReadFile(fileName: string, readFile: (path: string) => string | undefined): string | Diagnostic;
        function convertToObject(sourceFile: JsonSourceFile, errors: Diagnostic[]): any;
        function convertToJson(sourceFile: JsonSourceFile, rootExpression: Expression | undefined, errors: Diagnostic[], returnValue: boolean, jsonConversionNotifier: JsonConversionNotifier | undefined): any;
        function convertToTSConfig(configParseResult: ParsedCommandLine, configFileName: string, host: ConvertToTSConfigHost): TSConfig;
        function optionMapToObject(optionMap: Map<string, CompilerOptionsValue>): object;
        function getNameOfCompilerOptionValue(value: CompilerOptionsValue, customTypeMap: Map<string, string | number>): string | undefined;
        function serializeCompilerOptions(options: CompilerOptions, pathOptions?: {
            configFilePath: string;
            useCaseSensitiveFileNames: boolean;
        }): Map<string, CompilerOptionsValue>;
        function getCompilerOptionsDiffValue(options: CompilerOptions, newLine: string): string;
        function generateTSConfig(options: CompilerOptions, fileNames: readonly string[], newLine: string): string;
        function convertToOptionsWithAbsolutePaths(options: CompilerOptions, toAbsolutePath: (path: string) => string): CompilerOptions;
        function parseJsonConfigFileContent(json: any, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;
        function parseJsonSourceFileConfigFileContent(sourceFile: TsConfigSourceFile, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;
        function setConfigFileInOptions(options: CompilerOptions, configFile: TsConfigSourceFile | undefined): void;
        function handleWatchOptionsConfigDirTemplateSubstitution(watchOptions: WatchOptions | undefined, basePath: string): WatchOptions | undefined;
        function isSolutionConfig(config: ParsedCommandLine): boolean;
        function canJsonReportNoInputFiles(raw: any): boolean;
        function updateErrorForNoInputFiles(fileNames: string[], configFileName: string, configFileSpecs: ConfigFileSpecs, configParseDiagnostics: Diagnostic[], canJsonReportNoInutFiles: boolean): boolean;
        function convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
            options: CompilerOptions;
            errors: Diagnostic[];
        };
        function convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
            options: TypeAcquisition;
            errors: Diagnostic[];
        };
        function convertJsonOption(opt: CommandLineOption, value: any, basePath: string, errors: Diagnostic[], propertyAssignment?: PropertyAssignment, valueExpression?: Expression, sourceFile?: TsConfigSourceFile): CompilerOptionsValue;
        function getFileNamesFromConfigSpecs(configFileSpecs: ConfigFileSpecs, basePath: string, options: CompilerOptions, host: ParseConfigHost, extraFileExtensions?: readonly FileExtensionInfo[]): string[];
        function isExcludedFile(pathToCheck: string, spec: ConfigFileSpecs, basePath: string, useCaseSensitiveFileNames: boolean, currentDirectory: string): boolean;
        function matchesExclude(pathToCheck: string, excludeSpecs: readonly string[] | undefined, useCaseSensitiveFileNames: boolean, currentDirectory: string): boolean;
        function matchesExcludeWorker(pathToCheck: string, excludeSpecs: readonly string[] | undefined, useCaseSensitiveFileNames: boolean, currentDirectory: string, basePath?: string): boolean;
        function convertCompilerOptionsForTelemetry(opts: CompilerOptions): CompilerOptions;
        const inverseJsxOptionMap: Map<string, string>;
        const libs: string[];
        const libMap: Map<string, string>;
        const optionsForWatch: CommandLineOption[];
        const commonOptionsWithBuild: CommandLineOption[];
        const targetOptionDeclaration: CommandLineOptionOfCustomType;
        const moduleOptionDeclaration: CommandLineOptionOfCustomType;
        const optionDeclarations: CommandLineOption[];
        const semanticDiagnosticsOptionDeclarations: readonly CommandLineOption[];
        const affectsEmitOptionDeclarations: readonly CommandLineOption[];
        const affectsDeclarationPathOptionDeclarations: readonly CommandLineOption[];
        const moduleResolutionOptionDeclarations: readonly CommandLineOption[];
        const sourceFileAffectingCompilerOptions: readonly CommandLineOption[];
        const optionsAffectingProgramStructure: readonly CommandLineOption[];
        const transpileOptionValueCompilerOptions: readonly CommandLineOption[];
        const commandLineOptionOfCustomType: readonly CommandLineOptionOfCustomType[];
        const tscBuildOption: CommandLineOption;
        const optionsForBuild: CommandLineOption[];
        const buildOpts: CommandLineOption[];
        const typeAcquisitionDeclarations: CommandLineOption[];
        interface OptionsNameMap {
            optionsNameMap: Map<string, CommandLineOption>;
            shortOptionNames: Map<string, string>;
        }
        const defaultInitCompilerOptions: CompilerOptions;
        interface OptionsBase {
            [option: string]: CompilerOptionsValue | TsConfigSourceFile | undefined;
        }
        interface BaseParsedCommandLine {
            options: OptionsBase;
            watchOptions: WatchOptions | undefined;
            fileNames: string[];
            errors: Diagnostic[];
        }
        interface ParseCommandLineWorkerDiagnostics extends DidYouMeanOptionsDiagnostics {
            getOptionsNameMap: () => OptionsNameMap;
            optionTypeMismatchDiagnostic: DiagnosticMessage;
        }
        const compilerOptionsDidYouMeanDiagnostics: ParseCommandLineWorkerDiagnostics;
        interface ParsedBuildCommand {
            buildOptions: BuildOptions;
            watchOptions: WatchOptions | undefined;
            projects: string[];
            errors: Diagnostic[];
        }
        type DiagnosticReporter = (diagnostic: Diagnostic) => void;
        interface ConfigFileDiagnosticsReporter {
            onUnRecoverableConfigFileDiagnostic: DiagnosticReporter;
        }
        interface ParseConfigFileHost extends ParseConfigHost, ConfigFileDiagnosticsReporter {
            getCurrentDirectory(): string;
        }
        interface JsonConversionNotifier {
            rootOptions: TsConfigOnlyOption;
            onPropertySet(keyText: string, value: any, propertyAssignment: PropertyAssignment, parentOption: TsConfigOnlyOption | undefined, option: CommandLineOption | undefined): void;
        }
        interface TSConfig {
            compilerOptions: CompilerOptions;
            compileOnSave: boolean | undefined;
            exclude?: readonly string[];
            files: readonly string[] | undefined;
            include?: readonly string[];
            references: readonly ProjectReference[] | undefined;
        }
        interface ConvertToTSConfigHost {
            getCurrentDirectory(): string;
            useCaseSensitiveFileNames: boolean;
        }
        interface ParsedTsconfig {
            raw: any;
            options?: CompilerOptions;
            watchOptions?: WatchOptions;
            typeAcquisition?: TypeAcquisition;
            extendedConfigPath?: string | string[];
        }
        interface ExtendedConfigCacheEntry {
            extendedResult: TsConfigSourceFile;
            extendedConfig: ParsedTsconfig | undefined;
        }
        function trace(host: ModuleResolutionHost, message: DiagnosticMessage, ...args: any[]): void;
        function isTraceEnabled(compilerOptions: CompilerOptions, host: ModuleResolutionHost): boolean;
        function updateResolutionField<T>(to: T[] | undefined, value: T[] | undefined): T[] | undefined;
        function getPackageJsonTypesVersionsPaths(typesVersions: MapLike<MapLike<string[]>>): VersionPaths | undefined;
        function getEffectiveTypeRoots(options: CompilerOptions, host: GetEffectiveTypeRootsHost): string[] | undefined;
        function resolveTypeReferenceDirective(typeReferenceDirectiveName: string, containingFile: string | undefined, options: CompilerOptions, host: ModuleResolutionHost, redirectedReference?: ResolvedProjectReference, cache?: TypeReferenceDirectiveResolutionCache, resolutionMode?: ResolutionMode): ResolvedTypeReferenceDirectiveWithFailedLookupLocations;
        function getConditions(options: CompilerOptions, resolutionMode?: ResolutionMode): string[];
        function resolvePackageNameToPackageJson(packageName: string, containingDirectory: string, options: CompilerOptions, host: ModuleResolutionHost, cache: ModuleResolutionCache | undefined): PackageJsonInfo | undefined;
        function getAutomaticTypeDirectiveNames(options: CompilerOptions, host: ModuleResolutionHost): string[];
        function isPackageJsonInfo(entry: PackageJsonInfoCacheEntry | undefined): entry is PackageJsonInfo;
        function isMissingPackageJsonInfo(entry: PackageJsonInfoCacheEntry | undefined): entry is MissingPackageJsonInfo;
        function getKeyForCompilerOptions(options: CompilerOptions, affectingOptionDeclarations: readonly CommandLineOption[]): string;
        function createModeAwareCacheKey(specifier: string, mode: ResolutionMode): ModeAwareCacheKey;
        function createModeAwareCache<T>(): ModeAwareCache<T>;
        function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): ModuleResolutionCache;
        function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache, optionsToRedirectsKey?: Map<CompilerOptions, RedirectsCacheKey>): ModuleResolutionCache;
        function createTypeReferenceDirectiveResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): TypeReferenceDirectiveResolutionCache;
        function createTypeReferenceDirectiveResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache, optionsToRedirectsKey?: Map<CompilerOptions, RedirectsCacheKey>): TypeReferenceDirectiveResolutionCache;
        function getOptionsForLibraryResolution(options: CompilerOptions): CompilerOptions;
        function resolveLibrary(libraryName: string, resolveFrom: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache): ResolvedModuleWithFailedLookupLocations;
        function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache, mode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations | undefined;
        function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, resolutionMode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations;
        function resolveJSModule(moduleName: string, initialDir: string, host: ModuleResolutionHost): string;
        function bundlerModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
        function bundlerModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, conditions?: string[]): ResolvedModuleWithFailedLookupLocations;
        function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
        function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, conditions?: string[], lookupConfig?: boolean): ResolvedModuleWithFailedLookupLocations;
        function nodeNextJsonConfigResolver(moduleName: string, containingFile: string, host: ModuleResolutionHost): ResolvedModuleWithFailedLookupLocations;
        function pathContainsNodeModules(path: string): boolean;
        function parseNodeModuleFromPath(resolved: string, isFolder?: boolean): string | undefined;
        function getEntrypointsFromPackageJsonInfo(packageJsonInfo: PackageJsonInfo, options: CompilerOptions, host: GetPackageJsonEntrypointsHost, cache: ModuleResolutionCache | undefined, resolveJs?: boolean): string[] | false;
        function getTemporaryModuleResolutionState(packageJsonInfoCache: PackageJsonInfoCache | undefined, host: ModuleResolutionHost, options: CompilerOptions): ModuleResolutionState;
        function getPackageScopeForPath(directory: string, state: ModuleResolutionState): PackageJsonInfo | undefined;
        function parsePackageName(moduleName: string): {
            packageName: string;
            rest: string;
        };
        function allKeysStartWithDot(obj: MapLike<unknown>): boolean;
        function comparePatternKeys(a: string, b: string): Comparison;
        function isApplicableVersionedTypesKey(conditions: readonly string[], key: string): boolean;
        function forEachAncestorDirectoryStoppingAtGlobalCache<T, P extends string>(host: ModuleResolutionHost | ModuleSpecifierResolutionHost, directory: P, callback: (directory: P) => T | undefined): T | undefined;
        function getTypesPackageName(packageName: string): string;
        function mangleScopedPackageName(packageName: string): string;
        function getPackageNameFromTypesPackageName(mangledName: string): string;
        function unmangleScopedPackageName(typesPackageName: string): string;
        function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
        function shouldAllowImportingTsExtension(compilerOptions: CompilerOptions, fromFileName?: string): boolean;
        function loadModuleFromGlobalCache(moduleName: string, projectName: string | undefined, compilerOptions: CompilerOptions, host: ModuleResolutionHost, globalCache: string, packageJsonInfoCache: PackageJsonInfoCache): ResolvedModuleWithFailedLookupLocations;
        interface ModuleResolutionState {
            host: ModuleResolutionHost;
            compilerOptions: CompilerOptions;
            traceEnabled: boolean;
            failedLookupLocations: string[] | undefined;
            affectingLocations: string[] | undefined;
            resultFromCache?: ResolvedModuleWithFailedLookupLocations;
            packageJsonInfoCache: PackageJsonInfoCache | undefined;
            features: NodeResolutionFeatures;
            conditions: readonly string[];
            requestContainingDirectory: string | undefined;
            reportDiagnostic: DiagnosticReporter;
            isConfigLookup: boolean;
            candidateIsFromPackageJsonField: boolean;
            resolvedPackageDirectory: boolean;
        }
        interface PackageJsonPathFields {
            typings?: string;
            types?: string;
            typesVersions?: MapLike<MapLike<string[]>>;
            main?: string;
            tsconfig?: string;
            type?: string;
            imports?: object;
            exports?: object;
            name?: string;
            dependencies?: MapLike<string>;
            peerDependencies?: MapLike<string>;
            optionalDependencies?: MapLike<string>;
        }
        interface VersionPaths {
            version: string;
            paths: MapLike<string[]>;
        }
        interface TypeReferenceDirectiveResolutionCache extends PerDirectoryResolutionCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, NonRelativeNameResolutionCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, PackageJsonInfoCache {
            clearAllExceptPackageJsonInfoCache(): void;
        }
        interface ModeAwareCache<T> {
            get(key: string, mode: ResolutionMode): T | undefined;
            set(key: string, mode: ResolutionMode, value: T): this;
            delete(key: string, mode: ResolutionMode): this;
            has(key: string, mode: ResolutionMode): boolean;
            forEach(cb: (elem: T, key: string, mode: ResolutionMode) => void): void;
            size(): number;
        }
        interface PerDirectoryResolutionCache<T> {
            getFromDirectoryCache(name: string, mode: ResolutionMode, directoryName: string, redirectedReference: ResolvedProjectReference | undefined): T | undefined;
            getOrCreateCacheForDirectory(directoryName: string, redirectedReference?: ResolvedProjectReference): ModeAwareCache<T>;
            clear(): void;
            update(options: CompilerOptions): void;
            directoryToModuleNameMap: CacheWithRedirects<Path, ModeAwareCache<T>>;
            isReadonly?: boolean;
        }
        interface NonRelativeNameResolutionCache<T> {
            getFromNonRelativeNameCache(nonRelativeName: string, mode: ResolutionMode, directoryName: string, redirectedReference: ResolvedProjectReference | undefined): T | undefined;
            getOrCreateCacheForNonRelativeName(nonRelativeName: string, mode: ResolutionMode, redirectedReference?: ResolvedProjectReference): PerNonRelativeNameCache<T>;
            clear(): void;
            update(options: CompilerOptions): void;
            isReadonly?: boolean;
        }
        interface PerNonRelativeNameCache<T> {
            get(directory: string): T | undefined;
            set(directory: string, result: T): void;
            isReadonly?: boolean;
        }
        interface ModuleResolutionCache extends PerDirectoryResolutionCache<ResolvedModuleWithFailedLookupLocations>, NonRelativeModuleNameResolutionCache, PackageJsonInfoCache {
            getPackageJsonInfoCache(): PackageJsonInfoCache;
            clearAllExceptPackageJsonInfoCache(): void;
            optionsToRedirectsKey: Map<CompilerOptions, RedirectsCacheKey>;
        }
        interface NonRelativeModuleNameResolutionCache extends NonRelativeNameResolutionCache<ResolvedModuleWithFailedLookupLocations>, PackageJsonInfoCache {
            getOrCreateCacheForModuleName(nonRelativeModuleName: string, mode: ResolutionMode, redirectedReference?: ResolvedProjectReference): PerModuleNameCache;
        }
        interface MissingPackageJsonInfo {
            packageDirectory: string;
            directoryExists: boolean;
        }
        type PackageJsonInfoCacheEntry = PackageJsonInfo | MissingPackageJsonInfo;
        interface PackageJsonInfoCache {
            getPackageJsonInfo(packageJsonPath: string): PackageJsonInfoCacheEntry | undefined;
            setPackageJsonInfo(packageJsonPath: string, info: PackageJsonInfoCacheEntry): void;
            getInternalMap(): Map<Path, PackageJsonInfoCacheEntry> | undefined;
            clear(): void;
            isReadonly?: boolean;
        }
        type PerModuleNameCache = PerNonRelativeNameCache<ResolvedModuleWithFailedLookupLocations>;
        interface CacheWithRedirects<K, V> {
            getMapOfCacheRedirects(redirectedReference: ResolvedProjectReference | undefined): Map<K, V> | undefined;
            getOrCreateMapOfCacheRedirects(redirectedReference: ResolvedProjectReference | undefined): Map<K, V>;
            update(newOptions: CompilerOptions): void;
            clear(): void;
            getOwnMap(): Map<K, V>;
        }
        type RedirectsCacheKey = string & {
            __compilerOptionsKey: any;
        };
        type ModeAwareCacheKey = string & {
            __modeAwareCacheKey: any;
        };
        enum NodeResolutionFeatures {
            None = 0,
            Imports = 2,
            SelfName = 4,
            Exports = 8,
            ExportsPatternTrailers = 16,
            AllFeatures = 30,
            Node16Default = 30,
            NodeNextDefault = 30,
            BundlerDefault = 30,
            EsmMode = 32
        }
        const nodeModulesPathPart = "/node_modules/";
        interface GetPackageJsonEntrypointsHost extends ModuleResolutionHost {
            readDirectory: CompilerHost["readDirectory"];
        }
        interface PackageJsonInfo {
            packageDirectory: string;
            contents: PackageJsonInfoContents;
        }
        interface PackageJsonInfoContents {
            packageJsonContent: PackageJsonPathFields;
            versionPaths: VersionPaths | false | undefined;
            resolvedEntrypoints: string[] | false | undefined;
            peerDependencies: string | false | undefined;
        }
        function getModuleInstanceState(node: ModuleDeclaration, visited?: Map<number, ModuleInstanceState | undefined>): ModuleInstanceState;
        function createFlowNode(flags: FlowFlags, node: unknown, antecedent: FlowNode | FlowNode[] | undefined): FlowNode;
        function bindSourceFile(file: SourceFile, options: CompilerOptions): void;
        function isExportsOrModuleExportsOrAlias(sourceFile: SourceFile, node: Expression): boolean;
        function getContainerFlags(node: Node): ContainerFlags;
        enum ModuleInstanceState {
            NonInstantiated = 0,
            Instantiated = 1,
            ConstEnumOnly = 2
        }
        enum ContainerFlags {
            None = 0,
            IsContainer = 1,
            IsBlockScopedContainer = 2,
            IsControlFlowContainer = 4,
            IsFunctionLike = 8,
            IsFunctionExpression = 16,
            HasLocals = 32,
            IsInterface = 64,
            IsObjectLiteralOrClassExpressionMethodOrAccessor = 128
        }
        function createGetSymbolWalker(getRestTypeOfSignature: (sig: Signature) => Type, getTypePredicateOfSignature: (sig: Signature) => TypePredicate | undefined, getReturnTypeOfSignature: (sig: Signature) => Type, getBaseTypes: (type: InterfaceType) => BaseType[], resolveStructuredTypeMembers: (type: ObjectType) => ResolvedType, getTypeOfSymbol: (sym: Symbol) => Type, getResolvedSymbol: (node: Identifier) => Symbol, getConstraintOfTypeParameter: (typeParameter: TypeParameter) => Type | undefined, getFirstIdentifier: (node: EntityNameOrEntityNameExpression) => Identifier, getTypeArguments: (type: TypeReference) => readonly Type[]): (accept?: (symbol: Symbol) => boolean) => SymbolWalker;
        function getNodeId(node: Node): number;
        function getSymbolId(symbol: Symbol): SymbolId;
        function isInstantiatedModule(node: ModuleDeclaration, preserveConstEnums: boolean): boolean;
        function createTypeChecker(host: TypeCheckerHost): TypeChecker;
        function signatureHasRestParameter(s: Signature): boolean;
        enum TypeFacts {
            None = 0,
            TypeofEQString = 1,
            TypeofEQNumber = 2,
            TypeofEQBigInt = 4,
            TypeofEQBoolean = 8,
            TypeofEQSymbol = 16,
            TypeofEQObject = 32,
            TypeofEQFunction = 64,
            TypeofEQHostObject = 128,
            TypeofNEString = 256,
            TypeofNENumber = 512,
            TypeofNEBigInt = 1024,
            TypeofNEBoolean = 2048,
            TypeofNESymbol = 4096,
            TypeofNEObject = 8192,
            TypeofNEFunction = 16384,
            TypeofNEHostObject = 32768,
            EQUndefined = 65536,
            EQNull = 131072,
            EQUndefinedOrNull = 262144,
            NEUndefined = 524288,
            NENull = 1048576,
            NEUndefinedOrNull = 2097152,
            Truthy = 4194304,
            Falsy = 8388608,
            IsUndefined = 16777216,
            IsNull = 33554432,
            IsUndefinedOrNull = 50331648,
            All = 134217727,
            BaseStringStrictFacts = 3735041,
            BaseStringFacts = 12582401,
            StringStrictFacts = 16317953,
            StringFacts = 16776705,
            EmptyStringStrictFacts = 12123649,
            EmptyStringFacts = 12582401,
            NonEmptyStringStrictFacts = 7929345,
            NonEmptyStringFacts = 16776705,
            BaseNumberStrictFacts = 3734786,
            BaseNumberFacts = 12582146,
            NumberStrictFacts = 16317698,
            NumberFacts = 16776450,
            ZeroNumberStrictFacts = 12123394,
            ZeroNumberFacts = 12582146,
            NonZeroNumberStrictFacts = 7929090,
            NonZeroNumberFacts = 16776450,
            BaseBigIntStrictFacts = 3734276,
            BaseBigIntFacts = 12581636,
            BigIntStrictFacts = 16317188,
            BigIntFacts = 16775940,
            ZeroBigIntStrictFacts = 12122884,
            ZeroBigIntFacts = 12581636,
            NonZeroBigIntStrictFacts = 7928580,
            NonZeroBigIntFacts = 16775940,
            BaseBooleanStrictFacts = 3733256,
            BaseBooleanFacts = 12580616,
            BooleanStrictFacts = 16316168,
            BooleanFacts = 16774920,
            FalseStrictFacts = 12121864,
            FalseFacts = 12580616,
            TrueStrictFacts = 7927560,
            TrueFacts = 16774920,
            SymbolStrictFacts = 7925520,
            SymbolFacts = 16772880,
            ObjectStrictFacts = 7888800,
            ObjectFacts = 16736160,
            FunctionStrictFacts = 7880640,
            FunctionFacts = 16728000,
            VoidFacts = 9830144,
            UndefinedFacts = 26607360,
            NullFacts = 42917664,
            EmptyObjectStrictFacts = 83427327,
            EmptyObjectFacts = 83886079,
            UnknownFacts = 83886079,
            AllTypeofNE = 556800,
            OrFactsMask = 8256,
            AndFactsMask = 134209471
        }
        enum CheckMode {
            Normal = 0,
            Contextual = 1,
            Inferential = 2,
            SkipContextSensitive = 4,
            SkipGenericFunctions = 8,
            IsForSignatureHelp = 16,
            RestBindingElement = 32,
            TypeOnly = 64
        }
        enum SignatureCheckMode {
            None = 0,
            BivariantCallback = 1,
            StrictCallback = 2,
            IgnoreReturnTypes = 4,
            StrictArity = 8,
            StrictTopSignature = 16,
            Callback = 3
        }
        function visitNode<TIn extends Node | undefined, TVisited extends Node | undefined, TOut extends Node>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test: (node: Node) => node is TOut, lift?: (node: readonly Node[]) => Node): TOut | (TIn & undefined) | (TVisited & undefined);
        function visitNode<TIn extends Node | undefined, TVisited extends Node | undefined>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => Node): Node | (TIn & undefined) | (TVisited & undefined);
        function visitNodes<TIn extends Node, TInArray extends NodeArray<TIn> | undefined, TOut extends Node>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test: (node: Node) => node is TOut, start?: number, count?: number): NodeArray<TOut> | (TInArray & undefined);
        function visitNodes<TIn extends Node, TInArray extends NodeArray<TIn> | undefined>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<Node> | (TInArray & undefined);
        function visitArray<TIn extends Node, TInArray extends readonly TIn[] | undefined, TOut extends Node>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test: (node: Node) => node is TOut, start?: number, count?: number): readonly TOut[] | (TInArray & undefined);
        function visitArray<TIn extends Node, TInArray extends readonly TIn[] | undefined>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test?: (node: Node) => boolean, start?: number, count?: number): readonly Node[] | (TInArray & undefined);
        function visitLexicalEnvironment(statements: NodeArray<Statement>, visitor: Visitor, context: TransformationContext, start?: number, ensureUseStrict?: boolean, nodesVisitor?: NodesVisitor): NodeArray<Statement>;
        function visitParameterList(nodes: NodeArray<ParameterDeclaration>, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration>;
        function visitParameterList(nodes: NodeArray<ParameterDeclaration> | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration> | undefined;
        function visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext): FunctionBody;
        function visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext): FunctionBody | undefined;
        function visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext): ConciseBody;
        function visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext, nodeVisitor?: NodeVisitor): FunctionBody;
        function visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext, nodeVisitor?: NodeVisitor): FunctionBody | undefined;
        function visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext, nodeVisitor?: NodeVisitor): ConciseBody;
        function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext): Statement;
        function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext, nodeVisitor?: NodeVisitor): Statement;
        function visitCommaListElements(elements: NodeArray<Expression>, visitor: Visitor, discardVisitor?: Visitor): NodeArray<Expression>;
        function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext | undefined): T;
        function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext | undefined, nodesVisitor?: NodesVisitor, tokenVisitor?: Visitor, nodeVisitor?: NodeVisitor): T;
        function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext | undefined, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
        function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext | undefined, nodesVisitor?: NodesVisitor, tokenVisitor?: Visitor, nodeVisitor?: NodeVisitor): T | undefined;
        function createSourceMapGenerator(host: EmitHost, file: string, sourceRoot: string, sourcesDirectoryPath: string, generatorOptions: SourceMapGeneratorOptions): SourceMapGenerator;
        function getLineInfo(text: string, lineStarts: readonly number[]): LineInfo;
        function tryGetSourceMappingURL(lineInfo: LineInfo): string | undefined;
        function tryParseRawSourceMap(text: string): RawSourceMap | undefined;
        function decodeMappings(mappings: string): MappingsDecoder;
        function sameMapping<T extends Mapping>(left: T, right: T): boolean;
        function isSourceMapping(mapping: Mapping): mapping is SourceMapping;
        function createDocumentPositionMapper(host: DocumentPositionMapperHost, map: RawSourceMap, mapPath: string): DocumentPositionMapper;
        interface SourceMapGeneratorOptions {
            extendedDiagnostics?: boolean;
        }
        const sourceMapCommentRegExpDontCareLineStart: RegExp;
        const sourceMapCommentRegExp: RegExp;
        const whitespaceOrMapCommentRegExp: RegExp;
        interface LineInfo {
            getLineCount(): number;
            getLineText(line: number): string;
        }
        interface MappingsDecoder extends IterableIterator<Mapping> {
            readonly pos: number;
            readonly error: string | undefined;
            readonly state: Required<Mapping>;
        }
        interface Mapping {
            generatedLine: number;
            generatedCharacter: number;
            sourceIndex?: number;
            sourceLine?: number;
            sourceCharacter?: number;
            nameIndex?: number;
        }
        interface SourceMapping extends Mapping {
            sourceIndex: number;
            sourceLine: number;
            sourceCharacter: number;
        }
        const identitySourceMapConsumer: DocumentPositionMapper;
        function getOriginalNodeId(node: Node): number;
        function chainBundle(context: CoreTransformationContext, transformSourceFile: (x: SourceFile) => SourceFile): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function getExportNeedsImportStarHelper(node: ExportDeclaration): boolean;
        function getImportNeedsImportStarHelper(node: ImportDeclaration): boolean;
        function getImportNeedsImportDefaultHelper(node: ImportDeclaration): boolean;
        function collectExternalModuleInfo(context: TransformationContext, sourceFile: SourceFile): ExternalModuleInfo;
        function isSimpleCopiableExpression(expression: Expression): boolean;
        function isSimpleInlineableExpression(expression: Expression): boolean;
        function isCompoundAssignment(kind: BinaryOperator): kind is CompoundAssignmentOperator;
        function getNonAssignmentOperatorForCompoundAssignment(kind: CompoundAssignmentOperator): LogicalOperatorOrHigher | SyntaxKind.QuestionQuestionToken;
        function getSuperCallFromStatement(statement: Statement): SuperCall | undefined;
        function findSuperStatementIndexPath(statements: NodeArray<Statement>, start: number): number[];
        function getProperties(node: ClassExpression | ClassDeclaration, requireInitializer: true, isStatic: boolean): readonly InitializedPropertyDeclaration[];
        function getProperties(node: ClassExpression | ClassDeclaration, requireInitializer: boolean, isStatic: boolean): readonly PropertyDeclaration[];
        function getStaticPropertiesAndClassStaticBlock(node: ClassExpression | ClassDeclaration): readonly (PropertyDeclaration | ClassStaticBlockDeclaration)[];
        function getStaticPropertiesAndClassStaticBlock(node: ClassExpression | ClassDeclaration): readonly (PropertyDeclaration | ClassStaticBlockDeclaration)[];
        function isInitializedProperty(member: ClassElement): member is PropertyDeclaration & {
            initializer: Expression;
        };
        function isNonStaticMethodOrAccessorWithPrivateName(member: ClassElement): member is PrivateIdentifierMethodDeclaration | PrivateIdentifierAccessorDeclaration | PrivateIdentifierAutoAccessorPropertyDeclaration;
        function getAllDecoratorsOfClass(node: ClassLikeDeclaration, useLegacyDecorators: boolean): AllDecorators | undefined;
        function getAllDecoratorsOfClassElement(member: ClassElement, parent: ClassLikeDeclaration, useLegacyDecorators: boolean): AllDecorators | undefined;
        function newPrivateEnvironment<TData, TEntry>(data: TData): PrivateEnvironment<TData, TEntry>;
        function getPrivateIdentifier<TData, TEntry>(privateEnv: PrivateEnvironment<TData, TEntry> | undefined, name: PrivateIdentifier): TEntry | undefined;
        function setPrivateIdentifier<TData, TEntry>(privateEnv: PrivateEnvironment<TData, TEntry>, name: PrivateIdentifier, entry: TEntry): void;
        function accessPrivateIdentifier<TEnvData, TPrivateEnvData, TPrivateEntry>(env: LexicalEnvironment<TEnvData, TPrivateEnvData, TPrivateEntry> | undefined, name: PrivateIdentifier): TPrivateEntry | undefined;
        function isSimpleParameterList(nodes: NodeArray<ParameterDeclaration>): boolean;
        function rewriteModuleSpecifier(node: Expression, compilerOptions: CompilerOptions): Expression;
        function rewriteModuleSpecifier(node: Expression | undefined, compilerOptions: CompilerOptions): Expression | undefined;
        interface ExternalModuleInfo {
            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];
            externalHelpersImportDeclaration: ImportDeclaration | ImportEqualsDeclaration | undefined;
            exportSpecifiers: IdentifierNameMap<ExportSpecifier[]>;
            exportedBindings: Identifier[][];
            exportedNames: ModuleExportName[] | undefined;
            exportedFunctions: Set<FunctionDeclaration>;
            exportEquals: ExportAssignment | undefined;
            hasExportStarsToExportValues: boolean;
        }
        class IdentifierNameMap<V> {
            private readonly _map;
            get size(): number;
            has(key: Identifier): boolean;
            get(key: Identifier): V | undefined;
            set(key: Identifier, value: V): this;
            delete(key: Identifier): boolean;
            clear(): void;
            values(): MapIterator<V>;
            private static toKey;
        }
        interface PrivateEnvironment<TData, TEntry> {
            readonly data: TData;
            identifiers?: Map<__String, TEntry>;
            generatedIdentifiers?: Map<Node, TEntry>;
        }
        interface LexicalEnvironment<in out TEnvData, TPrivateEnvData, TPrivateEntry> {
            data: TEnvData;
            privateEnv?: PrivateEnvironment<TPrivateEnvData, TPrivateEntry>;
            readonly previous: LexicalEnvironment<TEnvData, TPrivateEnvData, TPrivateEntry> | undefined;
        }
        function flattenDestructuringAssignment(node: VariableDeclaration | DestructuringAssignment, visitor: (node: Node) => VisitResult<Node | undefined>, context: TransformationContext, level: FlattenLevel, needsValue?: boolean, createAssignmentCallback?: (name: Identifier, value: Expression, location?: TextRange) => Expression): Expression;
        function flattenDestructuringBinding(node: VariableDeclaration | ParameterDeclaration, visitor: (node: Node) => VisitResult<Node | undefined>, context: TransformationContext, level: FlattenLevel, rval?: Expression, hoistTempVariables?: boolean, skipInitializer?: boolean): VariableDeclaration[];
        enum FlattenLevel {
            All = 0,
            ObjectRest = 1
        }
        function isClassThisAssignmentBlock(node: Node): node is ClassThisAssignmentBlock;
        function classHasClassThisAssignment(node: ClassLikeDeclaration): boolean;
        function injectClassThisAssignmentIfMissing<T extends ClassLikeDeclaration>(factory: NodeFactory, node: T, classThis: Identifier, thisExpression?: ThisExpression): Extract<ClassLikeDeclaration, Pick<T, "kind">>;
        type ClassThisAssignmentBlock = ClassStaticBlockDeclaration & {
            readonly body: Block & {
                readonly statements: NodeArray<Statement> & readonly [
                    ExpressionStatement & {
                        readonly expression: AssignmentExpression<EqualsToken> & {
                            readonly left: Identifier;
                            readonly right: ThisExpression;
                        };
                    }
                ];
            };
        };
        function isClassNamedEvaluationHelperBlock(node: Node): node is ClassNamedEvaluationHelperBlock;
        function classHasExplicitlyAssignedName(node: ClassLikeDeclaration): boolean;
        function classHasDeclaredOrExplicitlyAssignedName(node: ClassLikeDeclaration): boolean;
        function injectClassNamedEvaluationHelperBlockIfMissing<T extends ClassLikeDeclaration>(context: TransformationContext, node: T, assignedName: Expression, thisExpression?: Expression): Extract<ClassLikeDeclaration, Pick<T, "kind">>;
        function transformNamedEvaluation<T extends NamedEvaluation>(context: TransformationContext, node: T, ignoreEmptyStringLiteral?: boolean, assignedName?: string): Extract<NamedEvaluation, Pick<T, "kind" | keyof T & "operatorToken" | keyof T & "name">>;
        type ClassNamedEvaluationHelperBlock = ClassStaticBlockDeclaration & {
            readonly body: Block & {
                readonly statements: NodeArray<Statement> & readonly [
                    ExpressionStatement & {
                        readonly expression: CallExpression & {
                            readonly expression: Identifier;
                        };
                    }
                ];
            };
        };
        function processTaggedTemplateExpression(context: TransformationContext, node: TaggedTemplateExpression, visitor: Visitor, currentSourceFile: SourceFile, recordTaggedTemplateString: (temp: Identifier) => void, level: ProcessLevel): CallExpression | TaggedTemplateExpression;
        enum ProcessLevel {
            LiftRestriction = 0,
            All = 1
        }
        function transformTypeScript(context: TransformationContext): Transformer<SourceFile | Bundle>;
        function transformClassFields(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function createRuntimeTypeSerializer(context: TransformationContext): RuntimeTypeSerializer;
        type SerializedEntityName = Identifier | PropertyAccessEntityNameExpression;
        type SerializedTypeNode = SerializedEntityName | ConditionalExpression | VoidExpression;
        interface RuntimeTypeSerializerContext {
            currentLexicalScope: SourceFile | Block | ModuleBlock | CaseBlock;
            currentNameScope: ClassLikeDeclaration | undefined;
        }
        interface RuntimeTypeSerializer {
            serializeTypeNode(serializerContext: RuntimeTypeSerializerContext, node: TypeNode): Expression;
            serializeTypeOfNode(serializerContext: RuntimeTypeSerializerContext, node: PropertyDeclaration | ParameterDeclaration | AccessorDeclaration | ClassLikeDeclaration | MethodDeclaration, container: ClassLikeDeclaration): Expression;
            serializeParameterTypesOfNode(serializerContext: RuntimeTypeSerializerContext, node: Node, container: ClassLikeDeclaration): ArrayLiteralExpression;
            serializeReturnTypeOfNode(serializerContext: RuntimeTypeSerializerContext, node: Node): SerializedTypeNode;
        }
        function transformLegacyDecorators(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformESDecorators(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformES2017(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function createSuperAccessVariableStatement(factory: NodeFactory, resolver: EmitResolver, node: FunctionLikeDeclaration, names: Set<__String>): VariableStatement;
        function transformES2018(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformES2019(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformES2020(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformES2021(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformESNext(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformJsx(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformES2016(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformES2015(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformGenerators(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformModule(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformSystemModule(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformECMAScriptModule(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
        function transformImpliedNodeFormatDependentModule(context: TransformationContext): Transformer<SourceFile | Bundle>;
        function canProduceDiagnostics(node: Node): node is DeclarationDiagnosticProducing;
        function createGetSymbolAccessibilityDiagnosticForNodeName(node: DeclarationDiagnosticProducing): (symbolAccessibilityResult: SymbolAccessibilityResult) => SymbolAccessibilityDiagnostic | undefined;
        function createGetSymbolAccessibilityDiagnosticForNode(node: DeclarationDiagnosticProducing): GetSymbolAccessibilityDiagnostic;
        function createGetIsolatedDeclarationErrors(resolver: EmitResolver): (node: Node) => DiagnosticWithLocation;
        type GetSymbolAccessibilityDiagnostic = (symbolAccessibilityResult: SymbolAccessibilityResult) => SymbolAccessibilityDiagnostic | undefined;
        interface SymbolAccessibilityDiagnostic {
            errorNode: Node;
            diagnosticMessage: DiagnosticMessage;
            typeName?: DeclarationName | QualifiedName;
        }
        type DeclarationDiagnosticProducing = VariableDeclaration | PropertyDeclaration | PropertySignature | BindingElement | SetAccessorDeclaration | GetAccessorDeclaration | ConstructSignatureDeclaration | CallSignatureDeclaration | MethodDeclaration | MethodSignature | FunctionDeclaration | ParameterDeclaration | TypeParameterDeclaration | ExpressionWithTypeArguments | ImportEqualsDeclaration | TypeAliasDeclaration | ConstructorDeclaration | IndexSignatureDeclaration | PropertyAccessExpression | ElementAccessExpression | BinaryExpression | JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag;
        function getDeclarationDiagnostics(host: EmitHost, resolver: EmitResolver, file: SourceFile): DiagnosticWithLocation[] | undefined;
        function transformDeclarations(context: TransformationContext): Transformer<SourceFile | Bundle>;
        function getTransformers(compilerOptions: CompilerOptions, customTransformers?: CustomTransformers, emitOnly?: boolean | EmitOnly): EmitTransformers;
        function noEmitSubstitution(_hint: EmitHint, node: Node): Node;
        function noEmitNotification(hint: EmitHint, node: Node, callback: (hint: EmitHint, node: Node) => void): void;
        function transformNodes<T extends Node>(resolver: EmitResolver | undefined, host: EmitHost | undefined, factory: NodeFactory, options: CompilerOptions, nodes: readonly T[], transformers: readonly TransformerFactory<T>[], allowDtsFiles: boolean): TransformationResult<T>;
        const noTransformers: EmitTransformers;
        const nullTransformationContext: TransformationContext;
        function isBuildInfoFile(file: string): boolean;
        function forEachEmittedFile<T>(host: EmitHost, action: (emitFileNames: EmitFileNames, sourceFileOrBundle: SourceFile | Bundle | undefined) => T, sourceFilesOrTargetSourceFile?: readonly SourceFile[] | SourceFile, forceDtsEmit?: boolean, onlyBuildInfo?: boolean, includeBuildInfo?: boolean): T | undefined;
        function getTsBuildInfoEmitOutputFilePath(options: CompilerOptions): string | undefined;
        function getOutputPathsFor(sourceFile: SourceFile | Bundle, host: EmitHost, forceDtsPaths: boolean): EmitFileNames;
        function getOutputExtension(fileName: string, options: Pick<CompilerOptions, "jsx">): Extension;
        function getOutputDeclarationFileName(inputFileName: string, configFile: ParsedCommandLine, ignoreCase: boolean, getCommonSourceDirectory?: () => string): string;
        function getOutputDeclarationFileNameWorker(inputFileName: string, options: CompilerOptions, ignoreCase: boolean, getCommonSourceDirectory: () => string): string;
        function getOutputJSFileNameWorker(inputFileName: string, options: CompilerOptions, ignoreCase: boolean, getCommonSourceDirectory: () => string): string;
        function getCommonSourceDirectory(options: CompilerOptions, emittedFiles: () => readonly string[], currentDirectory: string, getCanonicalFileName: GetCanonicalFileName, checkSourceFilesBelongToPath?: (commonSourceDirectory: string) => void): string;
        function getCommonSourceDirectoryOfConfig({ options, fileNames }: ParsedCommandLine, ignoreCase: boolean): string;
        function getAllProjectOutputs(configFile: ParsedCommandLine, ignoreCase: boolean): readonly string[];
        function getOutputFileNames(commandLine: ParsedCommandLine, inputFileName: string, ignoreCase: boolean): readonly string[];
        function getFirstProjectOutput(configFile: ParsedCommandLine, ignoreCase: boolean): string;
        function emitResolverSkipsTypeChecking(emitOnly: boolean | EmitOnly | undefined, forceDtsEmit: boolean | undefined): boolean;
        function emitFiles(resolver: EmitResolver, host: EmitHost, targetSourceFile: SourceFile | undefined, { scriptTransformers, declarationTransformers }: EmitTransformers, emitOnly: boolean | EmitOnly | undefined, onlyBuildInfo: boolean, forceDtsEmit?: boolean, skipBuildInfo?: boolean): EmitResult;
        function getBuildInfoText(buildInfo: BuildInfo): string;
        function getBuildInfo(buildInfoFile: string, buildInfoText: string): BuildInfo | undefined;
        function createPrinter(printerOptions?: PrinterOptions, handlers?: PrintHandlers): Printer;
        const notImplementedResolver: EmitResolver;
        const createPrinterWithDefaults: () => Printer;
        const createPrinterWithRemoveComments: () => Printer;
        const createPrinterWithRemoveCommentsNeverAsciiEscape: () => Printer;
        const createPrinterWithRemoveCommentsOmitTrailingSemicolon: () => Printer;
        function createCachedDirectoryStructureHost(host: DirectoryStructureHost, currentDirectory: string, useCaseSensitiveFileNames: boolean): CachedDirectoryStructureHost | undefined;
        function updateSharedExtendedConfigFileWatcher<T>(projectPath: T, options: CompilerOptions | undefined, extendedConfigFilesMap: Map<Path, SharedExtendedConfigFileWatcher<T>>, createExtendedConfigFileWatch: (extendedConfigPath: string, extendedConfigFilePath: Path) => FileWatcher, toPath: (fileName: string) => Path): void;
        function clearSharedExtendedConfigFileWatcher<T>(projectPath: T, extendedConfigFilesMap: Map<Path, SharedExtendedConfigFileWatcher<T>>): void;
        function cleanExtendedConfigCache(extendedConfigCache: Map<string, ExtendedConfigCacheEntry>, extendedConfigFilePath: Path, toPath: (fileName: string) => Path): void;
        function updateMissingFilePathsWatch(program: Program, missingFileWatches: Map<Path, FileWatcher>, createMissingFileWatch: (missingFilePath: Path, missingFileName: string) => FileWatcher): void;
        function updateWatchingWildcardDirectories<T extends FileWatcher>(existingWatchedForWildcards: Map<string, WildcardDirectoryWatcher<T>>, wildcardDirectories: MapLike<WatchDirectoryFlags> | undefined, watchDirectory: (directory: string, flags: WatchDirectoryFlags) => T): void;
        function isIgnoredFileFromWildCardWatching({ watchedDirPath, fileOrDirectory, fileOrDirectoryPath, configFileName, options, program, extraFileExtensions, currentDirectory, useCaseSensitiveFileNames, writeLog, toPath, getScriptKind }: IsIgnoredFileFromWildCardWatchingInput): boolean;
        function isEmittedFileOfProgram(program: Program | undefined, file: string): boolean;
        function getWatchFactory<X, Y = undefined>(host: WatchFactoryHost, watchLogLevel: WatchLogLevel, log: (s: string) => void, getDetailWatchInfo?: GetDetailWatchInfo<X, Y>): WatchFactory<X, Y>;
        function getFallbackOptions(options: WatchOptions | undefined): WatchOptions;
        function closeFileWatcherOf<T extends {
            watcher: FileWatcher;
        }>(objWithWatcher: T): void;
        interface DirectoryStructureHost {
            fileExists(path: string): boolean;
            readFile(path: string, encoding?: string): string | undefined;
            directoryExists?(path: string): boolean;
            getDirectories?(path: string): string[];
            readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
            realpath?(path: string): string;
            createDirectory?(path: string): void;
            writeFile?(path: string, data: string, writeByteOrderMark?: boolean): void;
        }
        interface FileAndDirectoryExistence {
            fileExists: boolean;
            directoryExists: boolean;
        }
        interface CachedDirectoryStructureHost extends DirectoryStructureHost {
            useCaseSensitiveFileNames: boolean;
            getDirectories(path: string): string[];
            readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
            addOrDeleteFileOrDirectory(fileOrDirectory: string, fileOrDirectoryPath: Path): FileAndDirectoryExistence | undefined;
            addOrDeleteFile(fileName: string, filePath: Path, eventKind: FileWatcherEventKind): void;
            clearCache(): void;
        }
        enum ProgramUpdateLevel {
            Update = 0,
            RootNamesAndUpdate = 1,
            Full = 2
        }
        interface SharedExtendedConfigFileWatcher<T> extends FileWatcher {
            watcher: FileWatcher;
            projects: Set<T>;
        }
        interface WildcardDirectoryWatcher<T extends FileWatcher = FileWatcher> {
            watcher: T;
            flags: WatchDirectoryFlags;
        }
        interface IsIgnoredFileFromWildCardWatchingInput {
            watchedDirPath: Path;
            fileOrDirectory: string;
            fileOrDirectoryPath: Path;
            configFileName: string;
            options: CompilerOptions;
            program: BuilderProgram | Program | readonly string[] | undefined;
            extraFileExtensions?: readonly FileExtensionInfo[];
            currentDirectory: string;
            useCaseSensitiveFileNames: boolean;
            writeLog: (s: string) => void;
            toPath: (fileName: string) => Path;
            getScriptKind?: (fileName: string) => ScriptKind;
        }
        enum WatchLogLevel {
            None = 0,
            TriggerOnly = 1,
            Verbose = 2
        }
        interface WatchFactoryHost {
            watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
            watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
            getCurrentDirectory?(): string;
            useCaseSensitiveFileNames: boolean | (() => boolean);
        }
        interface WatchFactory<X, Y = undefined> {
            watchFile: (file: string, callback: FileWatcherCallback, pollingInterval: PollingInterval, options: WatchOptions | undefined, detailInfo1: X, detailInfo2?: Y) => FileWatcher;
            watchDirectory: (directory: string, callback: DirectoryWatcherCallback, flags: WatchDirectoryFlags, options: WatchOptions | undefined, detailInfo1: X, detailInfo2?: Y) => FileWatcher;
        }
        type GetDetailWatchInfo<X, Y> = (detailInfo1: X, detailInfo2: Y | undefined) => string;
        function findConfigFile(searchPath: string, fileExists: (fileName: string) => boolean, configName?: string): string | undefined;
        function resolveTripleslashReference(moduleName: string, containingFile: string): string;
        function computeCommonSourceDirectoryOfFilenames(fileNames: readonly string[], currentDirectory: string, getCanonicalFileName: GetCanonicalFileName): string;
        function createCompilerHost(options: CompilerOptions, setParentNodes?: boolean): CompilerHost;
        function createGetSourceFile(readFile: ProgramHost<any>["readFile"], setParentNodes: boolean | undefined): CompilerHost["getSourceFile"];
        function createWriteFileMeasuringIO(actualWriteFile: (path: string, data: string, writeByteOrderMark: boolean) => void, createDirectory: (path: string) => void, directoryExists: (path: string) => boolean): CompilerHost["writeFile"];
        function createCompilerHostWorker(options: CompilerOptions, setParentNodes?: boolean, system?: System): CompilerHost;
        function changeCompilerHostLikeToUseCache(host: CompilerHostLikeForCache, toPath: (fileName: string) => Path, getSourceFile?: CompilerHost["getSourceFile"]): CompilerHostLikeWithCache;
        function getPreEmitDiagnostics(program: Program, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        function getPreEmitDiagnostics(program: BuilderProgram, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        function formatDiagnostics(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;
        function formatDiagnostic(diagnostic: Diagnostic, host: FormatDiagnosticsHost): string;
        function formatColorAndReset(text: string, formatStyle: string): string;
        function formatLocation(file: SourceFile, start: number, host: FormatDiagnosticsHost, color?: typeof formatColorAndReset): string;
        function formatDiagnosticsWithColorAndContext(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;
        function flattenDiagnosticMessageText(diag: string | DiagnosticMessageChain | undefined, newLine: string, indent?: number): string;
        function getModeForFileReference(ref: FileReference | string, containingFileMode: ResolutionMode): ResolutionMode;
        function getModeForResolutionAtIndex(file: SourceFile, index: number, compilerOptions: CompilerOptions): ResolutionMode;
        function getModeForResolutionAtIndex(file: SourceFileImportsList, index: number, compilerOptions: CompilerOptions): ResolutionMode;
        function isExclusivelyTypeOnlyImportOrExport(decl: ImportDeclaration | ExportDeclaration | JSDocImportTag): boolean;
        function getModeForUsageLocation(file: SourceFile, usage: StringLiteralLike, compilerOptions: CompilerOptions): ResolutionMode;
        function getResolutionModeOverride(node: ImportAttributes | undefined, grammarErrorOnNode?: (node: Node, diagnostic: DiagnosticMessage) => void): ResolutionMode | undefined;
        function createModuleResolutionLoader(containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, host: ModuleResolutionHost, cache: ModuleResolutionCache | undefined): ResolutionLoader<StringLiteralLike, ResolvedModuleWithFailedLookupLocations, SourceFile>;
        function createTypeReferenceResolutionLoader<T extends FileReference | string>(containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, host: ModuleResolutionHost, cache: TypeReferenceDirectiveResolutionCache | undefined): ResolutionLoader<T, ResolvedTypeReferenceDirectiveWithFailedLookupLocations, SourceFile | undefined>;
        function loadWithModeAwareCache<Entry, SourceFile, ResolutionCache, Resolution>(entries: readonly Entry[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, host: ModuleResolutionHost, resolutionCache: ResolutionCache | undefined, createLoader: (containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, host: ModuleResolutionHost, resolutionCache: ResolutionCache | undefined) => ResolutionLoader<Entry, Resolution, SourceFile>): readonly Resolution[];
        function getInferredLibraryNameResolveFrom(options: CompilerOptions, currentDirectory: string, libFileName: string): string;
        function getLibraryNameFromLibFileName(libFileName: string): string;
        function isReferencedFile(reason: FileIncludeReason | undefined): reason is ReferencedFile;
        function isReferenceFileLocation(location: ReferenceFileLocation | SyntheticReferenceFileLocation): location is ReferenceFileLocation;
        function getReferencedFileLocation(program: Program, ref: ReferencedFile): ReferenceFileLocation | SyntheticReferenceFileLocation;
        function isProgramUptoDate(program: Program | undefined, rootFileNames: string[], newOptions: CompilerOptions, getSourceVersion: (path: Path, fileName: string) => string | undefined, fileExists: (fileName: string) => boolean, hasInvalidatedResolutions: HasInvalidatedResolutions, hasInvalidatedLibResolutions: HasInvalidatedLibResolutions, hasChangedAutomaticTypeDirectiveNames: HasChangedAutomaticTypeDirectiveNames | undefined, getParsedCommandLine: (fileName: string) => ParsedCommandLine | undefined, projectReferences: readonly ProjectReference[] | undefined): boolean;
        function getConfigFileParsingDiagnostics(configFileParseResult: ParsedCommandLine): readonly Diagnostic[];
        function getImpliedNodeFormatForFile(fileName: string, packageJsonInfoCache: PackageJsonInfoCache | undefined, host: ModuleResolutionHost, options: CompilerOptions): ResolutionMode;
        function getImpliedNodeFormatForFileWorker(fileName: string, packageJsonInfoCache: PackageJsonInfoCache | undefined, host: ModuleResolutionHost, options: CompilerOptions): ResolutionMode | Partial<CreateSourceFileOptions> | undefined;
        function createProgram(createProgramOptions: CreateProgramOptions): Program;
        function createProgram(rootNames: readonly string[], options: CompilerOptions, host?: CompilerHost, oldProgram?: Program, configFileParsingDiagnostics?: readonly Diagnostic[]): Program;
        function getEmitModuleFormatOfFileWorker(sourceFile: Pick<SourceFile, "fileName" | "impliedNodeFormat" | "packageJsonScope">, options: CompilerOptions): ModuleKind;
        function getImpliedNodeFormatForEmitWorker(sourceFile: Pick<SourceFile, "fileName" | "impliedNodeFormat" | "packageJsonScope">, options: CompilerOptions): ResolutionMode;
        function getDefaultResolutionModeForFileWorker(sourceFile: Pick<SourceFile, "fileName" | "impliedNodeFormat" | "packageJsonScope">, options: CompilerOptions): ResolutionMode;
        function handleNoEmitOptions<T extends BuilderProgram>(program: Program | T, sourceFile: SourceFile | undefined, writeFile: WriteFileCallback | undefined, cancellationToken: CancellationToken | undefined): EmitResult | undefined;
        function filterSemanticDiagnostics(diagnostic: readonly Diagnostic[], option: CompilerOptions): readonly Diagnostic[];
        function parseConfigHostFromCompilerHostLike<T extends BuilderProgram>(host: (CompilerHost | ProgramHost<T>) & {
            onUnRecoverableConfigFileDiagnostic?: DiagnosticReporter;
        }, directoryStructureHost?: DirectoryStructureHost): ParseConfigFileHost;
        function resolveProjectReferencePath(ref: ProjectReference): ResolvedConfigFileName;
        function getResolutionDiagnostic(options: CompilerOptions, { extension }: ResolvedModuleFull, { isDeclarationFile }: {
            isDeclarationFile: SourceFile["isDeclarationFile"];
        }): DiagnosticMessage | undefined;
        function getModuleNameStringLiteralAt({ imports, moduleAugmentations }: SourceFileImportsList, index: number): StringLiteralLike;
        interface CompilerHostLikeForCache {
            fileExists(fileName: string): boolean;
            readFile(fileName: string, encoding?: string): string | undefined;
            directoryExists?(directory: string): boolean;
            createDirectory?(directory: string): void;
            writeFile?: WriteFileCallback;
        }
        interface CompilerHostLikeWithCache {
            originalReadFile: (fileName: string, encoding?: string) => string | undefined;
            originalFileExists: (fileName: string) => boolean;
            originalDirectoryExists: ((directory: string) => boolean) | undefined;
            originalCreateDirectory: ((directory: string) => void) | undefined;
            originalWriteFile: WriteFileCallback | undefined;
            getSourceFileWithCache: ((fileName: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean) => SourceFile | undefined) | undefined;
            readFileWithCache: (fileName: string) => string | undefined;
        }
        interface FormatDiagnosticsHost {
            getCurrentDirectory(): string;
            getCanonicalFileName(fileName: string): string;
            getNewLine(): string;
        }
        enum ForegroundColorEscapeSequences {
            Grey = "\u001B[90m",
            Red = "\u001B[91m",
            Yellow = "\u001B[93m",
            Blue = "\u001B[94m",
            Cyan = "\u001B[96m"
        }
        interface SourceFileImportsList {
            imports: SourceFile["imports"];
            moduleAugmentations: SourceFile["moduleAugmentations"];
            impliedNodeFormat?: ResolutionMode;
            fileName: string;
            packageJsonScope?: SourceFile["packageJsonScope"];
        }
        interface ResolutionWithResolvedFileName {
            resolvedFileName: string | undefined;
            packageId?: PackageId;
        }
        interface ResolutionNameAndModeGetter<Entry, SourceFile> {
            getName(entry: Entry): string;
            getMode(entry: Entry, file: SourceFile, compilerOptions: CompilerOptions): ResolutionMode;
        }
        interface ResolutionLoader<Entry, Resolution, SourceFile> {
            nameAndMode: ResolutionNameAndModeGetter<Entry, SourceFile>;
            resolve(name: string, mode: ResolutionMode): Resolution;
        }
        const moduleResolutionNameAndModeGetter: ResolutionNameAndModeGetter<StringLiteralLike, SourceFile>;
        const inferredTypesContainingFile = "__inferred type names__.ts";
        interface ReferenceFileLocation {
            file: SourceFile;
            pos: number;
            end: number;
            packageId: PackageId | undefined;
        }
        interface SyntheticReferenceFileLocation {
            file: SourceFile;
            packageId: PackageId | undefined;
            text: string;
        }
        const emitSkippedWithNoDiagnostics: EmitResult;
        function createProgramDiagnostics(getCompilerOptionsObjectLiteralSyntax: () => ObjectLiteralExpression | undefined): ProgramDiagnostics;
        interface LazyConfigDiagnostic {
            file: SourceFile;
            diagnostic: DiagnosticMessage;
            args: DiagnosticArguments;
        }
        interface ProgramDiagnostics {
            addConfigDiagnostic(diag: Diagnostic): void;
            addLazyConfigDiagnostic(file: SourceFile, message: DiagnosticMessage, ...args: DiagnosticArguments): void;
            addFileProcessingDiagnostic(diag: FilePreprocessingDiagnostics): void;
            setCommonSourceDirectory(directory: string): void;
            reuseStateFromOldProgram(oldProgramDiagnostics: ProgramDiagnostics, isConfigIdentical: boolean): void;
            getFileProcessingDiagnostics(): FilePreprocessingDiagnostics[] | undefined;
            getFileReasons(): MultiMap<Path, FileIncludeReason>;
            getConfigDiagnostics(): DiagnosticCollection | undefined;
            getLazyConfigDiagnostics(): LazyConfigDiagnostic[] | undefined;
            getCommonSourceDirectory(): string | undefined;
            getCombinedDiagnostics(program: Program): DiagnosticCollection;
        }
        interface EmitOutput {
            outputFiles: OutputFile[];
            emitSkipped: boolean;
            diagnostics: readonly Diagnostic[];
        }
        interface OutputFile {
            name: string;
            writeByteOrderMark: boolean;
            text: string;
            data?: WriteFileCallbackData;
        }
        function getFileEmitOutput(program: Program, sourceFile: SourceFile, emitOnlyDtsFiles: boolean, cancellationToken?: CancellationToken, customTransformers?: CustomTransformers, forceDtsEmit?: boolean): EmitOutput;
        enum SignatureInfo {
            ComputedDts = 0,
            StoredSignatureAtEmit = 1,
            UsedVersion = 2
        }
        interface BuilderState {
            fileInfos: Map<Path, BuilderState.FileInfo>;
            readonly referencedMap?: BuilderState.ReadonlyManyToManyPathMap | undefined;
            useFileVersionAsSignature?: boolean;
            hasCalledUpdateShapeSignature?: Set<Path>;
            oldSignatures?: Map<Path, string | false>;
            allFilesExcludingDefaultLibraryFile?: readonly SourceFile[];
            allFileNames?: readonly string[];
            signatureInfo?: Map<Path, SignatureInfo>;
        }
        namespace BuilderState {
            interface FileInfo {
                readonly version: string;
                signature: string | undefined;
                affectsGlobalScope: true | undefined;
                impliedFormat: ResolutionMode;
            }
            interface ReadonlyManyToManyPathMap {
                getKeys(v: Path): ReadonlySet<Path> | undefined;
                getValues(k: Path): ReadonlySet<Path> | undefined;
                keys(): IterableIterator<Path>;
                size(): number;
            }
            interface ManyToManyPathMap extends ReadonlyManyToManyPathMap {
                deleteKey(k: Path): boolean;
                set(k: Path, v: ReadonlySet<Path>): void;
            }
            function createManyToManyPathMap(): ManyToManyPathMap;
            function canReuseOldState(newReferencedMap: ReadonlyManyToManyPathMap | undefined, oldState: BuilderState | undefined): boolean | undefined;
            function createReferencedMap(options: CompilerOptions): ManyToManyPathMap | undefined;
            function create(newProgram: Program, oldState: Readonly<BuilderState> | undefined, disableUseFileVersionAsSignature: boolean): BuilderState;
            function releaseCache(state: BuilderState): void;
            function getFilesAffectedBy(state: BuilderState, programOfThisState: Program, path: Path, cancellationToken: CancellationToken | undefined, host: HostForComputeHash): readonly SourceFile[];
            function getFilesAffectedByWithOldState(state: BuilderState, programOfThisState: Program, path: Path, cancellationToken: CancellationToken | undefined, host: HostForComputeHash): readonly SourceFile[];
            function updateSignatureOfFile(state: BuilderState, signature: string | undefined, path: Path): void;
            function computeDtsSignature(programOfThisState: Program, sourceFile: SourceFile, cancellationToken: CancellationToken | undefined, host: HostForComputeHash, onNewSignature: (signature: string, sourceFiles: readonly SourceFile[]) => void): void;
            function updateShapeSignature(state: BuilderState, programOfThisState: Program, sourceFile: SourceFile, cancellationToken: CancellationToken | undefined, host: HostForComputeHash, useFileVersionAsSignature?: boolean | undefined): boolean;
            function getAllDependencies(state: BuilderState, programOfThisState: Program, sourceFile: SourceFile): readonly string[];
            function getReferencedByPaths(state: Readonly<BuilderState>, referencedFilePath: Path): Path[];
            function getAllFilesExcludingDefaultLibraryFile(state: BuilderState, programOfThisState: Program, firstSourceFile: SourceFile | undefined): readonly SourceFile[];
        }
        function getBuilderFileEmit(options: CompilerOptions): BuilderFileEmit;
        function getPendingEmitKindWithSeen(optionsOrEmitKind: CompilerOptions | BuilderFileEmit, seenOldOptionsOrEmitKind: CompilerOptions | BuilderFileEmit | undefined, emitOnlyDtsFiles: boolean | undefined, isForDtsErrors: boolean): BuilderFileEmit;
        function isIncrementalBundleEmitBuildInfo(info: IncrementalBuildInfo): info is IncrementalBundleEmitBuildInfo;
        function isIncrementalBuildInfo(info: BuildInfo): info is IncrementalBuildInfo;
        function getBuilderCreationParameters(newProgramOrRootNames: Program | readonly string[] | undefined, hostOrOptions: BuilderProgramHost | CompilerOptions | undefined, oldProgramOrHost?: BuilderProgram | CompilerHost, configFileParsingDiagnosticsOrOldProgram?: readonly Diagnostic[] | BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderCreationParameters;
        function computeSignatureWithDiagnostics(program: Program, sourceFile: SourceFile, text: string, host: HostForComputeHash, data: WriteFileCallbackData | undefined): string;
        function createBuilderProgram(kind: BuilderProgramKind.SemanticDiagnosticsBuilderProgram, builderCreationParameters: BuilderCreationParameters): SemanticDiagnosticsBuilderProgram;
        function createBuilderProgram(kind: BuilderProgramKind.EmitAndSemanticDiagnosticsBuilderProgram, builderCreationParameters: BuilderCreationParameters): EmitAndSemanticDiagnosticsBuilderProgram;
        function toBuilderStateFileInfoForMultiEmit(fileInfo: IncrementalMultiFileEmitBuildInfoFileInfo): BuilderState.FileInfo;
        function toBuilderFileEmit(value: IncrementalBuildInfoFilePendingEmit, fullEmitForOptions: BuilderFileEmit): BuilderFileEmit;
        function toProgramEmitPending(value: IncrementalBuildInfoBundlePendingEmit, options: CompilerOptions | undefined): BuilderFileEmit | undefined;
        function createBuilderProgramUsingIncrementalBuildInfo(buildInfo: IncrementalBuildInfo, buildInfoPath: string, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram;
        function getBuildInfoFileVersionMap(program: IncrementalBuildInfo, buildInfoPath: string, host: Pick<ReadBuildProgramHost, "useCaseSensitiveFileNames" | "getCurrentDirectory">): BuildInfoFileVersionMap;
        function getNonIncrementalBuildInfoRoots(buildInfo: BuildInfo, buildInfoPath: string, host: Pick<ReadBuildProgramHost, "useCaseSensitiveFileNames" | "getCurrentDirectory">): Path[] | undefined;
        function createRedirectedBuilderProgram(state: Pick<ReusableBuilderProgramState, "program" | "compilerOptions">, configFileParsingDiagnostics: readonly Diagnostic[]): BuilderProgram;
        interface ReusableDiagnostic extends ReusableDiagnosticRelatedInformation {
            reportsUnnecessary?: {};
            reportDeprecated?: {};
            source?: string;
            relatedInformation?: ReusableDiagnosticRelatedInformation[];
            skippedOn?: keyof CompilerOptions;
        }
        interface ReusableDiagnosticRelatedInformation {
            category: DiagnosticCategory;
            code: number;
            file: string | undefined | false;
            start: number | undefined;
            length: number | undefined;
            messageText: string | ReusableDiagnosticMessageChain;
        }
        interface ReusableRepopulateInfoChain {
            info: RepopulateDiagnosticChainInfo;
            next?: ReusableDiagnosticMessageChain[];
        }
        type SerializedDiagnosticMessageChain = Omit<DiagnosticMessageChain, "next" | "repopulateInfo"> & {
            next?: ReusableDiagnosticMessageChain[];
        };
        type ReusableDiagnosticMessageChain = SerializedDiagnosticMessageChain | ReusableRepopulateInfoChain;
        type EmitSignature = string | [
            signature: string
        ];
        interface ReusableBuilderProgramState extends BuilderState {
            semanticDiagnosticsPerFile: Map<Path, readonly ReusableDiagnostic[] | readonly Diagnostic[]>;
            emitDiagnosticsPerFile?: Map<Path, readonly ReusableDiagnostic[] | readonly Diagnostic[]> | undefined;
            changedFilesSet?: Set<Path>;
            program?: Program | undefined;
            compilerOptions: CompilerOptions;
            affectedFilesPendingEmit?: ReadonlyMap<Path, BuilderFileEmit>;
            programEmitPending?: BuilderFileEmit;
            checkPending?: true;
            hasReusableDiagnostic?: true;
            emitSignatures?: Map<Path, EmitSignature>;
            outSignature?: EmitSignature;
            latestChangedDtsFile: string | undefined;
            hasErrors?: boolean;
        }
        enum BuilderFileEmit {
            None = 0,
            Js = 1,
            JsMap = 2,
            JsInlineMap = 4,
            DtsErrors = 8,
            DtsEmit = 16,
            DtsMap = 32,
            Dts = 24,
            AllJs = 7,
            AllDtsEmit = 48,
            AllDts = 56,
            All = 63
        }
        interface BuilderProgramState extends BuilderState, ReusableBuilderProgramState {
            semanticDiagnosticsPerFile: Map<Path, readonly Diagnostic[]>;
            emitDiagnosticsPerFile?: Map<Path, readonly Diagnostic[]> | undefined;
            changedFilesSet: Set<Path>;
            affectedFiles?: readonly SourceFile[] | undefined;
            affectedFilesIndex: number | undefined;
            currentChangedFilePath?: Path | undefined;
            seenAffectedFiles: Set<Path> | undefined;
            cleanedDiagnosticsOfLibFiles?: boolean;
            semanticDiagnosticsFromOldState?: Set<Path>;
            hasChangedEmitSignature?: boolean;
            affectedFilesPendingEmit?: Map<Path, BuilderFileEmit>;
            buildInfoEmitPending: boolean;
            seenEmittedFiles: Map<Path, BuilderFileEmit> | undefined;
            seenProgramEmit: BuilderFileEmit | undefined;
            hasErrorsFromOldState?: boolean;
        }
        type IncrementalBuildInfoFileId = number & {
            __incrementalBuildInfoFileIdBrand: any;
        };
        type IncrementalBuildInfoFileIdListId = number & {
            __incrementalBuildInfoFileIdListIdBrand: any;
        };
        type IncrementalBuildInfoDiagnosticOfFile = [
            fileId: IncrementalBuildInfoFileId,
            diagnostics: readonly ReusableDiagnostic[]
        ];
        type IncrementalBuildInfoDiagnostic = IncrementalBuildInfoFileId | IncrementalBuildInfoDiagnosticOfFile;
        type IncrementalBuildInfoEmitDiagnostic = IncrementalBuildInfoDiagnosticOfFile;
        type IncrementalBuildInfoFilePendingEmit = IncrementalBuildInfoFileId | [
            fileId: IncrementalBuildInfoFileId
        ] | [
            fileId: IncrementalBuildInfoFileId,
            emitKind: BuilderFileEmit
        ];
        type IncrementalBuildInfoReferencedMap = [
            fileId: IncrementalBuildInfoFileId,
            fileIdListId: IncrementalBuildInfoFileIdListId
        ][];
        type IncrementalMultiFileEmitBuildInfoBuilderStateFileInfo = Omit<BuilderState.FileInfo, "signature"> & {
            signature: string | false | undefined;
        };
        type IncrementalBuildInfoEmitSignature = IncrementalBuildInfoFileId | [
            fileId: IncrementalBuildInfoFileId,
            signature: EmitSignature | [
            ]
        ];
        type IncrementalMultiFileEmitBuildInfoFileInfo = string | IncrementalMultiFileEmitBuildInfoBuilderStateFileInfo;
        type IncrementalBuildInfoRootStartEnd = [
            start: IncrementalBuildInfoFileId,
            end: IncrementalBuildInfoFileId
        ];
        type IncrementalBuildInfoRoot = IncrementalBuildInfoRootStartEnd | IncrementalBuildInfoFileId;
        type IncrementalBuildInfoResolvedRoot = [
            resolved: IncrementalBuildInfoFileId,
            root: IncrementalBuildInfoFileId
        ];
        interface IncrementalBuildInfoBase extends BuildInfo {
            fileNames: readonly string[];
            root: readonly IncrementalBuildInfoRoot[];
            resolvedRoot: readonly IncrementalBuildInfoResolvedRoot[] | undefined;
            options: CompilerOptions | undefined;
            semanticDiagnosticsPerFile: IncrementalBuildInfoDiagnostic[] | undefined;
            emitDiagnosticsPerFile: IncrementalBuildInfoEmitDiagnostic[] | undefined;
            changeFileSet: readonly IncrementalBuildInfoFileId[] | undefined;
            latestChangedDtsFile?: string | undefined;
            errors: true | undefined;
            checkPending: true | undefined;
        }
        interface IncrementalMultiFileEmitBuildInfo extends IncrementalBuildInfoBase {
            fileInfos: readonly IncrementalMultiFileEmitBuildInfoFileInfo[];
            fileIdsList: readonly (readonly IncrementalBuildInfoFileId[])[] | undefined;
            referencedMap: IncrementalBuildInfoReferencedMap | undefined;
            affectedFilesPendingEmit: IncrementalBuildInfoFilePendingEmit[] | undefined;
            emitSignatures: readonly IncrementalBuildInfoEmitSignature[] | undefined;
        }
        type IncrementalBundleEmitBuildInfoFileInfo = string | BuilderState.FileInfo;
        type IncrementalBuildInfoBundlePendingEmit = BuilderFileEmit | false;
        interface IncrementalBundleEmitBuildInfo extends IncrementalBuildInfoBase {
            fileInfos: readonly IncrementalBundleEmitBuildInfoFileInfo[];
            outSignature: EmitSignature | undefined;
            pendingEmit: IncrementalBuildInfoBundlePendingEmit | undefined;
        }
        type IncrementalBuildInfo = IncrementalMultiFileEmitBuildInfo | IncrementalBundleEmitBuildInfo;
        interface NonIncrementalBuildInfo extends BuildInfo {
            root: readonly string[];
            errors: true | undefined;
            checkPending: true | undefined;
        }
        enum BuilderProgramKind {
            SemanticDiagnosticsBuilderProgram = 0,
            EmitAndSemanticDiagnosticsBuilderProgram = 1
        }
        interface BuilderCreationParameters {
            newProgram: Program;
            host: BuilderProgramHost;
            oldProgram: BuilderProgram | undefined;
            configFileParsingDiagnostics: readonly Diagnostic[];
        }
        function createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): SemanticDiagnosticsBuilderProgram;
        function createSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): SemanticDiagnosticsBuilderProgram;
        function createEmitAndSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): EmitAndSemanticDiagnosticsBuilderProgram;
        function createEmitAndSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): EmitAndSemanticDiagnosticsBuilderProgram;
        function createAbstractBuilder(newProgram: Program, host: BuilderProgramHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): BuilderProgram;
        function createAbstractBuilder(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderProgram;
        type AffectedFileResult<T> = {
            result: T;
            affected: SourceFile | Program;
        } | undefined;
        interface BuilderProgramHost {
            createHash?: (data: string) => string;
            writeFile?: WriteFileCallback;
            storeSignatureInfo?: boolean;
        }
        type HostForComputeHash = Pick<BuilderProgramHost, "createHash" | "storeSignatureInfo">;
        interface BuilderProgram {
            state: ReusableBuilderProgramState;
            hasChangedEmitSignature?(): boolean;
            getProgram(): Program;
            getProgramOrUndefined(): Program | undefined;
            releaseProgram(): void;
            getCompilerOptions(): CompilerOptions;
            getSourceFile(fileName: string): SourceFile | undefined;
            getSourceFiles(): readonly SourceFile[];
            getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
            getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
            getConfigFileParsingDiagnostics(): readonly Diagnostic[];
            getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
            getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
            getAllDependencies(sourceFile: SourceFile): readonly string[];
            getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
            emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;
            emitBuildInfo(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken): EmitResult;
            getCurrentDirectory(): string;
            close(): void;
        }
        interface SemanticDiagnosticsBuilderProgram extends BuilderProgram {
            getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;
        }
        interface EmitAndSemanticDiagnosticsBuilderProgram extends SemanticDiagnosticsBuilderProgram {
            emitNextAffectedFile(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): AffectedFileResult<EmitResult>;
        }
        function removeIgnoredPath(path: Path): Path | undefined;
        function canWatchDirectoryOrFile(pathComponents: Readonly<PathPathComponents>, length?: number): boolean;
        function canWatchDirectoryOrFilePath(path: Path): boolean;
        function canWatchAtTypes(atTypes: Path): boolean;
        function canWatchAffectingLocation(filePath: Path): boolean;
        function getDirectoryToWatchFailedLookupLocation(failedLookupLocation: string, failedLookupLocationPath: Path, rootDir: string, rootPath: Path, rootPathComponents: Readonly<PathPathComponents>, isRootWatchable: boolean, getCurrentDirectory: () => string | undefined, preferNonRecursiveWatch: boolean | undefined): DirectoryOfFailedLookupWatch | undefined;
        function getDirectoryToWatchFailedLookupLocationFromTypeRoot(typeRoot: string, typeRootPath: Path, rootPath: Path, rootPathComponents: Readonly<PathPathComponents>, isRootWatchable: boolean, getCurrentDirectory: () => string | undefined, preferNonRecursiveWatch: boolean | undefined, filterCustomPath: (path: Path) => boolean): Path | undefined;
        function getRootDirectoryOfResolutionCache(rootDirForResolution: string, getCurrentDirectory: () => string | undefined): string;
        function createModuleResolutionLoaderUsingGlobalCache(containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, resolutionHost: ResolutionCacheHost, moduleResolutionCache: ModuleResolutionCache): ResolutionLoader<StringLiteralLike, ResolvedModuleWithFailedLookupLocations, SourceFile>;
        function createResolutionCache(resolutionHost: ResolutionCacheHost, rootDirForResolution: string, logChangesWhenResolvingModule: boolean): ResolutionCache;
        interface HasInvalidatedFromResolutionCache {
            hasInvalidatedResolutions: HasInvalidatedResolutions;
            hasInvalidatedLibResolutions: HasInvalidatedLibResolutions;
        }
        interface ResolutionCache {
            rootDirForResolution: string;
            resolvedModuleNames: Map<Path, ModeAwareCache<CachedResolvedModuleWithFailedLookupLocations>>;
            resolvedTypeReferenceDirectives: Map<Path, ModeAwareCache<CachedResolvedTypeReferenceDirectiveWithFailedLookupLocations>>;
            resolvedLibraries: Map<string, CachedResolvedModuleWithFailedLookupLocations>;
            resolvedFileToResolution: Map<Path, Set<ResolutionWithFailedLookupLocations>>;
            resolutionsWithFailedLookups: Set<ResolutionWithFailedLookupLocations>;
            resolutionsWithOnlyAffectingLocations: Set<ResolutionWithFailedLookupLocations>;
            directoryWatchesOfFailedLookups: Map<string, DirectoryWatchesOfFailedLookup>;
            fileWatchesOfAffectingLocations: Map<string, FileWatcherOfAffectingLocation>;
            packageDirWatchers: Map<Path, PackageDirWatcher>;
            dirPathToSymlinkPackageRefCount: Map<Path, number>;
            startRecordingFilesWithChangedResolutions(): void;
            finishRecordingFilesWithChangedResolutions(): Path[] | undefined;
            watchFailedLookupLocationsOfExternalModuleResolutions<T extends ResolutionWithFailedLookupLocations, R extends ResolutionWithResolvedFileName>(name: string, resolution: T, filePath: Path, getResolutionWithResolvedFileName: GetResolutionWithResolvedFileName<T, R>, deferWatchingNonRelativeResolution: boolean): void;
            resolveModuleNameLiterals(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];
            resolveTypeReferenceDirectiveReferences<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];
            resolveLibrary(libraryName: string, resolveFrom: string, options: CompilerOptions, libFileName: string): ResolvedModuleWithFailedLookupLocations;
            resolveSingleModuleNameWithoutWatching(moduleName: string, containingFile: string): ResolvedModuleWithFailedLookupLocations;
            invalidateResolutionsOfFailedLookupLocations(): boolean;
            invalidateResolutionOfFile(filePath: Path): void;
            removeResolutionsOfFile(filePath: Path): void;
            removeResolutionsFromProjectReferenceRedirects(filePath: Path): void;
            setFilesWithInvalidatedNonRelativeUnresolvedImports(filesWithUnresolvedImports: Map<Path, readonly string[]>): void;
            createHasInvalidatedResolutions(customHasInvalidatedResolutions: HasInvalidatedResolutions, customHasInvalidatedLibResolutions: HasInvalidatedLibResolutions): HasInvalidatedFromResolutionCache;
            hasChangedAutomaticTypeDirectiveNames(): boolean;
            isFileWithInvalidatedNonRelativeUnresolvedImports(path: Path): boolean;
            startCachingPerDirectoryResolution(): void;
            finishCachingPerDirectoryResolution(newProgram: Program | undefined, oldProgram: Program | undefined): void;
            updateTypeRootsWatch(): void;
            closeTypeRootsWatch(): void;
            getModuleResolutionCache(): ModuleResolutionCache;
            clear(): void;
            onChangesAffectModuleResolution(): void;
        }
        interface ResolutionWithFailedLookupLocations {
            failedLookupLocations?: string[];
            affectingLocations?: string[];
            isInvalidated?: boolean;
            files?: Set<Path>;
            alternateResult?: string;
        }
        interface CachedResolvedModuleWithFailedLookupLocations extends ResolvedModuleWithFailedLookupLocations, ResolutionWithFailedLookupLocations {
        }
        interface CachedResolvedTypeReferenceDirectiveWithFailedLookupLocations extends ResolvedTypeReferenceDirectiveWithFailedLookupLocations, ResolutionWithFailedLookupLocations {
        }
        interface ResolutionCacheHost extends MinimalResolutionCacheHost {
            toPath(fileName: string): Path;
            getCanonicalFileName: GetCanonicalFileName;
            getCompilationSettings(): CompilerOptions;
            preferNonRecursiveWatch: boolean | undefined;
            watchDirectoryOfFailedLookupLocation(directory: string, cb: DirectoryWatcherCallback, flags: WatchDirectoryFlags): FileWatcher;
            watchAffectingFileLocation(file: string, cb: FileWatcherCallback): FileWatcher;
            onInvalidatedResolution(): void;
            watchTypeRootsDirectory(directory: string, cb: DirectoryWatcherCallback, flags: WatchDirectoryFlags): FileWatcher;
            onChangedAutomaticTypeDirectiveNames(): void;
            scheduleInvalidateResolutionsOfFailedLookupLocations(): void;
            getCachedDirectoryStructureHost(): CachedDirectoryStructureHost | undefined;
            projectName?: string;
            globalCacheResolutionModuleName?(externalModuleName: string): string;
            writeLog(s: string): void;
            getCurrentProgram(): Program | undefined;
            fileIsOpen(filePath: Path): boolean;
            onDiscoveredSymlink?(): void;
            beforeResolveSingleModuleNameWithoutWatching?(moduleResolutionCache: ModuleResolutionCache): any;
            afterResolveSingleModuleNameWithoutWatching?(moduleResolutionCache: ModuleResolutionCache, moduleName: string, containingFile: string, result: ResolvedModuleWithFailedLookupLocations, data: any): any;
        }
        interface FileWatcherOfAffectingLocation {
            watcher: FileWatcher;
            resolutions: number;
            files: number;
            symlinks: Set<string> | undefined;
        }
        interface DirectoryWatchesOfFailedLookup {
            watcher: FileWatcher;
            refCount: number;
            nonRecursive?: boolean;
        }
        interface DirPathToWatcherOfPackageDirWatcher {
            watcher: DirectoryWatchesOfFailedLookup;
            refCount: number;
        }
        interface PackageDirWatcher {
            dirPathToWatcher: Map<Path, DirPathToWatcherOfPackageDirWatcher>;
            isSymlink: boolean;
        }
        interface DirectoryOfFailedLookupWatch {
            dir: string;
            dirPath: Path;
            nonRecursive?: boolean;
            packageDir?: string;
            packageDirPath?: Path;
        }
        type GetResolutionWithResolvedFileName<T extends ResolutionWithFailedLookupLocations = ResolutionWithFailedLookupLocations, R extends ResolutionWithResolvedFileName = ResolutionWithResolvedFileName> = (resolution: T) => R | undefined;
        function createDiagnosticReporter(system: System, pretty?: boolean): DiagnosticReporter;
        function getLocaleTimeString(system: System): string;
        function createWatchStatusReporter(system: System, pretty?: boolean): WatchStatusReporter;
        function parseConfigFileWithSystem(configFileName: string, optionsToExtend: CompilerOptions, extendedConfigCache: Map<string, ExtendedConfigCacheEntry> | undefined, watchOptionsToExtend: WatchOptions | undefined, system: System, reportDiagnostic: DiagnosticReporter): ParsedCommandLine | undefined;
        function getErrorCountForSummary(diagnostics: readonly Diagnostic[]): number;
        function getFilesInErrorForSummary(diagnostics: readonly Diagnostic[]): (ReportFileInError | undefined)[];
        function getWatchErrorSummaryDiagnosticMessage(errorCount: number): DiagnosticMessage;
        function getErrorSummaryText(errorCount: number, filesInError: readonly (ReportFileInError | undefined)[], newLine: string, host: HasCurrentDirectory): string;
        function isBuilderProgram<T extends BuilderProgram>(program: Program | BuilderProgram): program is T;
        function explainFiles(program: Program, write: (s: string) => void): void;
        function explainIfFileIsRedirectAndImpliedFormat(file: SourceFile, options: CompilerOptions, fileNameConvertor?: (fileName: string) => string): DiagnosticMessageChain[] | undefined;
        function getMatchedFileSpec(program: Program, fileName: string): string | undefined;
        function getMatchedIncludeSpec(program: Program, fileName: string): string | true | undefined;
        function fileIncludeReasonToDiagnostics(program: Program, reason: FileIncludeReason, fileNameConvertor?: (fileName: string) => string): DiagnosticMessageChain;
        function emitFilesAndReportErrors<T extends BuilderProgram>(program: Program | T, reportDiagnostic: DiagnosticReporter, write?: (s: string) => void, reportSummary?: ReportEmitErrorSummary, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): {
            emitResult: EmitResult;
            diagnostics: SortedReadonlyArray<Diagnostic>;
        };
        function emitFilesAndReportErrorsAndGetExitStatus<T extends BuilderProgram>(program: Program | T, reportDiagnostic: DiagnosticReporter, write?: (s: string) => void, reportSummary?: ReportEmitErrorSummary, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): ExitStatus;
        function createWatchHost(system?: System, reportWatchStatus?: WatchStatusReporter): WatchHost;
        function createWatchFactory<Y = undefined>(host: WatchFactoryHost & {
            trace?(s: string): void;
        }, options: {
            extendedDiagnostics?: boolean;
            diagnostics?: boolean;
        }): WatchFactoryWithLog<WatchType, Y>;
        function createCompilerHostFromProgramHost(host: ProgramHost<any>, getCompilerOptions: () => CompilerOptions, directoryStructureHost?: DirectoryStructureHost): CompilerHost;
        function getSourceFileVersionAsHashFromText(host: Pick<CompilerHost, "createHash">, text: string): string;
        function setGetSourceFileAsHashVersioned(compilerHost: CompilerHost): void;
        function createProgramHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system: System, createProgram: CreateProgram<T> | undefined): ProgramHost<T>;
        function createWatchCompilerHostOfConfigFile<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ configFileName, optionsToExtend, watchOptionsToExtend, extraFileExtensions, system, createProgram, reportDiagnostic, reportWatchStatus }: CreateWatchCompilerHostOfConfigFileInput<T>): WatchCompilerHostOfConfigFile<T>;
        function createWatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ rootFiles, options, watchOptions, projectReferences, system, createProgram, reportDiagnostic, reportWatchStatus }: CreateWatchCompilerHostOfFilesAndCompilerOptionsInput<T>): WatchCompilerHostOfFilesAndCompilerOptions<T>;
        function performIncrementalCompilation(input: IncrementalCompilationOptions): ExitStatus;
        const noopFileWatcher: FileWatcher;
        const returnNoopFileWatcher: () => FileWatcher;
        type WatchType = WatchTypeRegistry[keyof WatchTypeRegistry];
        const WatchType: WatchTypeRegistry;
        interface WatchTypeRegistry {
            ConfigFile: "Config file";
            ExtendedConfigFile: "Extended config file";
            SourceFile: "Source file";
            MissingFile: "Missing file";
            WildcardDirectory: "Wild card directory";
            FailedLookupLocations: "Failed Lookup Locations";
            AffectingFileLocation: "File location affecting resolution";
            TypeRoots: "Type roots";
            ConfigFileOfReferencedProject: "Config file of referened project";
            ExtendedConfigOfReferencedProject: "Extended config file of referenced project";
            WildcardDirectoryOfReferencedProject: "Wild card directory of referenced project";
            PackageJson: "package.json file";
            ClosedScriptInfo: "Closed Script info";
            ConfigFileForInferredRoot: "Config file for the inferred project root";
            NodeModules: "node_modules for closed script infos and package.jsons affecting module specifier cache";
            MissingSourceMapFile: "Missing source map file";
            NoopConfigFileForInferredRoot: "Noop Config file for the inferred project root";
            MissingGeneratedFile: "Missing generated file";
            NodeModulesForModuleSpecifierCache: "node_modules for module specifier cache invalidation";
            TypingInstallerLocationFile: "File location for typing installer";
            TypingInstallerLocationDirectory: "Directory location for typing installer";
        }
        interface WatchFactoryWithLog<X, Y = undefined> extends WatchFactory<X, Y> {
            writeLog: (s: string) => void;
        }
        interface CreateWatchCompilerHostInput<T extends BuilderProgram> {
            system: System;
            createProgram?: CreateProgram<T>;
            reportDiagnostic?: DiagnosticReporter;
            reportWatchStatus?: WatchStatusReporter;
        }
        interface CreateWatchCompilerHostOfConfigFileInput<T extends BuilderProgram> extends CreateWatchCompilerHostInput<T> {
            configFileName: string;
            optionsToExtend?: CompilerOptions;
            watchOptionsToExtend?: WatchOptions;
            extraFileExtensions?: readonly FileExtensionInfo[];
        }
        interface CreateWatchCompilerHostOfFilesAndCompilerOptionsInput<T extends BuilderProgram> extends CreateWatchCompilerHostInput<T> {
            rootFiles: string[];
            options: CompilerOptions;
            watchOptions: WatchOptions | undefined;
            projectReferences?: readonly ProjectReference[];
        }
        interface IncrementalCompilationOptions {
            rootNames: readonly string[];
            options: CompilerOptions;
            configFileParsingDiagnostics?: readonly Diagnostic[];
            projectReferences?: readonly ProjectReference[];
            host?: CompilerHost;
            reportDiagnostic?: DiagnosticReporter;
            reportErrorSummary?: ReportEmitErrorSummary;
            afterProgramEmitAndDiagnostics?(program: EmitAndSemanticDiagnosticsBuilderProgram): void;
            system?: System;
        }
        function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram | undefined;
        function createIncrementalCompilerHost(options: CompilerOptions, system?: System): CompilerHost;
        function createIncrementalProgram<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ rootNames, options, configFileParsingDiagnostics, projectReferences, host, createProgram }: IncrementalProgramOptions<T>): T;
        function createWatchCompilerHost<T extends BuilderProgram>(configFileName: string, optionsToExtend: CompilerOptions | undefined, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): WatchCompilerHostOfConfigFile<T>;
        function createWatchCompilerHost<T extends BuilderProgram>(rootFiles: string[], options: CompilerOptions, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, projectReferences?: readonly ProjectReference[], watchOptions?: WatchOptions): WatchCompilerHostOfFilesAndCompilerOptions<T>;
        function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfFilesAndCompilerOptions<T>): WatchOfFilesAndCompilerOptions<T>;
        function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfConfigFile<T>): WatchOfConfigFile<T>;
        interface ReadBuildProgramHost {
            useCaseSensitiveFileNames(): boolean;
            getCurrentDirectory(): string;
            readFile(fileName: string): string | undefined;
            getBuildInfo?(fileName: string, configFilePath: string | undefined): BuildInfo | undefined;
        }
        interface IncrementalProgramOptions<T extends BuilderProgram> {
            rootNames: readonly string[];
            options: CompilerOptions;
            configFileParsingDiagnostics?: readonly Diagnostic[];
            projectReferences?: readonly ProjectReference[];
            host?: CompilerHost;
            createProgram?: CreateProgram<T>;
        }
        type WatchStatusReporter = (diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number) => void;
        type CreateProgram<T extends BuilderProgram> = (rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: T, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[] | undefined) => T;
        interface WatchHost {
            onWatchStatusChange?(diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number): void;
            watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
            watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
            setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;
            clearTimeout?(timeoutId: any): void;
            preferNonRecursiveWatch?: boolean;
        }
        interface ProgramHost<T extends BuilderProgram> {
            createProgram: CreateProgram<T>;
            useCaseSensitiveFileNames(): boolean;
            getNewLine(): string;
            getCurrentDirectory(): string;
            getDefaultLibFileName(options: CompilerOptions): string;
            getDefaultLibLocation?(): string;
            createHash?(data: string): string;
            fileExists(path: string): boolean;
            readFile(path: string, encoding?: string): string | undefined;
            directoryExists?(path: string): boolean;
            getDirectories?(path: string): string[];
            readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
            realpath?(path: string): string;
            trace?(s: string): void;
            getEnvironmentVariable?(name: string): string | undefined;
            resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];
            resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];
            resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];
            resolveTypeReferenceDirectiveReferences?<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];
            resolveLibrary?(libraryName: string, resolveFrom: string, options: CompilerOptions, libFileName: string): ResolvedModuleWithFailedLookupLocations;
            hasInvalidatedLibResolutions?(libFileName: string): boolean;
            hasInvalidatedResolutions?(filePath: Path): boolean;
            getModuleResolutionCache?(): ModuleResolutionCache | undefined;
            jsDocParsingMode?: JSDocParsingMode;
            createDirectory?(path: string): void;
            writeFile?(path: string, data: string, writeByteOrderMark?: boolean): void;
            storeSignatureInfo?: boolean;
            now?(): Date;
        }
        interface WatchCompilerHost<T extends BuilderProgram> extends ProgramHost<T>, WatchHost {
            useSourceOfProjectReferenceRedirect?(): boolean;
            getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
            afterProgramCreate?(program: T): void;
        }
        interface WatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram> extends WatchCompilerHost<T> {
            rootFiles: string[];
            options: CompilerOptions;
            watchOptions?: WatchOptions;
            projectReferences?: readonly ProjectReference[];
        }
        interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T>, ConfigFileDiagnosticsReporter {
            configFileName: string;
            optionsToExtend?: CompilerOptions;
            watchOptionsToExtend?: WatchOptions;
            extraFileExtensions?: readonly FileExtensionInfo[];
            readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
        }
        interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T> {
            configFileParsingResult?: ParsedCommandLine;
            extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>;
        }
        interface Watch<T> {
            getProgram(): T;
            getCurrentProgram(): T;
            close(): void;
            getResolutionCache(): ResolutionCache;
        }
        interface WatchOfConfigFile<T> extends Watch<T> {
        }
        interface WatchOfFilesAndCompilerOptions<T> extends Watch<T> {
            updateRootFileNames(fileNames: string[]): void;
        }
        function resolveConfigFileProjectName(project: string): ResolvedConfigFileName;
        enum UpToDateStatusType {
            Unbuildable = 0,
            UpToDate = 1,
            UpToDateWithUpstreamTypes = 2,
            OutputMissing = 3,
            ErrorReadingFile = 4,
            OutOfDateWithSelf = 5,
            OutOfDateWithUpstream = 6,
            OutOfDateBuildInfoWithPendingEmit = 7,
            OutOfDateBuildInfoWithErrors = 8,
            OutOfDateOptions = 9,
            OutOfDateRoots = 10,
            UpstreamOutOfDate = 11,
            UpstreamBlocked = 12,
            ComputingUpstream = 13,
            TsVersionOutputOfDate = 14,
            UpToDateWithInputFileText = 15,
            ContainerOnly = 16,
            ForceBuild = 17
        }
        type UpToDateStatus = Status.Unbuildable | Status.UpToDate | Status.OutputMissing | Status.ErrorReadingFile | Status.OutOfDateWithSelf | Status.OutOfDateWithUpstream | Status.OutOfDateBuildInfo | Status.OutOfDateRoots | Status.UpstreamOutOfDate | Status.UpstreamBlocked | Status.ComputingUpstream | Status.TsVersionOutOfDate | Status.ContainerOnly | Status.ForceBuild;
        namespace Status {
            interface Unbuildable {
                type: UpToDateStatusType.Unbuildable;
                reason: string;
            }
            interface ContainerOnly {
                type: UpToDateStatusType.ContainerOnly;
            }
            interface UpToDate {
                type: UpToDateStatusType.UpToDate | UpToDateStatusType.UpToDateWithUpstreamTypes | UpToDateStatusType.UpToDateWithInputFileText;
                newestInputFileTime?: Date;
                newestInputFileName?: string;
                oldestOutputFileName: string;
            }
            interface OutputMissing {
                type: UpToDateStatusType.OutputMissing;
                missingOutputFileName: string;
            }
            interface ErrorReadingFile {
                type: UpToDateStatusType.ErrorReadingFile;
                fileName: string;
            }
            interface OutOfDateWithSelf {
                type: UpToDateStatusType.OutOfDateWithSelf;
                outOfDateOutputFileName: string;
                newerInputFileName: string;
            }
            interface OutOfDateBuildInfo {
                type: UpToDateStatusType.OutOfDateBuildInfoWithPendingEmit | UpToDateStatusType.OutOfDateBuildInfoWithErrors | UpToDateStatusType.OutOfDateOptions;
                buildInfoFile: string;
            }
            interface OutOfDateRoots {
                type: UpToDateStatusType.OutOfDateRoots;
                buildInfoFile: string;
                inputFile: Path;
            }
            interface UpstreamOutOfDate {
                type: UpToDateStatusType.UpstreamOutOfDate;
                upstreamProjectName: string;
            }
            interface UpstreamBlocked {
                type: UpToDateStatusType.UpstreamBlocked;
                upstreamProjectName: string;
                upstreamProjectBlocked: boolean;
            }
            interface ComputingUpstream {
                type: UpToDateStatusType.ComputingUpstream;
            }
            interface TsVersionOutOfDate {
                type: UpToDateStatusType.TsVersionOutputOfDate;
                version: string;
            }
            interface OutOfDateWithUpstream {
                type: UpToDateStatusType.OutOfDateWithUpstream;
                outOfDateOutputFileName: string;
                newerProjectName: string;
            }
            interface ForceBuild {
                type: UpToDateStatusType.ForceBuild;
            }
        }
        function isCircularBuildOrder(buildOrder: AnyBuildOrder): buildOrder is CircularBuildOrder;
        function getBuildOrderFromAnyBuildOrder(anyBuildOrder: AnyBuildOrder): BuildOrder;
        function createBuilderStatusReporter(system: System, pretty?: boolean): DiagnosticReporter;
        function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): SolutionBuilderHost<T>;
        function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): SolutionBuilderWithWatchHost<T>;
        function createSolutionBuilder<T extends BuilderProgram>(host: SolutionBuilderHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions): SolutionBuilder<T>;
        function createSolutionBuilderWithWatch<T extends BuilderProgram>(host: SolutionBuilderWithWatchHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions, baseWatchOptions?: WatchOptions): SolutionBuilder<T>;
        interface BuildOptions {
            dry?: boolean;
            force?: boolean;
            verbose?: boolean;
            stopBuildOnErrors?: boolean;
            clean?: boolean;
            watch?: boolean;
            help?: boolean;
            preserveWatchOutput?: boolean;
            listEmittedFiles?: boolean;
            listFiles?: boolean;
            explainFiles?: boolean;
            pretty?: boolean;
            incremental?: boolean;
            assumeChangesOnlyAffectDirectDependencies?: boolean;
            declaration?: boolean;
            declarationMap?: boolean;
            emitDeclarationOnly?: boolean;
            sourceMap?: boolean;
            inlineSourceMap?: boolean;
            traceResolution?: boolean;
            diagnostics?: boolean;
            extendedDiagnostics?: boolean;
            locale?: string;
            generateCpuProfile?: string;
            generateTrace?: string;
            [option: string]: CompilerOptionsValue | undefined;
        }
        type ResolvedConfigFilePath = ResolvedConfigFileName & Path;
        type ReportEmitErrorSummary = (errorCount: number, filesInError: (ReportFileInError | undefined)[]) => void;
        interface ReportFileInError {
            fileName: string;
            line: number;
        }
        interface SolutionBuilderHostBase<T extends BuilderProgram> extends ProgramHost<T> {
            createDirectory?(path: string): void;
            writeFile?(path: string, data: string, writeByteOrderMark?: boolean): void;
            getCustomTransformers?: (project: string) => CustomTransformers | undefined;
            getModifiedTime(fileName: string): Date | undefined;
            setModifiedTime(fileName: string, date: Date): void;
            deleteFile(fileName: string): void;
            getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
            reportDiagnostic: DiagnosticReporter;
            reportSolutionBuilderStatus: DiagnosticReporter;
            afterProgramEmitAndDiagnostics?(program: T): void;
            now?(): Date;
        }
        interface SolutionBuilderHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T> {
            reportErrorSummary?: ReportEmitErrorSummary;
        }
        interface SolutionBuilderWithWatchHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T>, WatchHost {
        }
        type BuildOrder = readonly ResolvedConfigFileName[];
        interface CircularBuildOrder {
            buildOrder: BuildOrder;
            circularDiagnostics: readonly Diagnostic[];
        }
        type AnyBuildOrder = BuildOrder | CircularBuildOrder;
        interface SolutionBuilder<T extends BuilderProgram> {
            build(project?: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;
            clean(project?: string): ExitStatus;
            buildReferences(project: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;
            cleanReferences(project?: string): ExitStatus;
            getNextInvalidatedProject(cancellationToken?: CancellationToken): InvalidatedProject<T> | undefined;
            getBuildOrder(): AnyBuildOrder;
            getUpToDateStatusOfProject(project: string): UpToDateStatus;
            invalidateProject(configFilePath: ResolvedConfigFilePath, updateLevel?: ProgramUpdateLevel): void;
            close(): void;
        }
        enum InvalidatedProjectKind {
            Build = 0,
            UpdateOutputFileStamps = 1
        }
        interface InvalidatedProjectBase {
            readonly kind: InvalidatedProjectKind;
            readonly project: ResolvedConfigFileName;
            readonly projectPath: ResolvedConfigFilePath;
            readonly buildOrder: readonly ResolvedConfigFileName[];
            done(cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): ExitStatus;
            getCompilerOptions(): CompilerOptions;
            getCurrentDirectory(): string;
        }
        interface UpdateOutputFileStampsProject extends InvalidatedProjectBase {
            readonly kind: InvalidatedProjectKind.UpdateOutputFileStamps;
            updateOutputFileStatmps(): void;
        }
        interface BuildInvalidedProject<T extends BuilderProgram> extends InvalidatedProjectBase {
            readonly kind: InvalidatedProjectKind.Build;
            getBuilderProgram(): T | undefined;
            getProgram(): Program | undefined;
            getSourceFile(fileName: string): SourceFile | undefined;
            getSourceFiles(): readonly SourceFile[];
            getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
            getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
            getConfigFileParsingDiagnostics(): readonly Diagnostic[];
            getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
            getAllDependencies(sourceFile: SourceFile): readonly string[];
            getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
            getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;
            emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult | undefined;
        }
        type InvalidatedProject<T extends BuilderProgram> = UpdateOutputFileStampsProject | BuildInvalidedProject<T>;
        function isBuildCommand(commandLineArgs: readonly string[]): boolean;
        function executeCommandLine(system: System, cb: ExecuteCommandLineCallbacks, commandLineArgs: readonly string[]): void | SolutionBuilder<EmitAndSemanticDiagnosticsBuilderProgram> | WatchOfConfigFile<EmitAndSemanticDiagnosticsBuilderProgram>;
        enum StatisticType {
            time = 0,
            count = 1,
            memory = 2
        }
        type ExecuteCommandLineCallbacks = (program: Program | BuilderProgram | ParsedCommandLine) => void;
        function createSyntacticTypeNodeBuilder(options: CompilerOptions, resolver: SyntacticTypeNodeBuilderResolver): SyntacticNodeBuilder;
        function getDefaultFormatCodeSettings(newLineCharacter?: string): FormatCodeSettings;
        interface IScriptSnapshot {
            getText(start: number, end: number): string;
            getLength(): number;
            getChangeRange(oldSnapshot: IScriptSnapshot): TextChangeRange | undefined;
            dispose?(): void;
        }
        namespace ScriptSnapshot {
            function fromString(text: string): IScriptSnapshot;
        }
        interface PreProcessedFileInfo {
            referencedFiles: FileReference[];
            typeReferenceDirectives: FileReference[];
            libReferenceDirectives: FileReference[];
            importedFiles: FileReference[];
            ambientExternalModules?: string[];
            isLibFile: boolean;
        }
        interface HostCancellationToken {
            isCancellationRequested(): boolean;
        }
        interface InstallPackageOptions {
            fileName: Path;
            packageName: string;
        }
        enum PackageJsonDependencyGroup {
            Dependencies = 1,
            DevDependencies = 2,
            PeerDependencies = 4,
            OptionalDependencies = 8,
            All = 15
        }
        interface ProjectPackageJsonInfo {
            fileName: string;
            parseable: boolean;
            dependencies?: Map<string, string>;
            devDependencies?: Map<string, string>;
            peerDependencies?: Map<string, string>;
            optionalDependencies?: Map<string, string>;
            get(dependencyName: string, inGroups?: PackageJsonDependencyGroup): string | undefined;
            has(dependencyName: string, inGroups?: PackageJsonDependencyGroup): boolean;
        }
        interface FormattingHost {
            getNewLine?(): string;
        }
        enum PackageJsonAutoImportPreference {
            Off = 0,
            On = 1,
            Auto = 2
        }
        interface PerformanceEvent {
            kind: "UpdateGraph" | "CreatePackageJsonAutoImportProvider";
            durationMs: number;
        }
        enum LanguageServiceMode {
            Semantic = 0,
            PartialSemantic = 1,
            Syntactic = 2
        }
        interface IncompleteCompletionsCache {
            get(): CompletionInfo | undefined;
            set(response: CompletionInfo): void;
            clear(): void;
        }
        interface LanguageServiceHost extends GetEffectiveTypeRootsHost, MinimalResolutionCacheHost {
            getCompilationSettings(): CompilerOptions;
            getNewLine?(): string;
            updateFromProject?(): void;
            updateFromProjectInProgress?: boolean;
            getProjectVersion?(): string;
            getScriptFileNames(): string[];
            getScriptKind?(fileName: string): ScriptKind;
            getScriptVersion(fileName: string): string;
            getScriptSnapshot(fileName: string): IScriptSnapshot | undefined;
            getProjectReferences?(): readonly ProjectReference[] | undefined;
            getLocalizedDiagnosticMessages?(): any;
            getCancellationToken?(): HostCancellationToken;
            getCurrentDirectory(): string;
            getDefaultLibFileName(options: CompilerOptions): string;
            log?(s: string): void;
            trace?(s: string): void;
            error?(s: string): void;
            useCaseSensitiveFileNames?(): boolean;
            readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
            realpath?(path: string): string;
            createHash?: ((data: string) => string) | undefined;
            readFile(path: string, encoding?: string): string | undefined;
            fileExists(path: string): boolean;
            getTypeRootsVersion?(): number;
            resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];
            getResolvedModuleWithFailedLookupLocationsFromCache?(modulename: string, containingFile: string, resolutionMode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations | undefined;
            resolveTypeReferenceDirectives?(typeDirectiveNames: string[] | FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];
            resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];
            resolveTypeReferenceDirectiveReferences?<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];
            resolveLibrary?(libraryName: string, resolveFrom: string, options: CompilerOptions, libFileName: string): ResolvedModuleWithFailedLookupLocations;
            hasInvalidatedLibResolutions?: ((libFileName: string) => boolean) | undefined;
            hasInvalidatedResolutions?: HasInvalidatedResolutions | undefined;
            hasChangedAutomaticTypeDirectiveNames?: HasChangedAutomaticTypeDirectiveNames;
            getGlobalTypingsCacheLocation?(): string | undefined;
            getSymlinkCache?(files?: readonly SourceFile[]): SymlinkCache;
            getModuleResolutionCache?(): ModuleResolutionCache | undefined;
            getDirectories?(directoryName: string): string[];
            getCustomTransformers?(): CustomTransformers | undefined;
            isKnownTypesPackageName?(name: string): boolean;
            installPackage?(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;
            writeFile?(fileName: string, content: string): void;
            getDocumentPositionMapper?(generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined;
            getSourceFileLike?(fileName: string): SourceFileLike | undefined;
            getPackageJsonsVisibleToFile?(fileName: string, rootDir?: string): readonly ProjectPackageJsonInfo[];
            getNearestAncestorDirectoryWithPackageJson?(fileName: string): string | undefined;
            getPackageJsonsForAutoImport?(rootDir?: string): readonly ProjectPackageJsonInfo[];
            getCachedExportInfoMap?(): ExportInfoMap;
            getModuleSpecifierCache?(): ModuleSpecifierCache;
            setCompilerHost?(host: CompilerHost): void;
            useSourceOfProjectReferenceRedirect?(): boolean;
            getPackageJsonAutoImportProvider?(): Program | undefined;
            sendPerformanceEvent?(kind: PerformanceEvent["kind"], durationMs: number): void;
            getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
            onReleaseParsedCommandLine?(configFileName: string, oldResolvedRef: ResolvedProjectReference | undefined, optionOptions: CompilerOptions): void;
            onReleaseOldSourceFile?(oldSourceFile: SourceFile, oldOptions: CompilerOptions, hasSourceFileByPath: boolean, newSourceFileByResolvedPath: SourceFile | undefined): void;
            getIncompleteCompletionsCache?(): IncompleteCompletionsCache;
            runWithTemporaryFileUpdate?(rootFile: string, updatedText: string, cb: (updatedProgram: Program, originalProgram: Program | undefined, updatedPastedText: SourceFile) => void): void;
            jsDocParsingMode?: JSDocParsingMode | undefined;
        }
        const emptyOptions: {};
        type WithMetadata<T> = T & {
            metadata?: unknown;
        };
        enum SemanticClassificationFormat {
            Original = "original",
            TwentyTwenty = "2020"
        }
        interface RegionDiagnosticsResult {
            diagnostics: Diagnostic[];
            spans: TextSpan[];
        }
        interface LanguageService {
            cleanupSemanticCache(): void;
            getSyntacticDiagnostics(fileName: string): DiagnosticWithLocation[];
            getSemanticDiagnostics(fileName: string): Diagnostic[];
            getRegionSemanticDiagnostics(fileName: string, ranges: TextRange[]): RegionDiagnosticsResult | undefined;
            getSuggestionDiagnostics(fileName: string): DiagnosticWithLocation[];
            getCompilerOptionsDiagnostics(): Diagnostic[];
            getSyntacticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];
            getSyntacticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];
            getSemanticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];
            getSemanticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];
            getEncodedSyntacticClassifications(fileName: string, span: TextSpan): Classifications;
            getEncodedSemanticClassifications(fileName: string, span: TextSpan, format?: SemanticClassificationFormat): Classifications;
            getCompletionsAtPosition(fileName: string, position: number, options: GetCompletionsAtPositionOptions | undefined, formattingSettings?: FormatCodeSettings): WithMetadata<CompletionInfo> | undefined;
            getCompletionEntryDetails(fileName: string, position: number, entryName: string, formatOptions: FormatCodeOptions | FormatCodeSettings | undefined, source: string | undefined, preferences: UserPreferences | undefined, data: CompletionEntryData | undefined): CompletionEntryDetails | undefined;
            getCompletionEntrySymbol(fileName: string, position: number, name: string, source: string | undefined): Symbol | undefined;
            getQuickInfoAtPosition(fileName: string, position: number): QuickInfo | undefined;
            getQuickInfoAtPosition(fileName: string, position: number, verbosityLevel: number | undefined): QuickInfo | undefined;
            getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): TextSpan | undefined;
            getBreakpointStatementAtPosition(fileName: string, position: number): TextSpan | undefined;
            getSignatureHelpItems(fileName: string, position: number, options: SignatureHelpItemsOptions | undefined): SignatureHelpItems | undefined;
            getRenameInfo(fileName: string, position: number, preferences: UserPreferences): RenameInfo;
            getRenameInfo(fileName: string, position: number, options?: RenameInfoOptions): RenameInfo;
            findRenameLocations(fileName: string, position: number, findInStrings: boolean, findInComments: boolean, preferences: UserPreferences): readonly RenameLocation[] | undefined;
            findRenameLocations(fileName: string, position: number, findInStrings: boolean, findInComments: boolean, providePrefixAndSuffixTextForRename?: boolean): readonly RenameLocation[] | undefined;
            getSmartSelectionRange(fileName: string, position: number): SelectionRange;
            getDefinitionAtPosition(fileName: string, position: number, searchOtherFilesOnly: false, stopAtAlias: boolean): readonly DefinitionInfo[] | undefined;
            getDefinitionAtPosition(fileName: string, position: number, searchOtherFilesOnly: boolean, stopAtAlias: false): readonly DefinitionInfo[] | undefined;
            getDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;
            getDefinitionAndBoundSpan(fileName: string, position: number): DefinitionInfoAndBoundSpan | undefined;
            getTypeDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;
            getImplementationAtPosition(fileName: string, position: number): readonly ImplementationLocation[] | undefined;
            getReferencesAtPosition(fileName: string, position: number): ReferenceEntry[] | undefined;
            findReferences(fileName: string, position: number): ReferencedSymbol[] | undefined;
            getDocumentHighlights(fileName: string, position: number, filesToSearch: string[]): DocumentHighlights[] | undefined;
            getFileReferences(fileName: string): ReferenceEntry[];
            getNavigateToItems(searchValue: string, maxResultCount?: number, fileName?: string, excludeDtsFiles?: boolean, excludeLibFiles?: boolean): NavigateToItem[];
            getNavigationBarItems(fileName: string): NavigationBarItem[];
            getNavigationTree(fileName: string): NavigationTree;
            prepareCallHierarchy(fileName: string, position: number): CallHierarchyItem | CallHierarchyItem[] | undefined;
            provideCallHierarchyIncomingCalls(fileName: string, position: number): CallHierarchyIncomingCall[];
            provideCallHierarchyOutgoingCalls(fileName: string, position: number): CallHierarchyOutgoingCall[];
            provideInlayHints(fileName: string, span: TextSpan, preferences: UserPreferences | undefined): InlayHint[];
            getOutliningSpans(fileName: string): OutliningSpan[];
            getTodoComments(fileName: string, descriptors: TodoCommentDescriptor[]): TodoComment[];
            getBraceMatchingAtPosition(fileName: string, position: number): TextSpan[];
            getIndentationAtPosition(fileName: string, position: number, options: EditorOptions | EditorSettings): number;
            getFormattingEditsForRange(fileName: string, start: number, end: number, options: FormatCodeOptions | FormatCodeSettings): TextChange[];
            getFormattingEditsForDocument(fileName: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];
            getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];
            getDocCommentTemplateAtPosition(fileName: string, position: number, options?: DocCommentTemplateOptions, formatOptions?: FormatCodeSettings): TextInsertion | undefined;
            isValidBraceCompletionAtPosition(fileName: string, position: number, openingBrace: number): boolean;
            getJsxClosingTagAtPosition(fileName: string, position: number): JsxClosingTagInfo | undefined;
            getLinkedEditingRangeAtPosition(fileName: string, position: number): LinkedEditingInfo | undefined;
            getSpanOfEnclosingComment(fileName: string, position: number, onlyMultiLine: boolean): TextSpan | undefined;
            toLineColumnOffset?(fileName: string, position: number): LineAndCharacter;
            getSourceMapper(): SourceMapper;
            clearSourceMapperCache(): void;
            getCodeFixesAtPosition(fileName: string, start: number, end: number, errorCodes: readonly number[], formatOptions: FormatCodeSettings, preferences: UserPreferences): readonly CodeFixAction[];
            getCombinedCodeFix(scope: CombinedCodeFixScope, fixId: {}, formatOptions: FormatCodeSettings, preferences: UserPreferences): CombinedCodeActions;
            applyCodeActionCommand(action: CodeActionCommand, formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult>;
            applyCodeActionCommand(action: CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult[]>;
            applyCodeActionCommand(action: CodeActionCommand | CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;
            applyCodeActionCommand(fileName: string, action: CodeActionCommand): Promise<ApplyCodeActionCommandResult>;
            applyCodeActionCommand(fileName: string, action: CodeActionCommand[]): Promise<ApplyCodeActionCommandResult[]>;
            applyCodeActionCommand(fileName: string, action: CodeActionCommand | CodeActionCommand[]): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;
            getApplicableRefactors(fileName: string, positionOrRange: number | TextRange, preferences: UserPreferences | undefined, triggerReason?: RefactorTriggerReason, kind?: string, includeInteractiveActions?: boolean): ApplicableRefactorInfo[];
            getEditsForRefactor(fileName: string, formatOptions: FormatCodeSettings, positionOrRange: number | TextRange, refactorName: string, actionName: string, preferences: UserPreferences | undefined, interactiveRefactorArguments?: InteractiveRefactorArguments): RefactorEditInfo | undefined;
            getMoveToRefactoringFileSuggestions(fileName: string, positionOrRange: number | TextRange, preferences: UserPreferences | undefined, triggerReason?: RefactorTriggerReason, kind?: string): {
                newFileName: string;
                files: string[];
            };
            organizeImports(args: OrganizeImportsArgs, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];
            getEditsForFileRename(oldFilePath: string, newFilePath: string, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];
            getEmitOutput(fileName: string, emitOnlyDtsFiles?: boolean, forceDtsEmit?: boolean): EmitOutput;
            getProgram(): Program | undefined;
            getCurrentProgram(): Program | undefined;
            getNonBoundSourceFile(fileName: string): SourceFile;
            getAutoImportProvider(): Program | undefined;
            updateIsDefinitionOfReferencedSymbols(referencedSymbols: readonly ReferencedSymbol[], knownSymbolSpans: Set<DocumentSpan>): boolean;
            toggleLineComment(fileName: string, textRange: TextRange): TextChange[];
            toggleMultilineComment(fileName: string, textRange: TextRange): TextChange[];
            commentSelection(fileName: string, textRange: TextRange): TextChange[];
            uncommentSelection(fileName: string, textRange: TextRange): TextChange[];
            getSupportedCodeFixes(fileName?: string): readonly string[];
            mapCode(fileName: string, contents: string[], focusLocations: TextSpan[][] | undefined, formatOptions: FormatCodeSettings, preferences: UserPreferences): readonly FileTextChanges[];
            dispose(): void;
            preparePasteEditsForFile(fileName: string, copiedTextRanges: TextRange[]): boolean;
            getPasteEdits(args: PasteEditsArgs, formatOptions: FormatCodeSettings): PasteEdits;
        }
        interface JsxClosingTagInfo {
            readonly newText: string;
        }
        interface LinkedEditingInfo {
            readonly ranges: TextSpan[];
            wordPattern?: string;
        }
        interface CombinedCodeFixScope {
            type: "file";
            fileName: string;
        }
        enum OrganizeImportsMode {
            All = "All",
            SortAndCombine = "SortAndCombine",
            RemoveUnused = "RemoveUnused"
        }
        interface PasteEdits {
            edits: readonly FileTextChanges[];
            fixId?: {};
        }
        interface PasteEditsArgs {
            targetFile: string;
            pastedText: string[];
            pasteLocations: TextRange[];
            copiedFrom: {
                file: string;
                range: TextRange[];
            } | undefined;
            preferences: UserPreferences;
        }
        interface OrganizeImportsArgs extends CombinedCodeFixScope {
            skipDestructiveCodeActions?: boolean;
            mode?: OrganizeImportsMode;
        }
        type CompletionsTriggerCharacter = "." | "\"" | "'" | "`" | "/" | "@" | "<" | "#" | " ";
        enum CompletionTriggerKind {
            Invoked = 1,
            TriggerCharacter = 2,
            TriggerForIncompleteCompletions = 3
        }
        interface GetCompletionsAtPositionOptions extends UserPreferences {
            triggerCharacter?: CompletionsTriggerCharacter;
            triggerKind?: CompletionTriggerKind;
            includeSymbol?: boolean;
            includeExternalModuleExports?: boolean;
            includeInsertTextCompletions?: boolean;
        }
        type SignatureHelpTriggerCharacter = "," | "(" | "<";
        type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";
        interface SignatureHelpItemsOptions {
            triggerReason?: SignatureHelpTriggerReason;
        }
        type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;
        interface SignatureHelpInvokedReason {
            kind: "invoked";
            triggerCharacter?: undefined;
        }
        interface SignatureHelpCharacterTypedReason {
            kind: "characterTyped";
            triggerCharacter: SignatureHelpTriggerCharacter;
        }
        interface SignatureHelpRetriggeredReason {
            kind: "retrigger";
            triggerCharacter?: SignatureHelpRetriggerCharacter;
        }
        interface ApplyCodeActionCommandResult {
            successMessage: string;
        }
        interface Classifications {
            spans: number[];
            endOfLineState: EndOfLineState;
        }
        interface ClassifiedSpan {
            textSpan: TextSpan;
            classificationType: ClassificationTypeNames;
        }
        interface ClassifiedSpan2020 {
            textSpan: TextSpan;
            classificationType: number;
        }
        interface NavigationBarItem {
            text: string;
            kind: ScriptElementKind;
            kindModifiers: string;
            spans: TextSpan[];
            childItems: NavigationBarItem[];
            indent: number;
            bolded: boolean;
            grayed: boolean;
        }
        interface NavigationTree {
            text: string;
            kind: ScriptElementKind;
            kindModifiers: string;
            spans: TextSpan[];
            nameSpan: TextSpan | undefined;
            childItems?: NavigationTree[];
        }
        interface CallHierarchyItem {
            name: string;
            kind: ScriptElementKind;
            kindModifiers?: string;
            file: string;
            span: TextSpan;
            selectionSpan: TextSpan;
            containerName?: string;
        }
        interface CallHierarchyIncomingCall {
            from: CallHierarchyItem;
            fromSpans: TextSpan[];
        }
        interface CallHierarchyOutgoingCall {
            to: CallHierarchyItem;
            fromSpans: TextSpan[];
        }
        enum InlayHintKind {
            Type = "Type",
            Parameter = "Parameter",
            Enum = "Enum"
        }
        interface InlayHint {
            text: string;
            position: number;
            kind: InlayHintKind;
            whitespaceBefore?: boolean;
            whitespaceAfter?: boolean;
            displayParts?: InlayHintDisplayPart[];
        }
        interface InlayHintDisplayPart {
            text: string;
            span?: TextSpan;
            file?: string;
        }
        interface TodoCommentDescriptor {
            text: string;
            priority: number;
        }
        interface TodoComment {
            descriptor: TodoCommentDescriptor;
            message: string;
            position: number;
        }
        interface TextChange {
            span: TextSpan;
            newText: string;
        }
        interface FileTextChanges {
            fileName: string;
            textChanges: readonly TextChange[];
            isNewFile?: boolean;
        }
        interface CodeAction {
            description: string;
            changes: FileTextChanges[];
            commands?: CodeActionCommand[];
        }
        interface CodeFixAction extends CodeAction {
            fixName: string;
            fixId?: {};
            fixAllDescription?: string;
        }
        interface CombinedCodeActions {
            changes: readonly FileTextChanges[];
            commands?: readonly CodeActionCommand[];
        }
        type CodeActionCommand = InstallPackageAction;
        interface InstallPackageAction {
            readonly type: "install package";
            readonly file: string;
            readonly packageName: string;
        }
        interface ApplicableRefactorInfo {
            name: string;
            description: string;
            inlineable?: boolean;
            actions: RefactorActionInfo[];
        }
        interface RefactorActionInfo {
            name: string;
            description: string;
            notApplicableReason?: string;
            kind?: string;
            isInteractive?: boolean;
            range?: {
                start: {
                    line: number;
                    offset: number;
                };
                end: {
                    line: number;
                    offset: number;
                };
            };
        }
        interface RefactorEditInfo {
            edits: FileTextChanges[];
            renameFilename?: string;
            renameLocation?: number;
            commands?: CodeActionCommand[];
            notApplicableReason?: string;
        }
        type RefactorTriggerReason = "implicit" | "invoked";
        interface TextInsertion {
            newText: string;
            caretOffset: number;
        }
        interface DocumentSpan {
            textSpan: TextSpan;
            fileName: string;
            originalTextSpan?: TextSpan;
            originalFileName?: string;
            contextSpan?: TextSpan;
            originalContextSpan?: TextSpan;
        }
        interface RenameLocation extends DocumentSpan {
            readonly prefixText?: string;
            readonly suffixText?: string;
        }
        interface ReferenceEntry extends DocumentSpan {
            isWriteAccess: boolean;
            isInString?: true;
        }
        interface ImplementationLocation extends DocumentSpan {
            kind: ScriptElementKind;
            displayParts: SymbolDisplayPart[];
        }
        enum HighlightSpanKind {
            none = "none",
            definition = "definition",
            reference = "reference",
            writtenReference = "writtenReference"
        }
        interface HighlightSpan {
            fileName?: string;
            isInString?: true;
            textSpan: TextSpan;
            contextSpan?: TextSpan;
            kind: HighlightSpanKind;
        }
        interface NavigateToItem {
            name: string;
            kind: ScriptElementKind;
            kindModifiers: string;
            matchKind: "exact" | "prefix" | "substring" | "camelCase";
            isCaseSensitive: boolean;
            fileName: string;
            textSpan: TextSpan;
            containerName: string;
            containerKind: ScriptElementKind;
        }
        enum IndentStyle {
            None = 0,
            Block = 1,
            Smart = 2
        }
        enum SemicolonPreference {
            Ignore = "ignore",
            Insert = "insert",
            Remove = "remove"
        }
        interface EditorOptions {
            BaseIndentSize?: number;
            IndentSize: number;
            TabSize: number;
            NewLineCharacter: string;
            ConvertTabsToSpaces: boolean;
            IndentStyle: IndentStyle;
        }
        interface EditorSettings {
            baseIndentSize?: number;
            indentSize?: number;
            tabSize?: number;
            newLineCharacter?: string;
            convertTabsToSpaces?: boolean;
            indentStyle?: IndentStyle;
            trimTrailingWhitespace?: boolean;
        }
        interface FormatCodeOptions extends EditorOptions {
            InsertSpaceAfterCommaDelimiter: boolean;
            InsertSpaceAfterSemicolonInForStatements: boolean;
            InsertSpaceBeforeAndAfterBinaryOperators: boolean;
            InsertSpaceAfterConstructor?: boolean;
            InsertSpaceAfterKeywordsInControlFlowStatements: boolean;
            InsertSpaceAfterFunctionKeywordForAnonymousFunctions: boolean;
            InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: boolean;
            InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: boolean;
            InsertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;
            InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: boolean;
            InsertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;
            InsertSpaceAfterTypeAssertion?: boolean;
            InsertSpaceBeforeFunctionParenthesis?: boolean;
            PlaceOpenBraceOnNewLineForFunctions: boolean;
            PlaceOpenBraceOnNewLineForControlBlocks: boolean;
            insertSpaceBeforeTypeAnnotation?: boolean;
        }
        interface FormatCodeSettings extends EditorSettings {
            readonly insertSpaceAfterCommaDelimiter?: boolean;
            readonly insertSpaceAfterSemicolonInForStatements?: boolean;
            readonly insertSpaceBeforeAndAfterBinaryOperators?: boolean;
            readonly insertSpaceAfterConstructor?: boolean;
            readonly insertSpaceAfterKeywordsInControlFlowStatements?: boolean;
            readonly insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;
            readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;
            readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;
            readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;
            readonly insertSpaceAfterOpeningAndBeforeClosingEmptyBraces?: boolean;
            readonly insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;
            readonly insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;
            readonly insertSpaceAfterTypeAssertion?: boolean;
            readonly insertSpaceBeforeFunctionParenthesis?: boolean;
            readonly placeOpenBraceOnNewLineForFunctions?: boolean;
            readonly placeOpenBraceOnNewLineForControlBlocks?: boolean;
            readonly insertSpaceBeforeTypeAnnotation?: boolean;
            readonly indentMultiLineObjectLiteralBeginningOnBlankLine?: boolean;
            readonly semicolons?: SemicolonPreference;
            readonly indentSwitchCase?: boolean;
        }
        const testFormatSettings: FormatCodeSettings;
        interface DefinitionInfo extends DocumentSpan {
            kind: ScriptElementKind;
            name: string;
            containerKind: ScriptElementKind;
            containerName: string;
            unverified?: boolean;
            isLocal?: boolean;
            isAmbient?: boolean;
            failedAliasResolution?: boolean;
        }
        interface DefinitionInfoAndBoundSpan {
            definitions?: readonly DefinitionInfo[];
            textSpan: TextSpan;
        }
        interface ReferencedSymbolDefinitionInfo extends DefinitionInfo {
            displayParts: SymbolDisplayPart[];
        }
        interface ReferencedSymbol {
            definition: ReferencedSymbolDefinitionInfo;
            references: ReferencedSymbolEntry[];
        }
        interface ReferencedSymbolEntry extends ReferenceEntry {
            isDefinition?: boolean;
        }
        enum SymbolDisplayPartKind {
            aliasName = 0,
            className = 1,
            enumName = 2,
            fieldName = 3,
            interfaceName = 4,
            keyword = 5,
            lineBreak = 6,
            numericLiteral = 7,
            stringLiteral = 8,
            localName = 9,
            methodName = 10,
            moduleName = 11,
            operator = 12,
            parameterName = 13,
            propertyName = 14,
            punctuation = 15,
            space = 16,
            text = 17,
            typeParameterName = 18,
            enumMemberName = 19,
            functionName = 20,
            regularExpressionLiteral = 21,
            link = 22,
            linkName = 23,
            linkText = 24
        }
        interface SymbolDisplayPart {
            text: string;
            kind: string;
        }
        interface JSDocLinkDisplayPart extends SymbolDisplayPart {
            target: DocumentSpan;
        }
        interface JSDocTagInfo {
            name: string;
            text?: SymbolDisplayPart[];
        }
        interface QuickInfo {
            kind: ScriptElementKind;
            kindModifiers: string;
            textSpan: TextSpan;
            displayParts?: SymbolDisplayPart[];
            documentation?: SymbolDisplayPart[];
            tags?: JSDocTagInfo[];
            canIncreaseVerbosityLevel?: boolean;
        }
        type RenameInfo = RenameInfoSuccess | RenameInfoFailure;
        interface RenameInfoSuccess {
            canRename: true;
            fileToRename?: string;
            displayName: string;
            fullDisplayName: string;
            kind: ScriptElementKind;
            kindModifiers: string;
            triggerSpan: TextSpan;
        }
        interface RenameInfoFailure {
            canRename: false;
            localizedErrorMessage: string;
        }
        interface RenameInfoOptions {
            readonly allowRenameOfImportPath?: boolean;
        }
        interface DocCommentTemplateOptions {
            readonly generateReturnInDocTemplate?: boolean;
        }
        interface InteractiveRefactorArguments {
            targetFile: string;
        }
        interface SignatureHelpParameter {
            name: string;
            documentation: SymbolDisplayPart[];
            displayParts: SymbolDisplayPart[];
            isOptional: boolean;
            isRest?: boolean;
        }
        interface SelectionRange {
            textSpan: TextSpan;
            parent?: SelectionRange;
        }
        interface SignatureHelpItem {
            isVariadic: boolean;
            prefixDisplayParts: SymbolDisplayPart[];
            suffixDisplayParts: SymbolDisplayPart[];
            separatorDisplayParts: SymbolDisplayPart[];
            parameters: SignatureHelpParameter[];
            documentation: SymbolDisplayPart[];
            tags: JSDocTagInfo[];
        }
        interface SignatureHelpItems {
            items: SignatureHelpItem[];
            applicableSpan: TextSpan;
            selectedItemIndex: number;
            argumentIndex: number;
            argumentCount: number;
        }
        enum CompletionInfoFlags {
            None = 0,
            MayIncludeAutoImports = 1,
            IsImportStatementCompletion = 2,
            IsContinuation = 4,
            ResolvedModuleSpecifiers = 8,
            ResolvedModuleSpecifiersBeyondLimit = 16,
            MayIncludeMethodSnippets = 32
        }
        interface CompletionInfo {
            flags?: CompletionInfoFlags;
            isGlobalCompletion: boolean;
            isMemberCompletion: boolean;
            optionalReplacementSpan?: TextSpan;
            isNewIdentifierLocation: boolean;
            isIncomplete?: true;
            entries: CompletionEntry[];
            defaultCommitCharacters?: string[];
        }
        interface CompletionEntryDataAutoImport {
            exportName: string;
            exportMapKey?: ExportMapInfoKey;
            moduleSpecifier?: string;
            fileName?: string;
            ambientModuleName?: string;
            isPackageJsonImport?: true;
        }
        interface CompletionEntryDataUnresolved extends CompletionEntryDataAutoImport {
            exportMapKey: ExportMapInfoKey;
        }
        interface CompletionEntryDataResolved extends CompletionEntryDataAutoImport {
            moduleSpecifier: string;
        }
        type CompletionEntryData = CompletionEntryDataUnresolved | CompletionEntryDataResolved;
        interface CompletionEntry {
            name: string;
            kind: ScriptElementKind;
            kindModifiers?: string;
            sortText: string;
            insertText?: string;
            filterText?: string;
            isSnippet?: true;
            replacementSpan?: TextSpan;
            hasAction?: true;
            source?: string;
            sourceDisplay?: SymbolDisplayPart[];
            labelDetails?: CompletionEntryLabelDetails;
            isRecommended?: true;
            isFromUncheckedFile?: true;
            isPackageJsonImport?: true;
            isImportStatementCompletion?: true;
            symbol?: Symbol;
            data?: CompletionEntryData;
            commitCharacters?: string[];
        }
        interface CompletionEntryLabelDetails {
            detail?: string;
            description?: string;
        }
        interface CompletionEntryDetails {
            name: string;
            kind: ScriptElementKind;
            kindModifiers: string;
            displayParts: SymbolDisplayPart[];
            documentation?: SymbolDisplayPart[];
            tags?: JSDocTagInfo[];
            codeActions?: CodeAction[];
            source?: SymbolDisplayPart[];
            sourceDisplay?: SymbolDisplayPart[];
        }
        interface OutliningSpan {
            textSpan: TextSpan;
            hintSpan: TextSpan;
            bannerText: string;
            autoCollapse: boolean;
            kind: OutliningSpanKind;
        }
        enum OutliningSpanKind {
            Comment = "comment",
            Region = "region",
            Code = "code",
            Imports = "imports"
        }
        enum OutputFileType {
            JavaScript = 0,
            SourceMap = 1,
            Declaration = 2
        }
        enum EndOfLineState {
            None = 0,
            InMultiLineCommentTrivia = 1,
            InSingleQuoteStringLiteral = 2,
            InDoubleQuoteStringLiteral = 3,
            InTemplateHeadOrNoSubstitutionTemplate = 4,
            InTemplateMiddleOrTail = 5,
            InTemplateSubstitutionPosition = 6
        }
        enum TokenClass {
            Punctuation = 0,
            Keyword = 1,
            Operator = 2,
            Comment = 3,
            Whitespace = 4,
            Identifier = 5,
            NumberLiteral = 6,
            BigIntLiteral = 7,
            StringLiteral = 8,
            RegExpLiteral = 9
        }
        interface ClassificationResult {
            finalLexState: EndOfLineState;
            entries: ClassificationInfo[];
        }
        interface ClassificationInfo {
            length: number;
            classification: TokenClass;
        }
        interface Classifier {
            getClassificationsForLine(text: string, lexState: EndOfLineState, syntacticClassifierAbsent: boolean): ClassificationResult;
            getEncodedLexicalClassifications(text: string, endOfLineState: EndOfLineState, syntacticClassifierAbsent: boolean): Classifications;
        }
        enum ScriptElementKind {
            unknown = "",
            warning = "warning",
            keyword = "keyword",
            scriptElement = "script",
            moduleElement = "module",
            classElement = "class",
            localClassElement = "local class",
            interfaceElement = "interface",
            typeElement = "type",
            enumElement = "enum",
            enumMemberElement = "enum member",
            variableElement = "var",
            localVariableElement = "local var",
            variableUsingElement = "using",
            variableAwaitUsingElement = "await using",
            functionElement = "function",
            localFunctionElement = "local function",
            memberFunctionElement = "method",
            memberGetAccessorElement = "getter",
            memberSetAccessorElement = "setter",
            memberVariableElement = "property",
            memberAccessorVariableElement = "accessor",
            constructorImplementationElement = "constructor",
            callSignatureElement = "call",
            indexSignatureElement = "index",
            constructSignatureElement = "construct",
            parameterElement = "parameter",
            typeParameterElement = "type parameter",
            primitiveType = "primitive type",
            label = "label",
            alias = "alias",
            constElement = "const",
            letElement = "let",
            directory = "directory",
            externalModuleName = "external module name",
            jsxAttribute = "JSX attribute",
            string = "string",
            link = "link",
            linkName = "link name",
            linkText = "link text"
        }
        enum ScriptElementKindModifier {
            none = "",
            publicMemberModifier = "public",
            privateMemberModifier = "private",
            protectedMemberModifier = "protected",
            exportedModifier = "export",
            ambientModifier = "declare",
            staticModifier = "static",
            abstractModifier = "abstract",
            optionalModifier = "optional",
            deprecatedModifier = "deprecated",
            dtsModifier = ".d.ts",
            tsModifier = ".ts",
            tsxModifier = ".tsx",
            jsModifier = ".js",
            jsxModifier = ".jsx",
            jsonModifier = ".json",
            dmtsModifier = ".d.mts",
            mtsModifier = ".mts",
            mjsModifier = ".mjs",
            dctsModifier = ".d.cts",
            ctsModifier = ".cts",
            cjsModifier = ".cjs"
        }
        enum ClassificationTypeNames {
            comment = "comment",
            identifier = "identifier",
            keyword = "keyword",
            numericLiteral = "number",
            bigintLiteral = "bigint",
            operator = "operator",
            stringLiteral = "string",
            whiteSpace = "whitespace",
            text = "text",
            punctuation = "punctuation",
            className = "class name",
            enumName = "enum name",
            interfaceName = "interface name",
            moduleName = "module name",
            typeParameterName = "type parameter name",
            typeAliasName = "type alias name",
            parameterName = "parameter name",
            docCommentTagName = "doc comment tag name",
            jsxOpenTagName = "jsx open tag name",
            jsxCloseTagName = "jsx close tag name",
            jsxSelfClosingTagName = "jsx self closing tag name",
            jsxAttribute = "jsx attribute",
            jsxText = "jsx text",
            jsxAttributeStringLiteralValue = "jsx attribute string literal value"
        }
        enum ClassificationType {
            comment = 1,
            identifier = 2,
            keyword = 3,
            numericLiteral = 4,
            operator = 5,
            stringLiteral = 6,
            regularExpressionLiteral = 7,
            whiteSpace = 8,
            text = 9,
            punctuation = 10,
            className = 11,
            enumName = 12,
            interfaceName = 13,
            moduleName = 14,
            typeParameterName = 15,
            typeAliasName = 16,
            parameterName = 17,
            docCommentTagName = 18,
            jsxOpenTagName = 19,
            jsxCloseTagName = 20,
            jsxSelfClosingTagName = 21,
            jsxAttribute = 22,
            jsxText = 23,
            jsxAttributeStringLiteralValue = 24,
            bigintLiteral = 25
        }
        interface CodeFixRegistration {
            errorCodes: readonly number[];
            getCodeActions(context: CodeFixContext): CodeFixAction[] | undefined;
            fixIds?: readonly string[];
            getAllCodeActions?(context: CodeFixAllContext): CombinedCodeActions;
        }
        interface CodeFixContextBase extends textChanges.TextChangesContext {
            sourceFile: SourceFile;
            program: Program;
            cancellationToken: CancellationToken;
            preferences: UserPreferences;
        }
        interface CodeFixAllContext extends CodeFixContextBase {
            fixId: {};
        }
        interface CodeFixContext extends CodeFixContextBase {
            errorCode: number;
            span: TextSpan;
        }
        interface Refactor {
            kinds?: string[];
            getEditsForAction(context: RefactorContext, actionName: string, interactiveRefactorArguments?: InteractiveRefactorArguments): RefactorEditInfo | undefined;
            getAvailableActions(context: RefactorContext, includeInteractive?: boolean, interactiveRefactorArguments?: InteractiveRefactorArguments): readonly ApplicableRefactorInfo[];
        }
        interface RefactorContext extends textChanges.TextChangesContext {
            file: SourceFile;
            startPosition: number;
            endPosition?: number;
            program: Program;
            cancellationToken?: CancellationToken;
            preferences: UserPreferences;
            triggerReason?: RefactorTriggerReason;
            kind?: string;
        }
        interface InlayHintsContext {
            file: SourceFile;
            program: Program;
            cancellationToken: CancellationToken;
            host: LanguageServiceHost;
            span: TextSpan;
            preferences: UserPreferences;
        }
        function getMeaningFromDeclaration(node: Node): SemanticMeaning;
        function getMeaningFromLocation(node: Node): SemanticMeaning;
        function isInRightSideOfInternalImportEqualsDeclaration(node: Node): boolean;
        function isCallExpressionTarget(node: Node, includeElementAccess?: boolean, skipPastOuterExpressions?: boolean): boolean;
        function isNewExpressionTarget(node: Node, includeElementAccess?: boolean, skipPastOuterExpressions?: boolean): boolean;
        function isCallOrNewExpressionTarget(node: Node, includeElementAccess?: boolean, skipPastOuterExpressions?: boolean): boolean;
        function isTaggedTemplateTag(node: Node, includeElementAccess?: boolean, skipPastOuterExpressions?: boolean): boolean;
        function isDecoratorTarget(node: Node, includeElementAccess?: boolean, skipPastOuterExpressions?: boolean): boolean;
        function isJsxOpeningLikeElementTagName(node: Node, includeElementAccess?: boolean, skipPastOuterExpressions?: boolean): boolean;
        function climbPastPropertyAccess(node: Node): Node;
        function getTargetLabel(referenceNode: Node, labelName: string): Identifier | undefined;
        function hasPropertyAccessExpressionWithName(node: CallExpression, funcName: string): boolean;
        function isJumpStatementTarget(node: Node): node is Identifier & {
            parent: BreakOrContinueStatement;
        };
        function isLabelOfLabeledStatement(node: Node): node is Identifier;
        function isLabelName(node: Node): boolean;
        function isTagName(node: Node): boolean;
        function isRightSideOfQualifiedName(node: Node): boolean;
        function isRightSideOfPropertyAccess(node: Node): boolean;
        function isArgumentExpressionOfElementAccess(node: Node): boolean;
        function isNameOfModuleDeclaration(node: Node): boolean;
        function isNameOfFunctionDeclaration(node: Node): boolean;
        function isLiteralNameOfPropertyDeclarationOrIndexAccess(node: StringLiteral | NumericLiteral | NoSubstitutionTemplateLiteral): boolean;
        function isExpressionOfExternalModuleImportEqualsDeclaration(node: Node): boolean;
        function getContainerNode(node: Node): Declaration | undefined;
        function getNodeKind(node: Node): ScriptElementKind;
        function isThis(node: Node): boolean;
        function getLineStartPositionForPosition(position: number, sourceFile: SourceFileLike): number;
        function rangeContainsRangeExclusive(r1: TextRange, r2: TextRange): boolean;
        function rangeContainsPosition(r: TextRange, pos: number): boolean;
        function rangeContainsPositionExclusive(r: TextRange, pos: number): boolean;
        function rangeContainsStartEnd(range: TextRange, start: number, end: number): boolean;
        function rangeOverlapsWithStartEnd(r1: TextRange, start: number, end: number): boolean;
        function nodeOverlapsWithStartEnd(node: Node, sourceFile: SourceFile, start: number, end: number): boolean;
        function startEndOverlapsWithStartEnd(start1: number, end1: number, start2: number, end2: number): boolean;
        function positionBelongsToNode(candidate: Node, position: number, sourceFile: SourceFile): boolean;
        function findListItemInfo(node: Node): ListItemInfo | undefined;
        function findChildOfKind<T extends Node>(n: Node, kind: T["kind"], sourceFile: SourceFileLike): T | undefined;
        function findContainingList(node: Node): SyntaxList | undefined;
        function getContextualTypeFromParentOrAncestorTypeNode(node: Expression, checker: TypeChecker): Type | undefined;
        function getAdjustedReferenceLocation(node: Node): Node;
        function getAdjustedRenameLocation(node: Node): Node;
        function getTouchingPropertyName(sourceFile: SourceFile, position: number): Node;
        function getTouchingToken(sourceFile: SourceFile, position: number, includePrecedingTokenAtEndPosition?: (n: Node) => boolean): Node;
        function getTokenAtPosition(sourceFile: SourceFile, position: number): Node;
        function findFirstNonJsxWhitespaceToken(sourceFile: SourceFile, position: number): Node | undefined;
        function findTokenOnLeftOfPosition(file: SourceFile, position: number): Node | undefined;
        function findNextToken(previousToken: Node, parent: Node, sourceFile: SourceFileLike): Node | undefined;
        function findPrecedingToken(position: number, sourceFile: SourceFileLike, startNode: Node, excludeJsdoc?: boolean): Node | undefined;
        function findPrecedingToken(position: number, sourceFile: SourceFile, startNode?: Node, excludeJsdoc?: boolean): Node | undefined;
        function isInString(sourceFile: SourceFile, position: number, previousToken?: Node | undefined): boolean;
        function isInsideJsxElementOrAttribute(sourceFile: SourceFile, position: number): boolean;
        function isInTemplateString(sourceFile: SourceFile, position: number): boolean;
        function isInJSXText(sourceFile: SourceFile, position: number): boolean;
        function isInsideJsxElement(sourceFile: SourceFile, position: number): boolean;
        function findPrecedingMatchingToken(token: Node, matchingTokenKind: SyntaxKind.OpenBraceToken | SyntaxKind.OpenParenToken | SyntaxKind.OpenBracketToken, sourceFile: SourceFile): Node | undefined;
        function isPossiblyTypeArgumentPosition(token: Node, sourceFile: SourceFile, checker: TypeChecker): boolean;
        function getPossibleGenericSignatures(called: Expression, typeArgumentCount: number, checker: TypeChecker): readonly Signature[];
        function getPossibleTypeArgumentsInfo(tokenIn: Node | undefined, sourceFile: SourceFile): PossibleTypeArgumentInfo | undefined;
        function isInComment(sourceFile: SourceFile, position: number, tokenAtPosition?: Node): CommentRange | undefined;
        function hasDocComment(sourceFile: SourceFile, position: number): boolean;
        function getNodeModifiers(node: Node, excludeFlags?: ModifierFlags): string;
        function getTypeArgumentOrTypeParameterList(node: Node): NodeArray<Node> | undefined;
        function isComment(kind: SyntaxKind): boolean;
        function isStringOrRegularExpressionOrTemplateLiteral(kind: SyntaxKind): boolean;
        function isStringAndEmptyAnonymousObjectIntersection(type: Type): boolean;
        function isInsideTemplateLiteral(node: TemplateLiteralToken, position: number, sourceFile: SourceFile): boolean;
        function isAccessibilityModifier(kind: SyntaxKind): boolean;
        function cloneCompilerOptions(options: CompilerOptions): CompilerOptions;
        function isArrayLiteralOrObjectLiteralDestructuringPattern(node: Node): boolean;
        function isInReferenceComment(sourceFile: SourceFile, position: number): boolean;
        function isInNonReferenceComment(sourceFile: SourceFile, position: number): boolean;
        function getReplacementSpanForContextToken(contextToken: Node | undefined, position: number): TextSpan | undefined;
        function createTextSpanFromNode(node: Node, sourceFile?: SourceFile, endNode?: Node): TextSpan;
        function createTextSpanFromStringLiteralLikeContent(node: StringLiteralLike, position: number): TextSpan | undefined;
        function createTextRangeFromNode(node: Node, sourceFile: SourceFile): TextRange;
        function createTextSpanFromRange(range: TextRange): TextSpan;
        function createTextRangeFromSpan(span: TextSpan): TextRange;
        function createTextChangeFromStartLength(start: number, length: number, newText: string): TextChange;
        function createTextChange(span: TextSpan, newText: string): TextChange;
        function isTypeKeyword(kind: SyntaxKind): boolean;
        function isTypeKeywordTokenOrIdentifier(node: Node): boolean;
        function nodeSeenTracker<T extends Node>(): NodeSeenTracker<T>;
        function getSnapshotText(snap: IScriptSnapshot): string;
        function repeatString(str: string, count: number): string;
        function skipConstraint(type: Type): Type;
        function getNameFromPropertyName(name: PropertyName): string | undefined;
        function programContainsModules(program: Program): boolean;
        function programContainsEsModules(program: Program): boolean;
        function compilerOptionsIndicateEsModules(compilerOptions: CompilerOptions): boolean;
        function createModuleSpecifierResolutionHost(program: Program, host: LanguageServiceHost): ModuleSpecifierResolutionHost;
        function getModuleSpecifierResolverHost(program: Program, host: LanguageServiceHost): SymbolTracker["moduleResolverHost"];
        function moduleResolutionUsesNodeModules(moduleResolution: ModuleResolutionKind): boolean;
        function makeImport(defaultImport: Identifier | undefined, namedImports: readonly ImportSpecifier[] | undefined, moduleSpecifier: string | Expression, quotePreference: QuotePreference, isTypeOnly?: boolean): ImportDeclaration;
        function makeStringLiteral(text: string, quotePreference: QuotePreference): StringLiteral;
        function quotePreferenceFromString(str: StringLiteral, sourceFile: SourceFile): QuotePreference;
        function getQuotePreference(sourceFile: SourceFile | FutureSourceFile, preferences: UserPreferences): QuotePreference;
        function getQuoteFromPreference(qp: QuotePreference): string;
        function symbolNameNoDefault(symbol: Symbol): string | undefined;
        function symbolEscapedNameNoDefault(symbol: Symbol): __String | undefined;
        function isModuleSpecifierLike(node: Node): node is StringLiteralLike;
        function isObjectBindingElementWithoutPropertyName(bindingElement: Node): bindingElement is ObjectBindingElementWithoutPropertyName;
        function getPropertySymbolFromBindingElement(checker: TypeChecker, bindingElement: ObjectBindingElementWithoutPropertyName): Symbol | undefined;
        function getParentNodeInSpan(node: Node | undefined, file: SourceFile, span: TextSpan): Node | undefined;
        function findModifier(node: Node, kind: Modifier["kind"]): Modifier | undefined;
        function insertImports(changes: textChanges.ChangeTracker, sourceFile: SourceFile | FutureSourceFile, imports: AnyImportOrRequireStatement | readonly AnyImportOrRequireStatement[], blankLineBetween: boolean, preferences: UserPreferences): void;
        function getTypeKeywordOfTypeOnlyImport(importClause: ImportClause, sourceFile: SourceFile): Token<SyntaxKind.TypeKeyword>;
        function textSpansEqual(a: TextSpan | undefined, b: TextSpan | undefined): boolean;
        function documentSpansEqual(a: DocumentSpan, b: DocumentSpan, useCaseSensitiveFileNames: boolean): boolean;
        function getDocumentSpansEqualityComparer(useCaseSensitiveFileNames: boolean): EqualityComparer<DocumentSpan>;
        function forEachUnique<T, U>(array: readonly T[] | undefined, callback: (element: T, index: number) => U): U | undefined;
        function isTextWhiteSpaceLike(text: string, startPos: number, endPos: number): boolean;
        function getMappedLocation(location: DocumentPosition, sourceMapper: SourceMapper, fileExists: ((path: string) => boolean) | undefined): DocumentPosition | undefined;
        function getMappedDocumentSpan(documentSpan: DocumentSpan, sourceMapper: SourceMapper, fileExists?: (path: string) => boolean): DocumentSpan | undefined;
        function getMappedContextSpan(documentSpan: DocumentSpan, sourceMapper: SourceMapper, fileExists?: (path: string) => boolean): TextSpan | undefined;
        function isFirstDeclarationOfSymbolParameter(symbol: Symbol): boolean;
        function displayPart(text: string, kind: SymbolDisplayPartKind): SymbolDisplayPart;
        function spacePart(): SymbolDisplayPart;
        function keywordPart(kind: SyntaxKind): SymbolDisplayPart;
        function punctuationPart(kind: SyntaxKind): SymbolDisplayPart;
        function operatorPart(kind: SyntaxKind): SymbolDisplayPart;
        function parameterNamePart(text: string): SymbolDisplayPart;
        function propertyNamePart(text: string): SymbolDisplayPart;
        function textOrKeywordPart(text: string): SymbolDisplayPart;
        function textPart(text: string): SymbolDisplayPart;
        function typeAliasNamePart(text: string): SymbolDisplayPart;
        function typeParameterNamePart(text: string): SymbolDisplayPart;
        function buildLinkParts(link: JSDocLink | JSDocLinkCode | JSDocLinkPlain, checker?: TypeChecker): SymbolDisplayPart[];
        function getNewLineOrDefaultFromHost(host: FormattingHost, formatSettings: FormatCodeSettings | undefined): string;
        function lineBreakPart(): SymbolDisplayPart;
        function mapToDisplayParts(writeDisplayParts: (writer: DisplayPartsSymbolWriter) => void): SymbolDisplayPart[];
        function typeToDisplayParts(typechecker: TypeChecker, type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags, verbosityLevel?: number, out?: WriterContextOut): SymbolDisplayPart[];
        function symbolToDisplayParts(typeChecker: TypeChecker, symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): SymbolDisplayPart[];
        function signatureToDisplayParts(typechecker: TypeChecker, signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, verbosityLevel?: number, out?: WriterContextOut): SymbolDisplayPart[];
        function isImportOrExportSpecifierName(location: Node): location is Identifier;
        function getScriptKind(fileName: string, host: LanguageServiceHost): ScriptKind;
        function getSymbolTarget(symbol: Symbol, checker: TypeChecker): Symbol;
        function getUniqueSymbolId(symbol: Symbol, checker: TypeChecker): number;
        function getFirstNonSpaceCharacterPosition(text: string, position: number): number;
        function getPrecedingNonSpaceCharacterPosition(text: string, position: number): number;
        function copyComments(sourceNode: Node, targetNode: Node): void;
        function getUniqueName(baseName: string, sourceFile: SourceFile): string;
        function getRenameLocation(edits: readonly FileTextChanges[], renameFilename: string, name: string, preferLastLocation: boolean): number;
        function copyLeadingComments(sourceNode: Node, targetNode: Node, sourceFile: SourceFile, commentKind?: CommentKind, hasTrailingNewLine?: boolean): void;
        function copyTrailingComments(sourceNode: Node, targetNode: Node, sourceFile: SourceFile, commentKind?: CommentKind, hasTrailingNewLine?: boolean): void;
        function copyTrailingAsLeadingComments(sourceNode: Node, targetNode: Node, sourceFile: SourceFile, commentKind?: CommentKind, hasTrailingNewLine?: boolean): void;
        function needsParentheses(expression: Expression): boolean;
        function getContextualTypeFromParent(node: Expression, checker: TypeChecker, contextFlags?: ContextFlags): Type | undefined;
        function quote(sourceFile: SourceFile, preferences: UserPreferences, text: string): string;
        function isEqualityOperatorKind(kind: SyntaxKind): kind is EqualityOperator;
        function isStringLiteralOrTemplate(node: Node): node is StringLiteralLike | TemplateExpression | TaggedTemplateExpression;
        function hasIndexSignature(type: Type): boolean;
        function getSwitchedType(caseClause: CaseClause, checker: TypeChecker): Type | undefined;
        function getTypeNodeIfAccessible(type: Type, enclosingScope: Node, program: Program, host: LanguageServiceHost): TypeNode | undefined;
        function positionIsASICandidate(pos: number, context: Node, sourceFile: SourceFileLike): boolean;
        function probablyUsesSemicolons(sourceFile: SourceFile): boolean;
        function tryGetDirectories(host: Pick<LanguageServiceHost, "getDirectories">, directoryName: string): string[];
        function tryReadDirectory(host: Pick<LanguageServiceHost, "readDirectory">, path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[]): readonly string[];
        function tryFileExists(host: Pick<LanguageServiceHost, "fileExists">, path: string): boolean;
        function tryDirectoryExists(host: LanguageServiceHost, path: string): boolean;
        function tryAndIgnoreErrors<T>(cb: () => T): T | undefined;
        function findPackageJsons(startDirectory: string, host: LanguageServiceHost): string[];
        function findPackageJson(directory: string, host: LanguageServiceHost): string | undefined;
        function createPackageJsonInfo(fileName: string, host: {
            readFile?(fileName: string): string | undefined;
        }): ProjectPackageJsonInfo | undefined;
        function createPackageJsonImportFilter(fromFile: SourceFile | FutureSourceFile, preferences: UserPreferences, host: LanguageServiceHost): PackageJsonImportFilter;
        function consumesNodeCoreModules(sourceFile: SourceFile): boolean;
        function isInsideNodeModules(fileOrDirectory: string): boolean;
        function findDiagnosticForNode(node: Node, sortedFileDiagnostics: readonly Diagnostic[]): DiagnosticWithLocation | undefined;
        function getDiagnosticsWithinSpan(span: TextSpan, sortedFileDiagnostics: readonly Diagnostic[]): readonly DiagnosticWithLocation[];
        function getRefactorContextSpan({ startPosition, endPosition }: RefactorContext): TextSpan;
        function getFixableErrorSpanExpression(sourceFile: SourceFile, span: TextSpan): Expression | undefined;
        function mapOneOrMany<T, U>(valueOrArray: T | readonly T[], f: (x: T, i: number) => U): U | U[];
        function mapOneOrMany<T, U>(valueOrArray: T | readonly T[] | undefined, f: (x: T, i: number) => U): U | U[] | undefined;
        function mapOneOrMany<T, U>(valueOrArray: T | readonly T[], f: (x: T, i: number) => U, resultSelector: (x: U[]) => U): U;
        function mapOneOrMany<T, U>(valueOrArray: T | readonly T[] | undefined, f: (x: T, i: number) => U, resultSelector: (x: U[]) => U): U | undefined;
        function firstOrOnly<T>(valueOrArray: T | readonly T[]): T;
        function getNameForExportedSymbol(symbol: Symbol, scriptTarget: ScriptTarget | undefined, preferCapitalized?: boolean): string;
        function getDefaultLikeExportNameFromDeclaration(symbol: Symbol): string | undefined;
        function moduleSymbolToValidIdentifier(moduleSymbol: Symbol, target: ScriptTarget | undefined, forceCapitalize: boolean): string;
        function moduleSpecifierToValidIdentifier(moduleSpecifier: string, target: ScriptTarget | undefined, forceCapitalize?: boolean): string;
        function stringContainsAt(haystack: string, needle: string, startIndex: number): boolean;
        function startsWithUnderscore(name: string): boolean;
        function isDeprecatedDeclaration(decl: Declaration): boolean;
        function shouldUseUriStyleNodeCoreModules(file: SourceFile | FutureSourceFile, program: Program): boolean | undefined;
        function getNewLineKind(newLineCharacter: string): NewLineKind;
        function diagnosticToString(diag: DiagnosticOrDiagnosticAndArguments): string;
        function getFormatCodeSettingsForWriting({ options }: formatting.FormatContext, sourceFile: SourceFile): FormatCodeSettings;
        function jsxModeNeedsExplicitImport(jsx: JsxEmit | undefined): jsx is JsxEmit.React | JsxEmit.ReactNative;
        function isSourceFileFromLibrary(program: Program, node: SourceFile): boolean;
        function newCaseClauseTracker(checker: TypeChecker, clauses: readonly (CaseClause | DefaultClause)[]): CaseClauseTracker;
        function fileShouldUseJavaScriptRequire(file: SourceFile | string, program: Program, host: LanguageServiceHost, preferRequire?: boolean): boolean | undefined;
        function isBlockLike(node: Node): node is BlockLike;
        function createFutureSourceFile(fileName: string, syntaxModuleIndicator: ModuleKind.ESNext | ModuleKind.CommonJS | undefined, program: Program, moduleResolutionHost: ModuleResolutionHost): FutureSourceFile;
        const scanner: Scanner;
        enum SemanticMeaning {
            None = 0,
            Value = 1,
            Type = 2,
            Namespace = 4,
            All = 7
        }
        interface ListItemInfo {
            listItemIndex: number;
            list: Node;
        }
        interface PossibleTypeArgumentInfo {
            readonly called: Identifier;
            readonly nTypeArguments: number;
        }
        interface PossibleProgramFileInfo {
            ProgramFiles?: string[];
        }
        const typeKeywords: readonly SyntaxKind[];
        type NodeSeenTracker<T = Node> = (node: T) => boolean;
        enum QuotePreference {
            Single = 0,
            Double = 1
        }
        type ObjectBindingElementWithoutPropertyName = BindingElement & {
            name: Identifier;
        };
        const ANONYMOUS = "anonymous function";
        interface PackageJsonImportFilter {
            allowsImportingAmbientModule: (moduleSymbol: Symbol, moduleSpecifierResolutionHost: ModuleSpecifierResolutionHost) => boolean;
            getSourceFileInfo: (sourceFile: SourceFile, moduleSpecifierResolutionHost: ModuleSpecifierResolutionHost) => {
                importable: boolean;
                packageName?: string;
            };
            allowsImportingSpecifier: (moduleSpecifier: string) => boolean;
        }
        type DiagnosticOrDiagnosticAndArguments = DiagnosticMessage | DiagnosticAndArguments;
        interface CaseClauseTracker {
            addValue(value: string | number): void;
            hasValue(value: string | number | PseudoBigInt): boolean;
        }
        function createCacheableExportInfoMap(host: CacheableExportInfoMapHost): ExportInfoMap;
        function isImportable(program: Program, fromFile: SourceFile, toFile: SourceFile | undefined, toModule: Symbol, preferences: UserPreferences, packageJsonFilter: PackageJsonImportFilter | undefined, moduleSpecifierResolutionHost: ModuleSpecifierResolutionHost, moduleSpecifierCache: ModuleSpecifierCache | undefined): boolean;
        function forEachExternalModuleToImportFrom(program: Program, host: LanguageServiceHost, preferences: UserPreferences, useAutoImportProvider: boolean, cb: (module: Symbol, moduleFile: SourceFile | undefined, program: Program, isFromPackageJson: boolean) => void): void;
        function getIsFileExcluded(host: LanguageServiceHost, preferences: UserPreferences): (sourceFile: SourceFile) => boolean;
        function getExportInfoMap(importingFile: SourceFile | FutureSourceFile, host: LanguageServiceHost, program: Program, preferences: UserPreferences, cancellationToken: CancellationToken | undefined): ExportInfoMap;
        function getDefaultLikeExportInfo(moduleSymbol: Symbol, checker: TypeChecker): {
            symbol: Symbol;
            exportKind: ExportKind;
        } | undefined;
        function forEachNameOfDefaultExport<T>(defaultExport: Symbol, checker: TypeChecker, scriptTarget: ScriptTarget | undefined, cb: (name: string, capitalizedName?: string) => T | undefined): T | undefined;
        enum ImportKind {
            Named = 0,
            Default = 1,
            Namespace = 2,
            CommonJS = 3
        }
        enum ExportKind {
            Named = 0,
            Default = 1,
            ExportEquals = 2,
            UMD = 3,
            Module = 4
        }
        interface SymbolExportInfo {
            readonly symbol: Symbol;
            readonly moduleSymbol: Symbol;
            moduleFileName: string | undefined;
            exportKind: ExportKind;
            targetFlags: SymbolFlags;
            isFromPackageJson: boolean;
        }
        type FutureSymbolExportInfo = Omit<SymbolExportInfo, "symbol"> & {
            readonly symbol?: undefined;
        };
        interface ExportInfoMap {
            isUsableByFile(importingFile: Path): boolean;
            clear(): void;
            add(importingFile: Path, symbol: Symbol, key: __String, moduleSymbol: Symbol, moduleFile: SourceFile | undefined, exportKind: ExportKind, isFromPackageJson: boolean, checker: TypeChecker): void;
            get(importingFile: Path, key: ExportMapInfoKey): readonly SymbolExportInfo[] | undefined;
            search<T>(importingFile: Path, preferCapitalized: boolean, matches: (name: string, targetFlags: SymbolFlags) => boolean, action: (info: readonly SymbolExportInfo[], symbolName: string, isFromAmbientModule: boolean, key: ExportMapInfoKey) => T | undefined): T | undefined;
            releaseSymbols(): void;
            isEmpty(): boolean;
            onFileChanged(oldSourceFile: SourceFile, newSourceFile: SourceFile, typeAcquisitionEnabled: boolean): boolean;
        }
        interface CacheableExportInfoMapHost {
            getCurrentProgram(): Program | undefined;
            getPackageJsonAutoImportProvider(): Program | undefined;
            getGlobalTypingsCacheLocation(): string | undefined;
        }
        type ExportMapInfoKey = string & {
            __exportInfoKey: void;
        };
        function createClassifier(): Classifier;
        function getSemanticClassifications(typeChecker: TypeChecker, cancellationToken: CancellationToken, sourceFile: SourceFile, classifiableNames: ReadonlySet<__String>, span: TextSpan): ClassifiedSpan[];
        function getEncodedSemanticClassifications(typeChecker: TypeChecker, cancellationToken: CancellationToken, sourceFile: SourceFile, classifiableNames: ReadonlySet<__String>, span: TextSpan): Classifications;
        function getSyntacticClassifications(cancellationToken: CancellationToken, sourceFile: SourceFile, span: TextSpan): ClassifiedSpan[];
        function getEncodedSyntacticClassifications(cancellationToken: CancellationToken, sourceFile: SourceFile, span: TextSpan): Classifications;
        interface DocumentHighlights {
            fileName: string;
            highlightSpans: HighlightSpan[];
        }
        namespace DocumentHighlights {
            function getDocumentHighlights(program: Program, cancellationToken: CancellationToken, sourceFile: SourceFile, position: number, sourceFilesToSearch: readonly SourceFile[]): DocumentHighlights[] | undefined;
        }
        function isDocumentRegistryEntry(entry: BucketEntry): entry is DocumentRegistryEntry;
        function createDocumentRegistry(useCaseSensitiveFileNames?: boolean, currentDirectory?: string, jsDocParsingMode?: JSDocParsingMode): DocumentRegistry;
        function createDocumentRegistryInternal(useCaseSensitiveFileNames?: boolean, currentDirectory?: string, jsDocParsingMode?: JSDocParsingMode, externalCache?: ExternalDocumentCache): DocumentRegistry;
        interface DocumentRegistry {
            acquireDocument(fileName: string, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
            acquireDocumentWithKey(fileName: string, path: Path, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
            updateDocument(fileName: string, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
            updateDocumentWithKey(fileName: string, path: Path, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
            getKeyForCompilationSettings(settings: CompilerOptions): DocumentRegistryBucketKey;
            getDocumentRegistryBucketKeyWithMode(key: DocumentRegistryBucketKey, mode: ResolutionMode): DocumentRegistryBucketKeyWithMode;
            releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind?: ScriptKind): void;
            releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind: ScriptKind, impliedNodeFormat: ResolutionMode): void;
            releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind?: ScriptKind): void;
            releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind: ScriptKind, impliedNodeFormat: ResolutionMode): void;
            reportStats(): string;
            getBuckets(): Map<DocumentRegistryBucketKeyWithMode, Map<Path, BucketEntry>>;
        }
        interface ExternalDocumentCache {
            setDocument(key: DocumentRegistryBucketKeyWithMode, path: Path, sourceFile: SourceFile): void;
            getDocument(key: DocumentRegistryBucketKeyWithMode, path: Path): SourceFile | undefined;
        }
        type DocumentRegistryBucketKey = string & {
            __bucketKey: any;
        };
        interface DocumentRegistryEntry {
            sourceFile: SourceFile;
            languageServiceRefCount: number;
        }
        type BucketEntry = DocumentRegistryEntry | Map<ScriptKind, DocumentRegistryEntry>;
        type DocumentRegistryBucketKeyWithMode = string & {
            __documentRegistryBucketKeyWithMode: any;
        };
        function getEditsForFileRename(program: Program, oldFileOrDirPath: string, newFileOrDirPath: string, host: LanguageServiceHost, formatContext: formatting.FormatContext, preferences: UserPreferences, sourceMapper: SourceMapper): readonly FileTextChanges[];
        function getPathUpdater(oldFileOrDirPath: string, newFileOrDirPath: string, getCanonicalFileName: GetCanonicalFileName, sourceMapper: SourceMapper | undefined): PathUpdater;
        type PathUpdater = (path: string) => string | undefined;
        function createPatternMatcher(pattern: string): PatternMatcher | undefined;
        function breakIntoCharacterSpans(identifier: string): TextSpan[];
        function breakIntoWordSpans(identifier: string): TextSpan[];
        enum PatternMatchKind {
            exact = 0,
            prefix = 1,
            substring = 2,
            camelCase = 3
        }
        interface PatternMatch {
            kind: PatternMatchKind;
            isCaseSensitive: boolean;
        }
        interface PatternMatcher {
            getMatchForLastSegmentOfPattern(candidate: string): PatternMatch | undefined;
            getFullMatch(candidateContainers: readonly string[], candidate: string): PatternMatch | undefined;
            patternContainsDots: boolean;
        }
        function preProcessFile(sourceText: string, readImportFiles?: boolean, detectJavaScriptImports?: boolean): PreProcessedFileInfo;
        function getSourceMapper(host: SourceMapperHost): SourceMapper;
        function getDocumentPositionMapper(host: DocumentPositionMapperHost, generatedFileName: string, generatedFileLineInfo: LineInfo, readMapFile: ReadMapFile): DocumentPositionMapper | undefined;
        interface SourceMapper {
            toLineColumnOffset(fileName: string, position: number): LineAndCharacter;
            tryGetSourcePosition(info: DocumentPosition): DocumentPosition | undefined;
            tryGetGeneratedPosition(info: DocumentPosition): DocumentPosition | undefined;
            clearCache(): void;
            documentPositionMappers: Map<string, DocumentPositionMapper>;
        }
        interface SourceMapperHost {
            useCaseSensitiveFileNames(): boolean;
            getCurrentDirectory(): string;
            getProgram(): Program | undefined;
            fileExists?(path: string): boolean;
            readFile?(path: string, encoding?: string): string | undefined;
            getSourceFileLike?(fileName: string): SourceFileLike | undefined;
            getDocumentPositionMapper?(generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined;
            log(s: string): void;
        }
        type ReadMapFile = (mapFileName: string, mapFileNameFromDts: string | undefined) => string | undefined | DocumentPositionMapper | false;
        function computeSuggestionDiagnostics(sourceFile: SourceFile, program: Program, cancellationToken: CancellationToken): DiagnosticWithLocation[];
        function returnsPromise(node: FunctionLikeDeclaration, checker: TypeChecker): boolean;
        function isReturnStatementWithFixablePromiseHandler(node: Node, checker: TypeChecker): node is ReturnStatement & {
            expression: CallExpression;
        };
        function isFixablePromiseHandler(node: Node, checker: TypeChecker): boolean;
        function canBeConvertedToAsync(node: Node): node is FunctionDeclaration | MethodDeclaration | FunctionExpression | ArrowFunction;
        function transpileModule(input: string, transpileOptions: TranspileOptions): TranspileOutput;
        function transpileDeclaration(input: string, transpileOptions: TranspileOptions): TranspileOutput;
        function transpile(input: string, compilerOptions?: CompilerOptions, fileName?: string, diagnostics?: Diagnostic[], moduleName?: string): string;
        function fixupCompilerOptions(options: CompilerOptions, diagnostics: Diagnostic[]): CompilerOptions;
        interface TranspileOptions {
            compilerOptions?: CompilerOptions;
            fileName?: string;
            reportDiagnostics?: boolean;
            moduleName?: string;
            renamedDependencies?: MapLike<string>;
            transformers?: CustomTransformers;
            jsDocParsingMode?: JSDocParsingMode;
        }
        interface TranspileOutput {
            outputText: string;
            diagnostics?: Diagnostic[];
            sourceMapText?: string;
        }
        function toEditorSettings(options: FormatCodeOptions | FormatCodeSettings): FormatCodeSettings;
        function toEditorSettings(options: EditorOptions | EditorSettings): EditorSettings;
        function displayPartsToString(displayParts: SymbolDisplayPart[] | undefined): string;
        function getDefaultCompilerOptions(): CompilerOptions;
        function getSupportedCodeFixes(): readonly string[];
        function createLanguageServiceSourceFile(fileName: string, scriptSnapshot: IScriptSnapshot, scriptTargetOrOptions: ScriptTarget | CreateSourceFileOptions, version: string, setNodeParents: boolean, scriptKind?: ScriptKind): SourceFile;
        function updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange | undefined, aggressiveChecks?: boolean): SourceFile;
        function createLanguageService(host: LanguageServiceHost, documentRegistry?: DocumentRegistry, syntaxOnlyOrLanguageServiceMode?: boolean | LanguageServiceMode): LanguageService;
        function getNameTable(sourceFile: SourceFile): Map<__String, number>;
        function getContainingObjectLiteralElement(node: Node): ObjectLiteralElementWithName | undefined;
        function getPropertySymbolsFromContextualType(node: ObjectLiteralElementWithName, checker: TypeChecker, contextualType: Type, unionSymbolOk: boolean): readonly Symbol[];
        function getDefaultLibFilePath(options: CompilerOptions): string;
        const servicesVersion = "0.8";
        interface DisplayPartsSymbolWriter extends EmitTextWriter {
            displayParts(): SymbolDisplayPart[];
        }
        class ThrottledCancellationToken implements CancellationToken {
            private hostCancellationToken;
            private readonly throttleWaitMilliseconds;
            private lastCancellationCheckTime;
            constructor(hostCancellationToken: HostCancellationToken, throttleWaitMilliseconds?: number);
            isCancellationRequested(): boolean;
            throwIfCancellationRequested(): void;
        }
        type ObjectLiteralElementWithName = ObjectLiteralElement & {
            name: PropertyName;
            parent: ObjectLiteralExpression | JsxAttributes;
        };
        function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions): TransformationResult<T>;
        function createOverload<T extends OverloadDefinitions>(name: string, overloads: T, binder: OverloadBinders<T>, deprecations?: OverloadDeprecations<T>): OverloadFunction<T>;
        function buildOverload(name: string): OverloadBuilder;
        interface DeprecationOptions {
            message?: string;
            error?: boolean;
            since?: Version | string;
            warnAfter?: Version | string;
            errorAfter?: Version | string;
            typeScriptVersion?: Version | string;
            name?: string;
        }
        type OverloadDefinitions = {
            readonly [P in number]: (...args: any[]) => any;
        };
        type OverloadKeys<T extends OverloadDefinitions> = Extract<keyof T, number>;
        type OverloadParameters<T extends OverloadDefinitions> = Parameters<{
            [P in OverloadKeys<T>]: T[P];
        }[OverloadKeys<T>]>;
        type OverloadFunction<T extends OverloadDefinitions> = UnionToIntersection<T[keyof T]>;
        type OverloadBinders<T extends OverloadDefinitions> = {
            [P in OverloadKeys<T>]: (args: OverloadParameters<T>) => boolean | undefined;
        };
        type OverloadDeprecations<T extends OverloadDefinitions> = {
            [P in OverloadKeys<T>]?: DeprecationOptions;
        };
        interface OverloadBuilder {
            overload<T extends OverloadDefinitions>(overloads: T): BindableOverloadBuilder<T>;
        }
        interface BindableOverloadBuilder<T extends OverloadDefinitions> {
            bind(binder: OverloadBinders<T>): BoundOverloadBuilder<T>;
        }
        interface FinishableOverloadBuilder<T extends OverloadDefinitions> {
            finish(): OverloadFunction<T>;
        }
        interface BoundOverloadBuilder<T extends OverloadDefinitions> extends FinishableOverloadBuilder<T> {
            deprecate(deprecations: OverloadDeprecations<T>): FinishableOverloadBuilder<T>;
        }
    }
    export = ts;
}

// declare module "typescript/lib/tsserverlibrary" {
//     import ts = require("./typescript");
//     export = ts;
// }
